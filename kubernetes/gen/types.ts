// *** Copyright 2020 Brandon Kalinowski. ***
// *** WARNING: this file was generated by the apigen generation tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

export namespace admissionregistration {
	export namespace v1 {
		/**
		 * MutatingWebhook describes an admission webhook and the resources and operations it applies
		 * to.
		 */
		export interface MutatingWebhook {
			/**
			 * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
			 * Webhook expects. API server will try to use first version in the list which it supports. If
			 * none of the versions specified in this list supported by API server, validation will fail
			 * for this object. If a persisted webhook configuration specifies allowed versions and does
			 * not include any versions known to the API Server, calls to the webhook will fail and be
			 * subject to the failure policy.
			 */
			admissionReviewVersions: string[]

			/**
			 * ClientConfig defines how to communicate with the hook. Required
			 */
			clientConfig: admissionregistration.v1.WebhookClientConfig

			/**
			 * The name of the admission webhook. Name should be fully qualified, e.g.,
			 * imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
			 * kubernetes.io is the name of the organization. Required.
			 */
			name: string

			/**
			 * SideEffects states whether this webhook has side effects. Acceptable values are: None,
			 * NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks with
			 * side effects MUST implement a reconciliation system, since a request may be rejected by a
			 * future step in the admission change and the side effects therefore need to be undone.
			 * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
			 * sideEffects == Unknown or Some.
			 */
			sideEffects: string

			/**
			 * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
			 * allowed values are Ignore or Fail. Defaults to Fail.
			 */
			failurePolicy?: string

			/**
			 * matchPolicy defines how the "rules" list is used to match incoming requests. Allowed values
			 * are "Exact" or "Equivalent".
			 *
			 * - Exact: match a request only if it exactly matches a specified rule. For example, if
			 * deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but "rules"
			 * only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a
			 * request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
			 *
			 * - Equivalent: match a request if modifies a resource listed in rules, even via another API
			 * group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1,
			 * and extensions/v1beta1, and "rules" only included `apiGroups:["apps"], apiVersions:["v1"],
			 * resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would be
			 * converted to apps/v1 and sent to the webhook.
			 *
			 * Defaults to "Equivalent"
			 */
			matchPolicy?: string

			/**
			 * NamespaceSelector decides whether to run the webhook on an object based on whether the
			 * namespace for that object matches the selector. If the object itself is a namespace, the
			 * matching is performed on object.metadata.labels. If the object is another cluster scoped
			 * resource, it never skips the webhook.
			 *
			 * For example, to run the webhook on any objects whose namespace is not associated with
			 * "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
			 *   "matchExpressions": [
			 *     {
			 *       "key": "runlevel",
			 *       "operator": "NotIn",
			 *       "values": [
			 *         "0",
			 *         "1"
			 *       ]
			 *     }
			 *   ]
			 * }
			 *
			 * If instead you want to only run the webhook on any objects whose namespace is associated
			 * with the "environment" of "prod" or "staging"; you will set the selector as follows:
			 * "namespaceSelector": {
			 *   "matchExpressions": [
			 *     {
			 *       "key": "environment",
			 *       "operator": "In",
			 *       "values": [
			 *         "prod",
			 *         "staging"
			 *       ]
			 *     }
			 *   ]
			 * }
			 *
			 * See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more
			 * examples of label selectors.
			 *
			 * Default to the empty LabelSelector, which matches everything.
			 */
			namespaceSelector?: meta.v1.LabelSelector

			/**
			 * ObjectSelector decides whether to run the webhook based on if the object has matching
			 * labels. objectSelector is evaluated against both the oldObject and newObject that would be
			 * sent to the webhook, and is considered to match if either object matches the selector. A
			 * null object (oldObject in the case of create, or newObject in the case of delete) or an
			 * object that cannot have labels (like a DeploymentRollback or a PodProxyOptions object) is
			 * not considered to match. Use the object selector only if the webhook is opt-in, because end
			 * users may skip the admission webhook by setting the labels. Default to the empty
			 * LabelSelector, which matches everything.
			 */
			objectSelector?: meta.v1.LabelSelector

			/**
			 * reinvocationPolicy indicates whether this webhook should be called multiple times as part
			 * of a single admission evaluation. Allowed values are "Never" and "IfNeeded".
			 *
			 * Never: the webhook will not be called more than once in a single admission evaluation.
			 *
			 * IfNeeded: the webhook will be called at least one additional time as part of the admission
			 * evaluation if the object being admitted is modified by other admission plugins after the
			 * initial webhook call. Webhooks that specify this option *must* be idempotent, able to
			 * process objects they previously admitted. Note: * the number of additional invocations is
			 * not guaranteed to be exactly one. * if additional invocations result in further
			 * modifications to the object, webhooks are not guaranteed to be invoked again. * webhooks
			 * that use this option may be reordered to minimize the number of additional invocations. *
			 * to validate an object after all mutations are guaranteed complete, use a validating
			 * admission webhook instead.
			 *
			 * Defaults to "Never".
			 */
			reinvocationPolicy?: string

			/**
			 * Rules describes what operations on what resources/subresources the webhook cares about. The
			 * webhook cares about an operation if it matches _any_ Rule. However, in order to prevent
			 * ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a
			 * state which cannot be recovered from without completely disabling the plugin,
			 * ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission
			 * requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
			 */
			rules?: admissionregistration.v1.RuleWithOperations[]

			/**
			 * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
			 * webhook call will be ignored or the API call will fail based on the failure policy. The
			 * timeout value must be between 1 and 30 seconds. Default to 10 seconds.
			 */
			timeoutSeconds?: number
		}

		/**
		 * MutatingWebhookConfiguration describes the configuration of and admission webhook that accept
		 * or reject and may change the object.
		 */
		export interface MutatingWebhookConfiguration {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'admissionregistration.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'MutatingWebhookConfiguration'

			/**
			 * Standard object metadata; More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Webhooks is a list of webhooks and the affected resources and operations.
			 */
			webhooks?: admissionregistration.v1.MutatingWebhook[]
		}

		export function isMutatingWebhookConfiguration(
			o: any
		): o is MutatingWebhookConfiguration {
			return (
				o.apiVersion == 'admissionregistration.k8s.io/v1' &&
				o.kind == 'MutatingWebhookConfiguration'
			)
		}

		/**
		 * MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
		 */
		export interface MutatingWebhookConfigurationList {
			/**
			 * List of MutatingWebhookConfiguration.
			 */
			items: admissionregistration.v1.MutatingWebhookConfiguration[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'admissionregistration.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'MutatingWebhookConfigurationList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isMutatingWebhookConfigurationList(
			o: any
		): o is MutatingWebhookConfigurationList {
			return (
				o.apiVersion == 'admissionregistration.k8s.io/v1' &&
				o.kind == 'MutatingWebhookConfigurationList'
			)
		}

		/**
		 * RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure
		 * that all the tuple expansions are valid.
		 */
		export interface RuleWithOperations {
			/**
			 * APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present,
			 * the length of the slice must be one. Required.
			 */
			apiGroups?: string[]

			/**
			 * APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is
			 * present, the length of the slice must be one. Required.
			 */
			apiVersions?: string[]

			/**
			 * Operations is the operations the admission hook cares about - CREATE, UPDATE, or * for all
			 * operations. If '*' is present, the length of the slice must be one. Required.
			 */
			operations?: string[]

			/**
			 * Resources is a list of resources this rule applies to.
			 *
			 * For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means all
			 * resources, but not subresources. 'pods/*' means all subresources of pods. '*&#8205;/scale'
			 * means all scale subresources. '*&#8205;/*' means all resources and their subresources.
			 *
			 * If wildcard is present, the validation rule will ensure resources do not overlap with each
			 * other.
			 *
			 * Depending on the enclosing object, subresources might not be allowed. Required.
			 */
			resources?: string[]

			/**
			 * scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and "*"
			 * "Cluster" means that only cluster-scoped resources will match this rule. Namespace API
			 * objects are cluster-scoped. "Namespaced" means that only namespaced resources will match
			 * this rule. "*" means that there are no scope restrictions. Subresources match the scope of
			 * their parent resource. Default is "*".
			 */
			scope?: string
		}

		/**
		 * ServiceReference holds a reference to Service.legacy.k8s.io
		 */
		export interface ServiceReference {
			/**
			 * `name` is the name of the service. Required
			 */
			name: string

			/**
			 * `namespace` is the namespace of the service. Required
			 */
			namespace: string

			/**
			 * `path` is an optional URL path which will be sent in any request to this service.
			 */
			path?: string

			/**
			 * If specified, the port on the service that hosting webhook. Default to 443 for backward
			 * compatibility. `port` should be a valid port number (1-65535, inclusive).
			 */
			port?: number
		}

		/**
		 * ValidatingWebhook describes an admission webhook and the resources and operations it applies
		 * to.
		 */
		export interface ValidatingWebhook {
			/**
			 * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
			 * Webhook expects. API server will try to use first version in the list which it supports. If
			 * none of the versions specified in this list supported by API server, validation will fail
			 * for this object. If a persisted webhook configuration specifies allowed versions and does
			 * not include any versions known to the API Server, calls to the webhook will fail and be
			 * subject to the failure policy.
			 */
			admissionReviewVersions: string[]

			/**
			 * ClientConfig defines how to communicate with the hook. Required
			 */
			clientConfig: admissionregistration.v1.WebhookClientConfig

			/**
			 * The name of the admission webhook. Name should be fully qualified, e.g.,
			 * imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
			 * kubernetes.io is the name of the organization. Required.
			 */
			name: string

			/**
			 * SideEffects states whether this webhook has side effects. Acceptable values are: None,
			 * NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks with
			 * side effects MUST implement a reconciliation system, since a request may be rejected by a
			 * future step in the admission change and the side effects therefore need to be undone.
			 * Requests with the dryRun attribute will be auto-rejected if they match a webhook with
			 * sideEffects == Unknown or Some.
			 */
			sideEffects: string

			/**
			 * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
			 * allowed values are Ignore or Fail. Defaults to Fail.
			 */
			failurePolicy?: string

			/**
			 * matchPolicy defines how the "rules" list is used to match incoming requests. Allowed values
			 * are "Exact" or "Equivalent".
			 *
			 * - Exact: match a request only if it exactly matches a specified rule. For example, if
			 * deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but "rules"
			 * only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a
			 * request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
			 *
			 * - Equivalent: match a request if modifies a resource listed in rules, even via another API
			 * group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1,
			 * and extensions/v1beta1, and "rules" only included `apiGroups:["apps"], apiVersions:["v1"],
			 * resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would be
			 * converted to apps/v1 and sent to the webhook.
			 *
			 * Defaults to "Equivalent"
			 */
			matchPolicy?: string

			/**
			 * NamespaceSelector decides whether to run the webhook on an object based on whether the
			 * namespace for that object matches the selector. If the object itself is a namespace, the
			 * matching is performed on object.metadata.labels. If the object is another cluster scoped
			 * resource, it never skips the webhook.
			 *
			 * For example, to run the webhook on any objects whose namespace is not associated with
			 * "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
			 *   "matchExpressions": [
			 *     {
			 *       "key": "runlevel",
			 *       "operator": "NotIn",
			 *       "values": [
			 *         "0",
			 *         "1"
			 *       ]
			 *     }
			 *   ]
			 * }
			 *
			 * If instead you want to only run the webhook on any objects whose namespace is associated
			 * with the "environment" of "prod" or "staging"; you will set the selector as follows:
			 * "namespaceSelector": {
			 *   "matchExpressions": [
			 *     {
			 *       "key": "environment",
			 *       "operator": "In",
			 *       "values": [
			 *         "prod",
			 *         "staging"
			 *       ]
			 *     }
			 *   ]
			 * }
			 *
			 * See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more
			 * examples of label selectors.
			 *
			 * Default to the empty LabelSelector, which matches everything.
			 */
			namespaceSelector?: meta.v1.LabelSelector

			/**
			 * ObjectSelector decides whether to run the webhook based on if the object has matching
			 * labels. objectSelector is evaluated against both the oldObject and newObject that would be
			 * sent to the webhook, and is considered to match if either object matches the selector. A
			 * null object (oldObject in the case of create, or newObject in the case of delete) or an
			 * object that cannot have labels (like a DeploymentRollback or a PodProxyOptions object) is
			 * not considered to match. Use the object selector only if the webhook is opt-in, because end
			 * users may skip the admission webhook by setting the labels. Default to the empty
			 * LabelSelector, which matches everything.
			 */
			objectSelector?: meta.v1.LabelSelector

			/**
			 * Rules describes what operations on what resources/subresources the webhook cares about. The
			 * webhook cares about an operation if it matches _any_ Rule. However, in order to prevent
			 * ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a
			 * state which cannot be recovered from without completely disabling the plugin,
			 * ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission
			 * requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
			 */
			rules?: admissionregistration.v1.RuleWithOperations[]

			/**
			 * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
			 * webhook call will be ignored or the API call will fail based on the failure policy. The
			 * timeout value must be between 1 and 30 seconds. Default to 10 seconds.
			 */
			timeoutSeconds?: number
		}

		/**
		 * ValidatingWebhookConfiguration describes the configuration of and admission webhook that
		 * accept or reject and object without changing it.
		 */
		export interface ValidatingWebhookConfiguration {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'admissionregistration.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ValidatingWebhookConfiguration'

			/**
			 * Standard object metadata; More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Webhooks is a list of webhooks and the affected resources and operations.
			 */
			webhooks?: admissionregistration.v1.ValidatingWebhook[]
		}

		export function isValidatingWebhookConfiguration(
			o: any
		): o is ValidatingWebhookConfiguration {
			return (
				o.apiVersion == 'admissionregistration.k8s.io/v1' &&
				o.kind == 'ValidatingWebhookConfiguration'
			)
		}

		/**
		 * ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
		 */
		export interface ValidatingWebhookConfigurationList {
			/**
			 * List of ValidatingWebhookConfiguration.
			 */
			items: admissionregistration.v1.ValidatingWebhookConfiguration[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'admissionregistration.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ValidatingWebhookConfigurationList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isValidatingWebhookConfigurationList(
			o: any
		): o is ValidatingWebhookConfigurationList {
			return (
				o.apiVersion == 'admissionregistration.k8s.io/v1' &&
				o.kind == 'ValidatingWebhookConfigurationList'
			)
		}

		/**
		 * WebhookClientConfig contains the information to make a TLS connection with the webhook
		 */
		export interface WebhookClientConfig {
			/**
			 * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server
			 * certificate. If unspecified, system trust roots on the apiserver are used.
			 */
			caBundle?: string

			/**
			 * `service` is a reference to the service for this webhook. Either `service` or `url` must be
			 * specified.
			 *
			 * If the webhook is running within the cluster, then you should use `service`.
			 */
			service?: admissionregistration.v1.ServiceReference

			/**
			 * `url` gives the location of the webhook, in standard URL form (`scheme://host:port/path`).
			 * Exactly one of `url` or `service` must be specified.
			 *
			 * The `host` should not refer to a service running in the cluster; use the `service` field
			 * instead. The host might be resolved via external DNS in some apiservers (e.g.,
			 * `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
			 * `host` may also be an IP address.
			 *
			 * Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
			 * great care to run this webhook on all hosts which run an apiserver which might need to make
			 * calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn
			 * up in a new cluster.
			 *
			 * The scheme must be "https"; the URL must begin with "https://".
			 *
			 * A path is optional, and if present may be any string permissible in a URL. You may use the
			 * path to pass an arbitrary string to the webhook, for example, a cluster identifier.
			 *
			 * Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
			 * ("#...") and query parameters ("?...") are not allowed, either.
			 */
			url?: string
		}
	}
	export namespace v1beta1 {
		/**
		 * MutatingWebhook describes an admission webhook and the resources and operations it applies
		 * to.
		 */
		export interface MutatingWebhook {
			/**
			 * ClientConfig defines how to communicate with the hook. Required
			 */
			clientConfig: admissionregistration.v1beta1.WebhookClientConfig

			/**
			 * The name of the admission webhook. Name should be fully qualified, e.g.,
			 * imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
			 * kubernetes.io is the name of the organization. Required.
			 */
			name: string

			/**
			 * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
			 * Webhook expects. API server will try to use first version in the list which it supports. If
			 * none of the versions specified in this list supported by API server, validation will fail
			 * for this object. If a persisted webhook configuration specifies allowed versions and does
			 * not include any versions known to the API Server, calls to the webhook will fail and be
			 * subject to the failure policy. Default to `['v1beta1']`.
			 */
			admissionReviewVersions?: string[]

			/**
			 * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
			 * allowed values are Ignore or Fail. Defaults to Ignore.
			 */
			failurePolicy?: string

			/**
			 * matchPolicy defines how the "rules" list is used to match incoming requests. Allowed values
			 * are "Exact" or "Equivalent".
			 *
			 * - Exact: match a request only if it exactly matches a specified rule. For example, if
			 * deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but "rules"
			 * only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a
			 * request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
			 *
			 * - Equivalent: match a request if modifies a resource listed in rules, even via another API
			 * group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1,
			 * and extensions/v1beta1, and "rules" only included `apiGroups:["apps"], apiVersions:["v1"],
			 * resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would be
			 * converted to apps/v1 and sent to the webhook.
			 *
			 * Defaults to "Exact"
			 */
			matchPolicy?: string

			/**
			 * NamespaceSelector decides whether to run the webhook on an object based on whether the
			 * namespace for that object matches the selector. If the object itself is a namespace, the
			 * matching is performed on object.metadata.labels. If the object is another cluster scoped
			 * resource, it never skips the webhook.
			 *
			 * For example, to run the webhook on any objects whose namespace is not associated with
			 * "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
			 *   "matchExpressions": [
			 *     {
			 *       "key": "runlevel",
			 *       "operator": "NotIn",
			 *       "values": [
			 *         "0",
			 *         "1"
			 *       ]
			 *     }
			 *   ]
			 * }
			 *
			 * If instead you want to only run the webhook on any objects whose namespace is associated
			 * with the "environment" of "prod" or "staging"; you will set the selector as follows:
			 * "namespaceSelector": {
			 *   "matchExpressions": [
			 *     {
			 *       "key": "environment",
			 *       "operator": "In",
			 *       "values": [
			 *         "prod",
			 *         "staging"
			 *       ]
			 *     }
			 *   ]
			 * }
			 *
			 * See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more
			 * examples of label selectors.
			 *
			 * Default to the empty LabelSelector, which matches everything.
			 */
			namespaceSelector?: meta.v1.LabelSelector

			/**
			 * ObjectSelector decides whether to run the webhook based on if the object has matching
			 * labels. objectSelector is evaluated against both the oldObject and newObject that would be
			 * sent to the webhook, and is considered to match if either object matches the selector. A
			 * null object (oldObject in the case of create, or newObject in the case of delete) or an
			 * object that cannot have labels (like a DeploymentRollback or a PodProxyOptions object) is
			 * not considered to match. Use the object selector only if the webhook is opt-in, because end
			 * users may skip the admission webhook by setting the labels. Default to the empty
			 * LabelSelector, which matches everything.
			 */
			objectSelector?: meta.v1.LabelSelector

			/**
			 * reinvocationPolicy indicates whether this webhook should be called multiple times as part
			 * of a single admission evaluation. Allowed values are "Never" and "IfNeeded".
			 *
			 * Never: the webhook will not be called more than once in a single admission evaluation.
			 *
			 * IfNeeded: the webhook will be called at least one additional time as part of the admission
			 * evaluation if the object being admitted is modified by other admission plugins after the
			 * initial webhook call. Webhooks that specify this option *must* be idempotent, able to
			 * process objects they previously admitted. Note: * the number of additional invocations is
			 * not guaranteed to be exactly one. * if additional invocations result in further
			 * modifications to the object, webhooks are not guaranteed to be invoked again. * webhooks
			 * that use this option may be reordered to minimize the number of additional invocations. *
			 * to validate an object after all mutations are guaranteed complete, use a validating
			 * admission webhook instead.
			 *
			 * Defaults to "Never".
			 */
			reinvocationPolicy?: string

			/**
			 * Rules describes what operations on what resources/subresources the webhook cares about. The
			 * webhook cares about an operation if it matches _any_ Rule. However, in order to prevent
			 * ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a
			 * state which cannot be recovered from without completely disabling the plugin,
			 * ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission
			 * requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
			 */
			rules?: admissionregistration.v1beta1.RuleWithOperations[]

			/**
			 * SideEffects states whether this webhook has side effects. Acceptable values are: Unknown,
			 * None, Some, NoneOnDryRun Webhooks with side effects MUST implement a reconciliation system,
			 * since a request may be rejected by a future step in the admission change and the side
			 * effects therefore need to be undone. Requests with the dryRun attribute will be
			 * auto-rejected if they match a webhook with sideEffects == Unknown or Some. Defaults to
			 * Unknown.
			 */
			sideEffects?: string

			/**
			 * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
			 * webhook call will be ignored or the API call will fail based on the failure policy. The
			 * timeout value must be between 1 and 30 seconds. Default to 30 seconds.
			 */
			timeoutSeconds?: number
		}

		/**
		 * MutatingWebhookConfiguration describes the configuration of and admission webhook that accept
		 * or reject and may change the object.
		 *
		 * @deprecated admissionregistration/v1beta1/MutatingWebhookConfiguration is deprecated by
		 * admissionregistration/v1/MutatingWebhookConfiguration and not supported by Kubernetes v1.19+
		 * clusters.
		 */
		export interface MutatingWebhookConfiguration {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'admissionregistration.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'MutatingWebhookConfiguration'

			/**
			 * Standard object metadata; More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Webhooks is a list of webhooks and the affected resources and operations.
			 */
			webhooks?: admissionregistration.v1beta1.MutatingWebhook[]
		}

		export function isMutatingWebhookConfiguration(
			o: any
		): o is MutatingWebhookConfiguration {
			return (
				o.apiVersion == 'admissionregistration.k8s.io/v1beta1' &&
				o.kind == 'MutatingWebhookConfiguration'
			)
		}

		/**
		 * MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
		 */
		export interface MutatingWebhookConfigurationList {
			/**
			 * List of MutatingWebhookConfiguration.
			 */
			items: admissionregistration.v1beta1.MutatingWebhookConfiguration[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'admissionregistration.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'MutatingWebhookConfigurationList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isMutatingWebhookConfigurationList(
			o: any
		): o is MutatingWebhookConfigurationList {
			return (
				o.apiVersion == 'admissionregistration.k8s.io/v1beta1' &&
				o.kind == 'MutatingWebhookConfigurationList'
			)
		}

		/**
		 * RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure
		 * that all the tuple expansions are valid.
		 */
		export interface RuleWithOperations {
			/**
			 * APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present,
			 * the length of the slice must be one. Required.
			 */
			apiGroups?: string[]

			/**
			 * APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is
			 * present, the length of the slice must be one. Required.
			 */
			apiVersions?: string[]

			/**
			 * Operations is the operations the admission hook cares about - CREATE, UPDATE, or * for all
			 * operations. If '*' is present, the length of the slice must be one. Required.
			 */
			operations?: string[]

			/**
			 * Resources is a list of resources this rule applies to.
			 *
			 * For example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means all
			 * resources, but not subresources. 'pods/*' means all subresources of pods. '*&#8205;/scale'
			 * means all scale subresources. '*&#8205;/*' means all resources and their subresources.
			 *
			 * If wildcard is present, the validation rule will ensure resources do not overlap with each
			 * other.
			 *
			 * Depending on the enclosing object, subresources might not be allowed. Required.
			 */
			resources?: string[]

			/**
			 * scope specifies the scope of this rule. Valid values are "Cluster", "Namespaced", and "*"
			 * "Cluster" means that only cluster-scoped resources will match this rule. Namespace API
			 * objects are cluster-scoped. "Namespaced" means that only namespaced resources will match
			 * this rule. "*" means that there are no scope restrictions. Subresources match the scope of
			 * their parent resource. Default is "*".
			 */
			scope?: string
		}

		/**
		 * ServiceReference holds a reference to Service.legacy.k8s.io
		 */
		export interface ServiceReference {
			/**
			 * `name` is the name of the service. Required
			 */
			name: string

			/**
			 * `namespace` is the namespace of the service. Required
			 */
			namespace: string

			/**
			 * `path` is an optional URL path which will be sent in any request to this service.
			 */
			path?: string

			/**
			 * If specified, the port on the service that hosting webhook. Default to 443 for backward
			 * compatibility. `port` should be a valid port number (1-65535, inclusive).
			 */
			port?: number
		}

		/**
		 * ValidatingWebhook describes an admission webhook and the resources and operations it applies
		 * to.
		 */
		export interface ValidatingWebhook {
			/**
			 * ClientConfig defines how to communicate with the hook. Required
			 */
			clientConfig: admissionregistration.v1beta1.WebhookClientConfig

			/**
			 * The name of the admission webhook. Name should be fully qualified, e.g.,
			 * imagepolicy.kubernetes.io, where "imagepolicy" is the name of the webhook, and
			 * kubernetes.io is the name of the organization. Required.
			 */
			name: string

			/**
			 * AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the
			 * Webhook expects. API server will try to use first version in the list which it supports. If
			 * none of the versions specified in this list supported by API server, validation will fail
			 * for this object. If a persisted webhook configuration specifies allowed versions and does
			 * not include any versions known to the API Server, calls to the webhook will fail and be
			 * subject to the failure policy. Default to `['v1beta1']`.
			 */
			admissionReviewVersions?: string[]

			/**
			 * FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
			 * allowed values are Ignore or Fail. Defaults to Ignore.
			 */
			failurePolicy?: string

			/**
			 * matchPolicy defines how the "rules" list is used to match incoming requests. Allowed values
			 * are "Exact" or "Equivalent".
			 *
			 * - Exact: match a request only if it exactly matches a specified rule. For example, if
			 * deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but "rules"
			 * only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`, a
			 * request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
			 *
			 * - Equivalent: match a request if modifies a resource listed in rules, even via another API
			 * group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1,
			 * and extensions/v1beta1, and "rules" only included `apiGroups:["apps"], apiVersions:["v1"],
			 * resources: ["deployments"]`, a request to apps/v1beta1 or extensions/v1beta1 would be
			 * converted to apps/v1 and sent to the webhook.
			 *
			 * Defaults to "Exact"
			 */
			matchPolicy?: string

			/**
			 * NamespaceSelector decides whether to run the webhook on an object based on whether the
			 * namespace for that object matches the selector. If the object itself is a namespace, the
			 * matching is performed on object.metadata.labels. If the object is another cluster scoped
			 * resource, it never skips the webhook.
			 *
			 * For example, to run the webhook on any objects whose namespace is not associated with
			 * "runlevel" of "0" or "1";  you will set the selector as follows: "namespaceSelector": {
			 *   "matchExpressions": [
			 *     {
			 *       "key": "runlevel",
			 *       "operator": "NotIn",
			 *       "values": [
			 *         "0",
			 *         "1"
			 *       ]
			 *     }
			 *   ]
			 * }
			 *
			 * If instead you want to only run the webhook on any objects whose namespace is associated
			 * with the "environment" of "prod" or "staging"; you will set the selector as follows:
			 * "namespaceSelector": {
			 *   "matchExpressions": [
			 *     {
			 *       "key": "environment",
			 *       "operator": "In",
			 *       "values": [
			 *         "prod",
			 *         "staging"
			 *       ]
			 *     }
			 *   ]
			 * }
			 *
			 * See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more
			 * examples of label selectors.
			 *
			 * Default to the empty LabelSelector, which matches everything.
			 */
			namespaceSelector?: meta.v1.LabelSelector

			/**
			 * ObjectSelector decides whether to run the webhook based on if the object has matching
			 * labels. objectSelector is evaluated against both the oldObject and newObject that would be
			 * sent to the webhook, and is considered to match if either object matches the selector. A
			 * null object (oldObject in the case of create, or newObject in the case of delete) or an
			 * object that cannot have labels (like a DeploymentRollback or a PodProxyOptions object) is
			 * not considered to match. Use the object selector only if the webhook is opt-in, because end
			 * users may skip the admission webhook by setting the labels. Default to the empty
			 * LabelSelector, which matches everything.
			 */
			objectSelector?: meta.v1.LabelSelector

			/**
			 * Rules describes what operations on what resources/subresources the webhook cares about. The
			 * webhook cares about an operation if it matches _any_ Rule. However, in order to prevent
			 * ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a
			 * state which cannot be recovered from without completely disabling the plugin,
			 * ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission
			 * requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
			 */
			rules?: admissionregistration.v1beta1.RuleWithOperations[]

			/**
			 * SideEffects states whether this webhook has side effects. Acceptable values are: Unknown,
			 * None, Some, NoneOnDryRun Webhooks with side effects MUST implement a reconciliation system,
			 * since a request may be rejected by a future step in the admission change and the side
			 * effects therefore need to be undone. Requests with the dryRun attribute will be
			 * auto-rejected if they match a webhook with sideEffects == Unknown or Some. Defaults to
			 * Unknown.
			 */
			sideEffects?: string

			/**
			 * TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the
			 * webhook call will be ignored or the API call will fail based on the failure policy. The
			 * timeout value must be between 1 and 30 seconds. Default to 30 seconds.
			 */
			timeoutSeconds?: number
		}

		/**
		 * ValidatingWebhookConfiguration describes the configuration of and admission webhook that
		 * accept or reject and object without changing it.
		 *
		 * @deprecated admissionregistration/v1beta1/ValidatingWebhookConfiguration is deprecated by
		 * admissionregistration/v1/ValidatingWebhookConfiguration and not supported by Kubernetes
		 * v1.19+ clusters.
		 */
		export interface ValidatingWebhookConfiguration {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'admissionregistration.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ValidatingWebhookConfiguration'

			/**
			 * Standard object metadata; More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Webhooks is a list of webhooks and the affected resources and operations.
			 */
			webhooks?: admissionregistration.v1beta1.ValidatingWebhook[]
		}

		export function isValidatingWebhookConfiguration(
			o: any
		): o is ValidatingWebhookConfiguration {
			return (
				o.apiVersion == 'admissionregistration.k8s.io/v1beta1' &&
				o.kind == 'ValidatingWebhookConfiguration'
			)
		}

		/**
		 * ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
		 */
		export interface ValidatingWebhookConfigurationList {
			/**
			 * List of ValidatingWebhookConfiguration.
			 */
			items: admissionregistration.v1beta1.ValidatingWebhookConfiguration[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'admissionregistration.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ValidatingWebhookConfigurationList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isValidatingWebhookConfigurationList(
			o: any
		): o is ValidatingWebhookConfigurationList {
			return (
				o.apiVersion == 'admissionregistration.k8s.io/v1beta1' &&
				o.kind == 'ValidatingWebhookConfigurationList'
			)
		}

		/**
		 * WebhookClientConfig contains the information to make a TLS connection with the webhook
		 */
		export interface WebhookClientConfig {
			/**
			 * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server
			 * certificate. If unspecified, system trust roots on the apiserver are used.
			 */
			caBundle?: string

			/**
			 * `service` is a reference to the service for this webhook. Either `service` or `url` must be
			 * specified.
			 *
			 * If the webhook is running within the cluster, then you should use `service`.
			 */
			service?: admissionregistration.v1beta1.ServiceReference

			/**
			 * `url` gives the location of the webhook, in standard URL form (`scheme://host:port/path`).
			 * Exactly one of `url` or `service` must be specified.
			 *
			 * The `host` should not refer to a service running in the cluster; use the `service` field
			 * instead. The host might be resolved via external DNS in some apiservers (e.g.,
			 * `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
			 * `host` may also be an IP address.
			 *
			 * Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
			 * great care to run this webhook on all hosts which run an apiserver which might need to make
			 * calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn
			 * up in a new cluster.
			 *
			 * The scheme must be "https"; the URL must begin with "https://".
			 *
			 * A path is optional, and if present may be any string permissible in a URL. You may use the
			 * path to pass an arbitrary string to the webhook, for example, a cluster identifier.
			 *
			 * Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
			 * ("#...") and query parameters ("?...") are not allowed, either.
			 */
			url?: string
		}
	}
}

export namespace apiextensions {
	export namespace v1 {
		/**
		 * CustomResourceColumnDefinition specifies a column for server side printing.
		 */
		export interface CustomResourceColumnDefinition {
			/**
			 * jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against each
			 * custom resource to produce the value for this column.
			 */
			jsonPath: string

			/**
			 * name is a human readable name for the column.
			 */
			name: string

			/**
			 * type is an OpenAPI type definition for this column. See
			 * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
			 * details.
			 */
			type: string

			/**
			 * description is a human readable description of this column.
			 */
			description?: string

			/**
			 * format is an optional OpenAPI type definition for this column. The 'name' format is applied
			 * to the primary identifier column to assist in clients identifying column is the resource
			 * name. See
			 * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
			 * details.
			 */
			format?: string

			/**
			 * priority is an integer defining the relative importance of this column compared to others.
			 * Lower numbers are considered higher priority. Columns that may be omitted in limited space
			 * scenarios should be given a priority greater than 0.
			 */
			priority?: number
		}

		/**
		 * CustomResourceConversion describes how to convert different versions of a CR.
		 */
		export interface CustomResourceConversion {
			/**
			 * strategy specifies how custom resources are converted between versions. Allowed values are:
			 * - `None`: The converter only change the apiVersion and would not touch any other field in
			 * the custom resource. - `Webhook`: API Server will call to an external webhook to do the
			 * conversion. Additional information
			 *   is needed for this option. This requires spec.preserveUnknownFields to be false, and
			 * spec.conversion.webhook to be set.
			 */
			strategy: string

			/**
			 * webhook describes how to call the conversion webhook. Required when `strategy` is set to
			 * `Webhook`.
			 */
			webhook?: apiextensions.v1.WebhookConversion
		}

		/**
		 * CustomResourceDefinition represents a resource that should be exposed on the API server.  Its
		 * name MUST be in the format <.spec.name>.<.spec.group>.
		 */
		export interface CustomResourceDefinition {
			/**
			 * spec describes how the user wants the resources to appear
			 */
			spec: apiextensions.v1.CustomResourceDefinitionSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apiextensions.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CustomResourceDefinition'

			metadata?: meta.v1.ObjectMeta
		}

		export function isCustomResourceDefinition(
			o: any
		): o is CustomResourceDefinition {
			return (
				o.apiVersion == 'apiextensions.k8s.io/v1' &&
				o.kind == 'CustomResourceDefinition'
			)
		}

		/**
		 * CustomResourceDefinitionCondition contains details for the current condition of this pod.
		 */
		export interface CustomResourceDefinitionCondition {
			/**
			 * type is the type of the condition. Types include Established, NamesAccepted and
			 * Terminating.
			 */
			type: string

			/**
			 * lastTransitionTime last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * message is a human-readable message indicating details about last transition.
			 */
			message?: string

			/**
			 * reason is a unique, one-word, CamelCase reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * CustomResourceDefinitionList is a list of CustomResourceDefinition objects.
		 */
		export interface CustomResourceDefinitionList {
			/**
			 * items list individual CustomResourceDefinition objects
			 */
			items: apiextensions.v1.CustomResourceDefinition[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apiextensions.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CustomResourceDefinitionList'

			metadata?: meta.v1.ListMeta
		}

		export function isCustomResourceDefinitionList(
			o: any
		): o is CustomResourceDefinitionList {
			return (
				o.apiVersion == 'apiextensions.k8s.io/v1' &&
				o.kind == 'CustomResourceDefinitionList'
			)
		}

		/**
		 * CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition
		 */
		export interface CustomResourceDefinitionNames {
			/**
			 * kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom
			 * resource instances will use this value as the `kind` attribute in API calls.
			 */
			kind: string

			/**
			 * plural is the plural name of the resource to serve. The custom resources are served under
			 * `/apis/<group>/<version>/.../<plural>`. Must match the name of the CustomResourceDefinition
			 * (in the form `<names.plural>.<group>`). Must be all lowercase.
			 */
			plural: string

			/**
			 * categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
			 * This is published in API discovery documents, and used by clients to support invocations
			 * like `kubectl get all`.
			 */
			categories?: string[]

			/**
			 * listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
			 */
			listKind?: string

			/**
			 * shortNames are short names for the resource, exposed in API discovery documents, and used
			 * by clients to support invocations like `kubectl get <shortname>`. It must be all lowercase.
			 */
			shortNames?: string[]

			/**
			 * singular is the singular name of the resource. It must be all lowercase. Defaults to
			 * lowercased `kind`.
			 */
			singular?: string
		}

		/**
		 * CustomResourceDefinitionSpec describes how a user wants their resource to appear
		 */
		export interface CustomResourceDefinitionSpec {
			/**
			 * group is the API group of the defined custom resource. The custom resources are served
			 * under `/apis/<group>/...`. Must match the name of the CustomResourceDefinition (in the form
			 * `<names.plural>.<group>`).
			 */
			group: string

			/**
			 * names specify the resource and kind names for the custom resource.
			 */
			names: apiextensions.v1.CustomResourceDefinitionNames

			/**
			 * scope indicates whether the defined custom resource is cluster- or namespace-scoped.
			 * Allowed values are `Cluster` and `Namespaced`.
			 */
			scope: string

			/**
			 * versions is the list of all API versions of the defined custom resource. Version names are
			 * used to compute the order in which served versions are listed in API discovery. If the
			 * version string is "kube-like", it will sort above non "kube-like" version strings, which
			 * are ordered lexicographically. "Kube-like" versions start with a "v", then are followed by
			 * a number (the major version), then optionally the string "alpha" or "beta" and another
			 * number (the minor version). These are sorted first by GA > beta > alpha (where GA is a
			 * version with no suffix such as beta or alpha), and then by comparing major version, then
			 * minor version. An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3,
			 * v3beta1, v12alpha1, v11alpha2, foo1, foo10.
			 */
			versions: apiextensions.v1.CustomResourceDefinitionVersion[]

			/**
			 * conversion defines conversion settings for the CRD.
			 */
			conversion?: apiextensions.v1.CustomResourceConversion

			/**
			 * preserveUnknownFields indicates that object fields which are not specified in the OpenAPI
			 * schema should be preserved when persisting to storage. apiVersion, kind, metadata and known
			 * fields inside metadata are always preserved. This field is deprecated in favor of setting
			 * `x-preserve-unknown-fields` to true in `spec.versions[*].schema.openAPIV3Schema`. See
			 * https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#pruning-versus-preserving-unknown-fields
			 * for details.
			 */
			preserveUnknownFields?: boolean
		}

		/**
		 * CustomResourceDefinitionVersion describes a version for CRD.
		 */
		export interface CustomResourceDefinitionVersion {
			/**
			 * name is the version name, e.g. v1, v2beta1, etc. The custom resources are
			 * served under this version at `/apis/<group>/<version>/...` if `served` is true.
			 */
			name: string

			/**
			 * served is a flag enabling/disabling this version from being served via REST APIs
			 */
			served: boolean

			/**
			 * storage indicates this version should be used when persisting custom resources to storage.
			 * There must be exactly one version with storage=true.
			 */
			storage: boolean

			/**
			 * additionalPrinterColumns specifies additional columns returned in Table output. See
			 * https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
			 * for details. If no columns are specified, a single column displaying the age of the custom
			 * resource is used.
			 */
			additionalPrinterColumns?: apiextensions.v1.CustomResourceColumnDefinition[]

			/**
			 * schema describes the schema used for validation, pruning, and defaulting of this version of
			 * the custom resource.
			 */
			schema?: apiextensions.v1.CustomResourceValidation

			/**
			 * subresources specify what subresources this version of the defined custom resource have.
			 */
			subresources?: apiextensions.v1.CustomResourceSubresources
		}

		/**
		 * CustomResourceSubresourceScale defines how to serve the scale subresource for
		 * CustomResources.
		 */
		export interface CustomResourceSubresourceScale {
			/**
			 * specReplicasPath defines the JSON path inside of a custom resource that corresponds to
			 * Scale `spec.replicas`. Only JSON paths without the array notation are allowed. Must be a
			 * JSON Path under `.spec`. If there is no value under the given path in the custom resource,
			 * the `/scale` subresource will return an error on GET.
			 */
			specReplicasPath: string

			/**
			 * statusReplicasPath defines the JSON path inside of a custom resource that corresponds to
			 * Scale `status.replicas`. Only JSON paths without the array notation are allowed. Must be a
			 * JSON Path under `.status`. If there is no value under the given path in the custom
			 * resource, the `status.replicas` value in the `/scale` subresource will default to 0.
			 */
			statusReplicasPath: string

			/**
			 * labelSelectorPath defines the JSON path inside of a custom resource that corresponds to
			 * Scale `status.selector`. Only JSON paths without the array notation are allowed. Must be a
			 * JSON Path under `.status` or `.spec`. Must be set to work with HorizontalPodAutoscaler. The
			 * field pointed by this JSON path must be a string field (not a complex selector struct)
			 * which contains a serialized label selector in string form. More info:
			 * https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource
			 * If there is no value under the given path in the custom resource, the `status.selector`
			 * value in the `/scale` subresource will default to the empty string.
			 */
			labelSelectorPath?: string
		}

		/**
		 * CustomResourceSubresources defines the status and scale subresources for CustomResources.
		 */
		export interface CustomResourceSubresources {
			/**
			 * scale indicates the custom resource should serve a `/scale` subresource that returns an
			 * `autoscaling/v1` Scale object.
			 */
			scale?: apiextensions.v1.CustomResourceSubresourceScale
		}

		/**
		 * CustomResourceValidation is a list of validation methods for CustomResources.
		 */
		export interface CustomResourceValidation {
			/**
			 * openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.
			 */
			openAPIV3Schema?: apiextensions.v1.JSONSchemaProps
		}

		/**
		 * ExternalDocumentation allows referencing an external resource for extended documentation.
		 */
		export interface ExternalDocumentation {
			description?: string

			url?: string
		}

		/**
		 * JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
		 */
		export interface JSONSchemaProps {
			$ref?: string

			$schema?: string

			additionalItems?: apiextensions.v1.JSONSchemaProps | boolean

			additionalProperties?: apiextensions.v1.JSONSchemaProps | boolean

			allOf?: apiextensions.v1.JSONSchemaProps[]

			anyOf?: apiextensions.v1.JSONSchemaProps[]

			/**
			 * default is a default value for undefined object fields. Defaulting is a beta feature under
			 * the CustomResourceDefaulting feature gate. Defaulting requires spec.preserveUnknownFields
			 * to be false.
			 */
			default?: any

			definitions?: object

			dependencies?: object

			description?: string

			enum?: any[]

			example?: any

			exclusiveMaximum?: boolean

			exclusiveMinimum?: boolean

			externalDocs?: apiextensions.v1.ExternalDocumentation

			/**
			 * format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats
			 * are validated:
			 *
			 * - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed
			 * by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang
			 * net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as
			 * defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang
			 * net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by
			 * Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID
			 * that allows uppercase defined by the regex
			 * (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3
			 * that allows uppercase defined by the regex
			 * (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4
			 * that allows uppercase defined by the regex
			 * (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an
			 * UUID5 that allows uppercase defined by the regex
			 * (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an
			 * ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10
			 * number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041" -
			 * creditcard: a credit card number defined by the regex
			 * ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$
			 * with any non digit characters mixed in - ssn: a U.S. social security number following the
			 * regex ^\d{3}[- ]?\d{2}[- ]?\d{4}$ - hexcolor: an hexadecimal color code like "#FFFFFF:
			 * following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like
			 * rgb like "rgb(255,255,2559" - byte: base64 encoded binary data - password: any kind of
			 * string - date: a date string like "2006-01-02" as defined by full-date in RFC3339 -
			 * duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or
			 * compatible with Scala duration format - datetime: a date time string like
			 * "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
			 */
			format?: string

			id?: string

			items?: apiextensions.v1.JSONSchemaProps | any[]

			maxItems?: number

			maxLength?: number

			maxProperties?: number

			maximum?: number

			minItems?: number

			minLength?: number

			minProperties?: number

			minimum?: number

			multipleOf?: number

			not?: apiextensions.v1.JSONSchemaProps

			nullable?: boolean

			oneOf?: apiextensions.v1.JSONSchemaProps[]

			pattern?: string

			patternProperties?: object

			properties?: object

			required?: string[]

			title?: string

			type?: string

			uniqueItems?: boolean

			/**
			 * x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes
			 * runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to
			 * further restrict the embedded object. kind, apiVersion and metadata are validated
			 * automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not
			 * have to be if the object is fully specified (up to kind, apiVersion, metadata).
			 */
			x_kubernetes_embedded_resource?: boolean

			/**
			 * x-kubernetes-int-or-string specifies that this value is either an integer or a string. If
			 * this is true, an empty type is allowed and type as child of anyOf is permitted if following
			 * one of the following patterns:
			 *
			 * 1) anyOf:
			 *    - type: integer
			 *    - type: string
			 * 2) allOf:
			 *    - anyOf:
			 *      - type: integer
			 *      - type: string
			 *    - ... zero or more
			 */
			x_kubernetes_int_or_string?: boolean

			/**
			 * x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by
			 * specifying the keys used as the index of the map.
			 *
			 * This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set to
			 * "map". Also, the values specified for this attribute must be a scalar typed field of the
			 * child structure (no nesting is supported).
			 */
			x_kubernetes_list_map_keys?: string[]

			/**
			 * x-kubernetes-list-type annotates an array to further describe its topology. This extension
			 * must only be used on lists and may have 3 possible values:
			 *
			 * 1) `atomic`: the list is treated as a single entity, like a scalar.
			 *      Atomic lists will be entirely replaced when updated. This extension
			 *      may be used on any type of list (struct, scalar, ...).
			 * 2) `set`:
			 *      Sets are lists that must not have multiple items with the same value. Each
			 *      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an
			 *      array with x-kubernetes-list-type `atomic`.
			 * 3) `map`:
			 *      These lists are like maps in that their elements have a non-index key
			 *      used to identify them. Order is preserved upon merge. The map tag
			 *      must only be used on a list with elements of type object.
			 * Defaults to atomic for arrays.
			 */
			x_kubernetes_list_type?: string

			/**
			 * x-kubernetes-map-type annotates an object to further describe its topology. This extension
			 * must only be used when type is object and may have 2 possible values:
			 *
			 * 1) `granular`:
			 *      These maps are actual maps (key-value pairs) and each fields are independent
			 *      from each other (they can each be manipulated by separate actors). This is
			 *      the default behaviour for all maps.
			 * 2) `atomic`: the list is treated as a single entity, like a scalar.
			 *      Atomic maps will be entirely replaced when updated.
			 */
			x_kubernetes_map_type?: string

			/**
			 * x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields
			 * which are not specified in the validation schema. This affects fields recursively, but
			 * switches back to normal pruning behaviour if nested properties or additionalProperties are
			 * specified in the schema. This can either be true or undefined. False is forbidden.
			 */
			x_kubernetes_preserve_unknown_fields?: boolean
		}

		/**
		 * ServiceReference holds a reference to Service.legacy.k8s.io
		 */
		export interface ServiceReference {
			/**
			 * name is the name of the service. Required
			 */
			name: string

			/**
			 * namespace is the namespace of the service. Required
			 */
			namespace: string

			/**
			 * path is an optional URL path at which the webhook will be contacted.
			 */
			path?: string

			/**
			 * port is an optional service port at which the webhook will be contacted. `port` should be a
			 * valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility.
			 */
			port?: number
		}

		/**
		 * WebhookClientConfig contains the information to make a TLS connection with the webhook.
		 */
		export interface WebhookClientConfig {
			/**
			 * caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server
			 * certificate. If unspecified, system trust roots on the apiserver are used.
			 */
			caBundle?: string

			/**
			 * service is a reference to the service for this webhook. Either service or url must be
			 * specified.
			 *
			 * If the webhook is running within the cluster, then you should use `service`.
			 */
			service?: apiextensions.v1.ServiceReference

			/**
			 * url gives the location of the webhook, in standard URL form (`scheme://host:port/path`).
			 * Exactly one of `url` or `service` must be specified.
			 *
			 * The `host` should not refer to a service running in the cluster; use the `service` field
			 * instead. The host might be resolved via external DNS in some apiservers (e.g.,
			 * `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
			 * `host` may also be an IP address.
			 *
			 * Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
			 * great care to run this webhook on all hosts which run an apiserver which might need to make
			 * calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn
			 * up in a new cluster.
			 *
			 * The scheme must be "https"; the URL must begin with "https://".
			 *
			 * A path is optional, and if present may be any string permissible in a URL. You may use the
			 * path to pass an arbitrary string to the webhook, for example, a cluster identifier.
			 *
			 * Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
			 * ("#...") and query parameters ("?...") are not allowed, either.
			 */
			url?: string
		}

		/**
		 * WebhookConversion describes how to call a conversion webhook
		 */
		export interface WebhookConversion {
			/**
			 * conversionReviewVersions is an ordered list of preferred `ConversionReview` versions the
			 * Webhook expects. The API server will use the first version in the list which it supports.
			 * If none of the versions specified in this list are supported by API server, conversion will
			 * fail for the custom resource. If a persisted Webhook configuration specifies allowed
			 * versions and does not include any versions known to the API Server, calls to the webhook
			 * will fail.
			 */
			conversionReviewVersions: string[]

			/**
			 * clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
			 */
			clientConfig?: apiextensions.v1.WebhookClientConfig
		}
	}
	export namespace v1beta1 {
		/**
		 * CustomResourceColumnDefinition specifies a column for server side printing.
		 */
		export interface CustomResourceColumnDefinition {
			/**
			 * JSONPath is a simple JSON path (i.e. with array notation) which is evaluated against each
			 * custom resource to produce the value for this column.
			 */
			JSONPath: string

			/**
			 * name is a human readable name for the column.
			 */
			name: string

			/**
			 * type is an OpenAPI type definition for this column. See
			 * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
			 * details.
			 */
			type: string

			/**
			 * description is a human readable description of this column.
			 */
			description?: string

			/**
			 * format is an optional OpenAPI type definition for this column. The 'name' format is applied
			 * to the primary identifier column to assist in clients identifying column is the resource
			 * name. See
			 * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for
			 * details.
			 */
			format?: string

			/**
			 * priority is an integer defining the relative importance of this column compared to others.
			 * Lower numbers are considered higher priority. Columns that may be omitted in limited space
			 * scenarios should be given a priority greater than 0.
			 */
			priority?: number
		}

		/**
		 * CustomResourceConversion describes how to convert different versions of a CR.
		 */
		export interface CustomResourceConversion {
			/**
			 * strategy specifies how custom resources are converted between versions. Allowed values are:
			 * - `None`: The converter only change the apiVersion and would not touch any other field in
			 * the custom resource. - `Webhook`: API Server will call to an external webhook to do the
			 * conversion. Additional information
			 *   is needed for this option. This requires spec.preserveUnknownFields to be false, and
			 * spec.conversion.webhookClientConfig to be set.
			 */
			strategy: string

			/**
			 * conversionReviewVersions is an ordered list of preferred `ConversionReview` versions the
			 * Webhook expects. The API server will use the first version in the list which it supports.
			 * If none of the versions specified in this list are supported by API server, conversion will
			 * fail for the custom resource. If a persisted Webhook configuration specifies allowed
			 * versions and does not include any versions known to the API Server, calls to the webhook
			 * will fail. Defaults to `["v1beta1"]`.
			 */
			conversionReviewVersions?: string[]

			/**
			 * webhookClientConfig is the instructions for how to call the webhook if strategy is
			 * `Webhook`. Required when `strategy` is set to `Webhook`.
			 */
			webhookClientConfig?: apiextensions.v1beta1.WebhookClientConfig
		}

		/**
		 * CustomResourceDefinition represents a resource that should be exposed on the API server.  Its
		 * name MUST be in the format <.spec.name>.<.spec.group>.
		 *
		 * @deprecated apiextensions/v1beta1/CustomResourceDefinition is deprecated by
		 * apiextensions/v1/CustomResourceDefinition and not supported by Kubernetes v1.19+ clusters.
		 */
		export interface CustomResourceDefinition {
			/**
			 * spec describes how the user wants the resources to appear
			 */
			spec: apiextensions.v1beta1.CustomResourceDefinitionSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apiextensions.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CustomResourceDefinition'

			metadata?: meta.v1.ObjectMeta
		}

		export function isCustomResourceDefinition(
			o: any
		): o is CustomResourceDefinition {
			return (
				o.apiVersion == 'apiextensions.k8s.io/v1beta1' &&
				o.kind == 'CustomResourceDefinition'
			)
		}

		/**
		 * CustomResourceDefinitionCondition contains details for the current condition of this pod.
		 */
		export interface CustomResourceDefinitionCondition {
			/**
			 * type is the type of the condition. Types include Established, NamesAccepted and
			 * Terminating.
			 */
			type: string

			/**
			 * lastTransitionTime last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * message is a human-readable message indicating details about last transition.
			 */
			message?: string

			/**
			 * reason is a unique, one-word, CamelCase reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * CustomResourceDefinitionList is a list of CustomResourceDefinition objects.
		 */
		export interface CustomResourceDefinitionList {
			/**
			 * items list individual CustomResourceDefinition objects
			 */
			items: apiextensions.v1beta1.CustomResourceDefinition[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apiextensions.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CustomResourceDefinitionList'

			metadata?: meta.v1.ListMeta
		}

		export function isCustomResourceDefinitionList(
			o: any
		): o is CustomResourceDefinitionList {
			return (
				o.apiVersion == 'apiextensions.k8s.io/v1beta1' &&
				o.kind == 'CustomResourceDefinitionList'
			)
		}

		/**
		 * CustomResourceDefinitionNames indicates the names to serve this CustomResourceDefinition
		 */
		export interface CustomResourceDefinitionNames {
			/**
			 * kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom
			 * resource instances will use this value as the `kind` attribute in API calls.
			 */
			kind: string

			/**
			 * plural is the plural name of the resource to serve. The custom resources are served under
			 * `/apis/<group>/<version>/.../<plural>`. Must match the name of the CustomResourceDefinition
			 * (in the form `<names.plural>.<group>`). Must be all lowercase.
			 */
			plural: string

			/**
			 * categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
			 * This is published in API discovery documents, and used by clients to support invocations
			 * like `kubectl get all`.
			 */
			categories?: string[]

			/**
			 * listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
			 */
			listKind?: string

			/**
			 * shortNames are short names for the resource, exposed in API discovery documents, and used
			 * by clients to support invocations like `kubectl get <shortname>`. It must be all lowercase.
			 */
			shortNames?: string[]

			/**
			 * singular is the singular name of the resource. It must be all lowercase. Defaults to
			 * lowercased `kind`.
			 */
			singular?: string
		}

		/**
		 * CustomResourceDefinitionSpec describes how a user wants their resource to appear
		 */
		export interface CustomResourceDefinitionSpec {
			/**
			 * group is the API group of the defined custom resource. The custom resources are served
			 * under `/apis/<group>/...`. Must match the name of the CustomResourceDefinition (in the form
			 * `<names.plural>.<group>`).
			 */
			group: string

			/**
			 * names specify the resource and kind names for the custom resource.
			 */
			names: apiextensions.v1beta1.CustomResourceDefinitionNames

			/**
			 * scope indicates whether the defined custom resource is cluster- or namespace-scoped.
			 * Allowed values are `Cluster` and `Namespaced`. Default is `Namespaced`.
			 */
			scope: string

			/**
			 * additionalPrinterColumns specifies additional columns returned in Table output. See
			 * https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
			 * for details. If present, this field configures columns for all versions. Top-level and
			 * per-version columns are mutually exclusive. If no top-level or per-version columns are
			 * specified, a single column displaying the age of the custom resource is used.
			 */
			additionalPrinterColumns?: apiextensions.v1beta1.CustomResourceColumnDefinition[]

			/**
			 * conversion defines conversion settings for the CRD.
			 */
			conversion?: apiextensions.v1beta1.CustomResourceConversion

			/**
			 * preserveUnknownFields indicates that object fields which are not specified in the OpenAPI
			 * schema should be preserved when persisting to storage. apiVersion, kind, metadata and known
			 * fields inside metadata are always preserved. If false, schemas must be defined for all
			 * versions. Defaults to true in v1beta for backwards compatibility. Deprecated: will be
			 * required to be false in v1. Preservation of unknown fields can be specified in the
			 * validation schema using the `x-kubernetes-preserve-unknown-fields: true` extension. See
			 * https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#pruning-versus-preserving-unknown-fields
			 * for details.
			 */
			preserveUnknownFields?: boolean

			/**
			 * subresources specify what subresources the defined custom resource has. If present, this
			 * field configures subresources for all versions. Top-level and per-version subresources are
			 * mutually exclusive.
			 */
			subresources?: apiextensions.v1beta1.CustomResourceSubresources

			/**
			 * validation describes the schema used for validation and pruning of the custom resource. If
			 * present, this validation schema is used to validate all versions. Top-level and per-version
			 * schemas are mutually exclusive.
			 */
			validation?: apiextensions.v1beta1.CustomResourceValidation

			/**
			 * version is the API version of the defined custom resource. The custom resources are served
			 * under `/apis/<group>/<version>/...`. Must match the name of the first item in the
			 * `versions` list if `version` and `versions` are both specified. Optional if `versions` is
			 * specified. Deprecated: use `versions` instead.
			 */
			version?: string

			/**
			 * versions is the list of all API versions of the defined custom resource. Optional if
			 * `version` is specified. The name of the first item in the `versions` list must match the
			 * `version` field if `version` and `versions` are both specified. Version names are used to
			 * compute the order in which served versions are listed in API discovery. If the version
			 * string is "kube-like", it will sort above non "kube-like" version strings, which are
			 * ordered lexicographically. "Kube-like" versions start with a "v", then are followed by a
			 * number (the major version), then optionally the string "alpha" or "beta" and another number
			 * (the minor version). These are sorted first by GA > beta > alpha (where GA is a version
			 * with no suffix such as beta or alpha), and then by comparing major version, then minor
			 * version. An example sorted list of versions: v10, v2, v1, v11beta2, v10beta3, v3beta1,
			 * v12alpha1, v11alpha2, foo1, foo10.
			 */
			versions?: apiextensions.v1beta1.CustomResourceDefinitionVersion[]
		}

		/**
		 * CustomResourceDefinitionVersion describes a version for CRD.
		 */
		export interface CustomResourceDefinitionVersion {
			/**
			 * name is the version name, e.g. v1, v2beta1, etc. The custom resources are
			 * served under this version at `/apis/<group>/<version>/...` if `served` is true.
			 */
			name: string

			/**
			 * served is a flag enabling/disabling this version from being served via REST APIs
			 */
			served: boolean

			/**
			 * storage indicates this version should be used when persisting custom resources to storage.
			 * There must be exactly one version with storage=true.
			 */
			storage: boolean

			/**
			 * additionalPrinterColumns specifies additional columns returned in Table output. See
			 * https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
			 * for details. Top-level and per-version columns are mutually exclusive. Per-version columns
			 * must not all be set to identical values (top-level columns should be used instead). If no
			 * top-level or per-version columns are specified, a single column displaying the age of the
			 * custom resource is used.
			 */
			additionalPrinterColumns?: apiextensions.v1beta1.CustomResourceColumnDefinition[]

			/**
			 * schema describes the schema used for validation and pruning of this version of the custom
			 * resource. Top-level and per-version schemas are mutually exclusive. Per-version schemas
			 * must not all be set to identical values (top-level validation schema should be used
			 * instead).
			 */
			schema?: apiextensions.v1beta1.CustomResourceValidation

			/**
			 * subresources specify what subresources this version of the defined custom resource have.
			 * Top-level and per-version subresources are mutually exclusive. Per-version subresources
			 * must not all be set to identical values (top-level subresources should be used instead).
			 */
			subresources?: apiextensions.v1beta1.CustomResourceSubresources
		}

		/**
		 * CustomResourceSubresourceScale defines how to serve the scale subresource for
		 * CustomResources.
		 */
		export interface CustomResourceSubresourceScale {
			/**
			 * specReplicasPath defines the JSON path inside of a custom resource that corresponds to
			 * Scale `spec.replicas`. Only JSON paths without the array notation are allowed. Must be a
			 * JSON Path under `.spec`. If there is no value under the given path in the custom resource,
			 * the `/scale` subresource will return an error on GET.
			 */
			specReplicasPath: string

			/**
			 * statusReplicasPath defines the JSON path inside of a custom resource that corresponds to
			 * Scale `status.replicas`. Only JSON paths without the array notation are allowed. Must be a
			 * JSON Path under `.status`. If there is no value under the given path in the custom
			 * resource, the `status.replicas` value in the `/scale` subresource will default to 0.
			 */
			statusReplicasPath: string

			/**
			 * labelSelectorPath defines the JSON path inside of a custom resource that corresponds to
			 * Scale `status.selector`. Only JSON paths without the array notation are allowed. Must be a
			 * JSON Path under `.status` or `.spec`. Must be set to work with HorizontalPodAutoscaler. The
			 * field pointed by this JSON path must be a string field (not a complex selector struct)
			 * which contains a serialized label selector in string form. More info:
			 * https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource
			 * If there is no value under the given path in the custom resource, the `status.selector`
			 * value in the `/scale` subresource will default to the empty string.
			 */
			labelSelectorPath?: string
		}

		/**
		 * CustomResourceSubresources defines the status and scale subresources for CustomResources.
		 */
		export interface CustomResourceSubresources {
			/**
			 * scale indicates the custom resource should serve a `/scale` subresource that returns an
			 * `autoscaling/v1` Scale object.
			 */
			scale?: apiextensions.v1beta1.CustomResourceSubresourceScale
		}

		/**
		 * CustomResourceValidation is a list of validation methods for CustomResources.
		 */
		export interface CustomResourceValidation {
			/**
			 * openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.
			 */
			openAPIV3Schema?: apiextensions.v1beta1.JSONSchemaProps
		}

		/**
		 * ExternalDocumentation allows referencing an external resource for extended documentation.
		 */
		export interface ExternalDocumentation {
			description?: string

			url?: string
		}

		/**
		 * JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
		 */
		export interface JSONSchemaProps {
			$ref?: string

			$schema?: string

			additionalItems?: apiextensions.v1beta1.JSONSchemaProps | boolean

			additionalProperties?: apiextensions.v1beta1.JSONSchemaProps | boolean

			allOf?: apiextensions.v1beta1.JSONSchemaProps[]

			anyOf?: apiextensions.v1beta1.JSONSchemaProps[]

			/**
			 * default is a default value for undefined object fields. Defaulting is a beta feature under
			 * the CustomResourceDefaulting feature gate. CustomResourceDefinitions with defaults must be
			 * created using the v1 (or newer) CustomResourceDefinition API.
			 */
			default?: any

			definitions?: object

			dependencies?: object

			description?: string

			enum?: any[]

			example?: any

			exclusiveMaximum?: boolean

			exclusiveMinimum?: boolean

			externalDocs?: apiextensions.v1beta1.ExternalDocumentation

			/**
			 * format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats
			 * are validated:
			 *
			 * - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed
			 * by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang
			 * net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as
			 * defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang
			 * net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by
			 * Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID
			 * that allows uppercase defined by the regex
			 * (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3
			 * that allows uppercase defined by the regex
			 * (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4
			 * that allows uppercase defined by the regex
			 * (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an
			 * UUID5 that allows uppercase defined by the regex
			 * (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an
			 * ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10
			 * number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041" -
			 * creditcard: a credit card number defined by the regex
			 * ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$
			 * with any non digit characters mixed in - ssn: a U.S. social security number following the
			 * regex ^\d{3}[- ]?\d{2}[- ]?\d{4}$ - hexcolor: an hexadecimal color code like "#FFFFFF:
			 * following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like
			 * rgb like "rgb(255,255,2559" - byte: base64 encoded binary data - password: any kind of
			 * string - date: a date string like "2006-01-02" as defined by full-date in RFC3339 -
			 * duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or
			 * compatible with Scala duration format - datetime: a date time string like
			 * "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
			 */
			format?: string

			id?: string

			items?: apiextensions.v1beta1.JSONSchemaProps | any[]

			maxItems?: number

			maxLength?: number

			maxProperties?: number

			maximum?: number

			minItems?: number

			minLength?: number

			minProperties?: number

			minimum?: number

			multipleOf?: number

			not?: apiextensions.v1beta1.JSONSchemaProps

			nullable?: boolean

			oneOf?: apiextensions.v1beta1.JSONSchemaProps[]

			pattern?: string

			patternProperties?: object

			properties?: object

			required?: string[]

			title?: string

			type?: string

			uniqueItems?: boolean

			/**
			 * x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes
			 * runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to
			 * further restrict the embedded object. kind, apiVersion and metadata are validated
			 * automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not
			 * have to be if the object is fully specified (up to kind, apiVersion, metadata).
			 */
			x_kubernetes_embedded_resource?: boolean

			/**
			 * x-kubernetes-int-or-string specifies that this value is either an integer or a string. If
			 * this is true, an empty type is allowed and type as child of anyOf is permitted if following
			 * one of the following patterns:
			 *
			 * 1) anyOf:
			 *    - type: integer
			 *    - type: string
			 * 2) allOf:
			 *    - anyOf:
			 *      - type: integer
			 *      - type: string
			 *    - ... zero or more
			 */
			x_kubernetes_int_or_string?: boolean

			/**
			 * x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by
			 * specifying the keys used as the index of the map.
			 *
			 * This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set to
			 * "map". Also, the values specified for this attribute must be a scalar typed field of the
			 * child structure (no nesting is supported).
			 */
			x_kubernetes_list_map_keys?: string[]

			/**
			 * x-kubernetes-list-type annotates an array to further describe its topology. This extension
			 * must only be used on lists and may have 3 possible values:
			 *
			 * 1) `atomic`: the list is treated as a single entity, like a scalar.
			 *      Atomic lists will be entirely replaced when updated. This extension
			 *      may be used on any type of list (struct, scalar, ...).
			 * 2) `set`:
			 *      Sets are lists that must not have multiple items with the same value. Each
			 *      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an
			 *      array with x-kubernetes-list-type `atomic`.
			 * 3) `map`:
			 *      These lists are like maps in that their elements have a non-index key
			 *      used to identify them. Order is preserved upon merge. The map tag
			 *      must only be used on a list with elements of type object.
			 * Defaults to atomic for arrays.
			 */
			x_kubernetes_list_type?: string

			/**
			 * x-kubernetes-map-type annotates an object to further describe its topology. This extension
			 * must only be used when type is object and may have 2 possible values:
			 *
			 * 1) `granular`:
			 *      These maps are actual maps (key-value pairs) and each fields are independent
			 *      from each other (they can each be manipulated by separate actors). This is
			 *      the default behaviour for all maps.
			 * 2) `atomic`: the list is treated as a single entity, like a scalar.
			 *      Atomic maps will be entirely replaced when updated.
			 */
			x_kubernetes_map_type?: string

			/**
			 * x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields
			 * which are not specified in the validation schema. This affects fields recursively, but
			 * switches back to normal pruning behaviour if nested properties or additionalProperties are
			 * specified in the schema. This can either be true or undefined. False is forbidden.
			 */
			x_kubernetes_preserve_unknown_fields?: boolean
		}

		/**
		 * ServiceReference holds a reference to Service.legacy.k8s.io
		 */
		export interface ServiceReference {
			/**
			 * name is the name of the service. Required
			 */
			name: string

			/**
			 * namespace is the namespace of the service. Required
			 */
			namespace: string

			/**
			 * path is an optional URL path at which the webhook will be contacted.
			 */
			path?: string

			/**
			 * port is an optional service port at which the webhook will be contacted. `port` should be a
			 * valid port number (1-65535, inclusive). Defaults to 443 for backward compatibility.
			 */
			port?: number
		}

		/**
		 * WebhookClientConfig contains the information to make a TLS connection with the webhook.
		 */
		export interface WebhookClientConfig {
			/**
			 * caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server
			 * certificate. If unspecified, system trust roots on the apiserver are used.
			 */
			caBundle?: string

			/**
			 * service is a reference to the service for this webhook. Either service or url must be
			 * specified.
			 *
			 * If the webhook is running within the cluster, then you should use `service`.
			 */
			service?: apiextensions.v1beta1.ServiceReference

			/**
			 * url gives the location of the webhook, in standard URL form (`scheme://host:port/path`).
			 * Exactly one of `url` or `service` must be specified.
			 *
			 * The `host` should not refer to a service running in the cluster; use the `service` field
			 * instead. The host might be resolved via external DNS in some apiservers (e.g.,
			 * `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
			 * `host` may also be an IP address.
			 *
			 * Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
			 * great care to run this webhook on all hosts which run an apiserver which might need to make
			 * calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn
			 * up in a new cluster.
			 *
			 * The scheme must be "https"; the URL must begin with "https://".
			 *
			 * A path is optional, and if present may be any string permissible in a URL. You may use the
			 * path to pass an arbitrary string to the webhook, for example, a cluster identifier.
			 *
			 * Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
			 * ("#...") and query parameters ("?...") are not allowed, either.
			 */
			url?: string
		}
	}
}

export namespace apiregistration {
	export namespace v1 {
		/**
		 * APIService represents a server for a particular GroupVersion. Name must be "version.group".
		 */
		export interface APIService {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apiregistration.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'APIService'

			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec contains information for locating and communicating with a server
			 */
			spec?: apiregistration.v1.APIServiceSpec
		}

		export function isAPIService(o: any): o is APIService {
			return (
				o.apiVersion == 'apiregistration.k8s.io/v1' && o.kind == 'APIService'
			)
		}

		/**
		 * APIServiceCondition describes the state of an APIService at a particular point
		 */
		export interface APIServiceCondition {
			/**
			 * Type is the type of the condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * Human-readable message indicating details about last transition.
			 */
			message?: string

			/**
			 * Unique, one-word, CamelCase reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * APIServiceList is a list of APIService objects.
		 */
		export interface APIServiceList {
			items: apiregistration.v1.APIService[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apiregistration.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'APIServiceList'

			metadata?: meta.v1.ListMeta
		}

		export function isAPIServiceList(o: any): o is APIServiceList {
			return (
				o.apiVersion == 'apiregistration.k8s.io/v1' &&
				o.kind == 'APIServiceList'
			)
		}

		/**
		 * APIServiceSpec contains information for locating and communicating with a server. Only https
		 * is supported, though you are able to disable certificate verification.
		 */
		export interface APIServiceSpec {
			/**
			 * GroupPriorityMininum is the priority this group should have at least. Higher priority means
			 * that the group is preferred by clients over lower priority ones. Note that other versions
			 * of this group might specify even higher GroupPriorityMininum values such that the whole
			 * group gets a higher priority. The primary sort is based on GroupPriorityMinimum, ordered
			 * highest number to lowest (20 before 10). The secondary sort is based on the alphabetical
			 * comparison of the name of the object.  (v1.bar before v1.foo) We'd recommend something
			 * like: *.k8s.io (except extensions) at 18000 and PaaSes (OpenShift, Deis) are recommended to
			 * be in the 2000s
			 */
			groupPriorityMinimum: number

			/**
			 * Service is a reference to the service for this API server.  It must communicate on port 443
			 * If the Service is nil, that means the handling for the API groupversion is handled locally
			 * on this server. The call will simply delegate to the normal handler chain to be fulfilled.
			 */
			service: apiregistration.v1.ServiceReference

			/**
			 * VersionPriority controls the ordering of this API version inside of its group.  Must be
			 * greater than zero. The primary sort is based on VersionPriority, ordered highest to lowest
			 * (20 before 10). Since it's inside of a group, the number can be small, probably in the 10s.
			 * In case of equal version priorities, the version string will be used to compute the order
			 * inside a group. If the version string is "kube-like", it will sort above non "kube-like"
			 * version strings, which are ordered lexicographically. "Kube-like" versions start with a
			 * "v", then are followed by a number (the major version), then optionally the string "alpha"
			 * or "beta" and another number (the minor version). These are sorted first by GA > beta >
			 * alpha (where GA is a version with no suffix such as beta or alpha), and then by comparing
			 * major version, then minor version. An example sorted list of versions: v10, v2, v1,
			 * v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
			 */
			versionPriority: number

			/**
			 * CABundle is a PEM encoded CA bundle which will be used to validate an API server's serving
			 * certificate. If unspecified, system trust roots on the apiserver are used.
			 */
			caBundle?: string

			/**
			 * Group is the API group name this server hosts
			 */
			group?: string

			/**
			 * InsecureSkipTLSVerify disables TLS certificate verification when communicating with this
			 * server. This is strongly discouraged.  You should use the CABundle instead.
			 */
			insecureSkipTLSVerify?: boolean

			/**
			 * Version is the API version this server hosts.  For example, "v1"
			 */
			version?: string
		}

		/**
		 * ServiceReference holds a reference to Service.legacy.k8s.io
		 */
		export interface ServiceReference {
			/**
			 * Name is the name of the service
			 */
			name?: string

			/**
			 * Namespace is the namespace of the service
			 */
			namespace?: string

			/**
			 * If specified, the port on the service that hosting webhook. Default to 443 for backward
			 * compatibility. `port` should be a valid port number (1-65535, inclusive).
			 */
			port?: number
		}
	}
	export namespace v1beta1 {
		/**
		 * APIService represents a server for a particular GroupVersion. Name must be "version.group".
		 */
		export interface APIService {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apiregistration.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'APIService'

			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec contains information for locating and communicating with a server
			 */
			spec?: apiregistration.v1beta1.APIServiceSpec
		}

		export function isAPIService(o: any): o is APIService {
			return (
				o.apiVersion == 'apiregistration.k8s.io/v1beta1' &&
				o.kind == 'APIService'
			)
		}

		/**
		 * APIServiceCondition describes the state of an APIService at a particular point
		 */
		export interface APIServiceCondition {
			/**
			 * Type is the type of the condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * Human-readable message indicating details about last transition.
			 */
			message?: string

			/**
			 * Unique, one-word, CamelCase reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * APIServiceList is a list of APIService objects.
		 */
		export interface APIServiceList {
			items: apiregistration.v1beta1.APIService[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apiregistration.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'APIServiceList'

			metadata?: meta.v1.ListMeta
		}

		export function isAPIServiceList(o: any): o is APIServiceList {
			return (
				o.apiVersion == 'apiregistration.k8s.io/v1beta1' &&
				o.kind == 'APIServiceList'
			)
		}

		/**
		 * APIServiceSpec contains information for locating and communicating with a server. Only https
		 * is supported, though you are able to disable certificate verification.
		 */
		export interface APIServiceSpec {
			/**
			 * GroupPriorityMininum is the priority this group should have at least. Higher priority means
			 * that the group is preferred by clients over lower priority ones. Note that other versions
			 * of this group might specify even higher GroupPriorityMininum values such that the whole
			 * group gets a higher priority. The primary sort is based on GroupPriorityMinimum, ordered
			 * highest number to lowest (20 before 10). The secondary sort is based on the alphabetical
			 * comparison of the name of the object.  (v1.bar before v1.foo) We'd recommend something
			 * like: *.k8s.io (except extensions) at 18000 and PaaSes (OpenShift, Deis) are recommended to
			 * be in the 2000s
			 */
			groupPriorityMinimum: number

			/**
			 * Service is a reference to the service for this API server.  It must communicate on port 443
			 * If the Service is nil, that means the handling for the API groupversion is handled locally
			 * on this server. The call will simply delegate to the normal handler chain to be fulfilled.
			 */
			service: apiregistration.v1beta1.ServiceReference

			/**
			 * VersionPriority controls the ordering of this API version inside of its group.  Must be
			 * greater than zero. The primary sort is based on VersionPriority, ordered highest to lowest
			 * (20 before 10). Since it's inside of a group, the number can be small, probably in the 10s.
			 * In case of equal version priorities, the version string will be used to compute the order
			 * inside a group. If the version string is "kube-like", it will sort above non "kube-like"
			 * version strings, which are ordered lexicographically. "Kube-like" versions start with a
			 * "v", then are followed by a number (the major version), then optionally the string "alpha"
			 * or "beta" and another number (the minor version). These are sorted first by GA > beta >
			 * alpha (where GA is a version with no suffix such as beta or alpha), and then by comparing
			 * major version, then minor version. An example sorted list of versions: v10, v2, v1,
			 * v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
			 */
			versionPriority: number

			/**
			 * CABundle is a PEM encoded CA bundle which will be used to validate an API server's serving
			 * certificate. If unspecified, system trust roots on the apiserver are used.
			 */
			caBundle?: string

			/**
			 * Group is the API group name this server hosts
			 */
			group?: string

			/**
			 * InsecureSkipTLSVerify disables TLS certificate verification when communicating with this
			 * server. This is strongly discouraged.  You should use the CABundle instead.
			 */
			insecureSkipTLSVerify?: boolean

			/**
			 * Version is the API version this server hosts.  For example, "v1"
			 */
			version?: string
		}

		/**
		 * ServiceReference holds a reference to Service.legacy.k8s.io
		 */
		export interface ServiceReference {
			/**
			 * Name is the name of the service
			 */
			name?: string

			/**
			 * Namespace is the namespace of the service
			 */
			namespace?: string

			/**
			 * If specified, the port on the service that hosting webhook. Default to 443 for backward
			 * compatibility. `port` should be a valid port number (1-65535, inclusive).
			 */
			port?: number
		}
	}
}

export namespace apps {
	export namespace v1 {
		/**
		 * ControllerRevision implements an immutable snapshot of state data. Clients are responsible
		 * for serializing and deserializing the objects that contain their internal state. Once a
		 * ControllerRevision has been successfully created, it can not be updated. The API Server will
		 * fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
		 * may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
		 * controllers for update and rollback, this object is beta. However, it may be subject to name
		 * and representation changes in future releases, and clients should not depend on its
		 * stability. It is primarily for internal use by controllers.
		 */
		export interface ControllerRevision {
			/**
			 * Revision indicates the revision of the state represented by Data.
			 */
			revision: number

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1'

			/**
			 * Data is the serialized representation of the state.
			 */
			data?: object

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ControllerRevision'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isControllerRevision(o: any): o is ControllerRevision {
			return o.apiVersion == 'apps/v1' && o.kind == 'ControllerRevision'
		}

		/**
		 * ControllerRevisionList is a resource containing a list of ControllerRevision objects.
		 */
		export interface ControllerRevisionList {
			/**
			 * Items is the list of ControllerRevisions
			 */
			items: apps.v1.ControllerRevision[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ControllerRevisionList'

			/**
			 * More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isControllerRevisionList(
			o: any
		): o is ControllerRevisionList {
			return o.apiVersion == 'apps/v1' && o.kind == 'ControllerRevisionList'
		}

		/**
		 * DaemonSet represents the configuration of a daemon set.
		 */
		export interface DaemonSet {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'DaemonSet'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * The desired behavior of this daemon set. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: apps.v1.DaemonSetSpec
		}

		export function isDaemonSet(o: any): o is DaemonSet {
			return o.apiVersion == 'apps/v1' && o.kind == 'DaemonSet'
		}

		/**
		 * DaemonSetCondition describes the state of a DaemonSet at a certain point.
		 */
		export interface DaemonSetCondition {
			/**
			 * Type of DaemonSet condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * DaemonSetList is a collection of daemon sets.
		 */
		export interface DaemonSetList {
			/**
			 * A list of daemon sets.
			 */
			items: apps.v1.DaemonSet[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'DaemonSetList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isDaemonSetList(o: any): o is DaemonSetList {
			return o.apiVersion == 'apps/v1' && o.kind == 'DaemonSetList'
		}

		/**
		 * DaemonSetSpec is the specification of a daemon set.
		 */
		export interface DaemonSetSpec {
			/**
			 * A label query over pods that are managed by the daemon set. Must match in order to be
			 * controlled. It must match the pod template's labels. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
			 */
			selector: meta.v1.LabelSelector

			/**
			 * An object that describes the pod that will be created. The DaemonSet will create exactly
			 * one copy of this pod on every node that matches the template's node selector (or on every
			 * node if no node selector is specified). More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
			 */
			template: core.v1.PodTemplateSpec

			/**
			 * The minimum number of seconds for which a newly created DaemonSet pod should be ready
			 * without any of its container crashing, for it to be considered available. Defaults to 0
			 * (pod will be considered available as soon as it is ready).
			 */
			minReadySeconds?: number

			/**
			 * The number of old history to retain to allow rollback. This is a pointer to distinguish
			 * between explicit zero and not specified. Defaults to 10.
			 */
			revisionHistoryLimit?: number

			/**
			 * An update strategy to replace existing DaemonSet pods with new pods.
			 */
			updateStrategy?: apps.v1.DaemonSetUpdateStrategy
		}

		/**
		 * DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
		 */
		export interface DaemonSetUpdateStrategy {
			/**
			 * Rolling update config params. Present only if type = "RollingUpdate".
			 */
			rollingUpdate?: apps.v1.RollingUpdateDaemonSet

			/**
			 * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
			 */
			type?: string
		}

		/**
		 * Deployment enables declarative updates for Pods and ReplicaSets.
		 */
		export interface Deployment {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Deployment'

			/**
			 * Standard object metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of the Deployment.
			 */
			spec?: apps.v1.DeploymentSpec
		}

		export function isDeployment(o: any): o is Deployment {
			return o.apiVersion == 'apps/v1' && o.kind == 'Deployment'
		}

		/**
		 * DeploymentCondition describes the state of a deployment at a certain point.
		 */
		export interface DeploymentCondition {
			/**
			 * Type of deployment condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * The last time this condition was updated.
			 */
			lastUpdateTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * DeploymentList is a list of Deployments.
		 */
		export interface DeploymentList {
			/**
			 * Items is the list of Deployments.
			 */
			items: apps.v1.Deployment[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'DeploymentList'

			/**
			 * Standard list metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isDeploymentList(o: any): o is DeploymentList {
			return o.apiVersion == 'apps/v1' && o.kind == 'DeploymentList'
		}

		/**
		 * DeploymentSpec is the specification of the desired behavior of the Deployment.
		 */
		export interface DeploymentSpec {
			/**
			 * Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the
			 * ones affected by this deployment. It must match the pod template's labels.
			 */
			selector: meta.v1.LabelSelector

			/**
			 * Template describes the pods that will be created.
			 */
			template: core.v1.PodTemplateSpec

			/**
			 * Minimum number of seconds for which a newly created pod should be ready without any of its
			 * container crashing, for it to be considered available. Defaults to 0 (pod will be
			 * considered available as soon as it is ready)
			 */
			minReadySeconds?: number

			/**
			 * Indicates that the deployment is paused.
			 */
			paused?: boolean

			/**
			 * The maximum time in seconds for a deployment to make progress before it is considered to be
			 * failed. The deployment controller will continue to process failed deployments and a
			 * condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status.
			 * Note that progress will not be estimated during the time a deployment is paused. Defaults
			 * to 600s.
			 */
			progressDeadlineSeconds?: number

			/**
			 * Number of desired pods. This is a pointer to distinguish between explicit zero and not
			 * specified. Defaults to 1.
			 */
			replicas?: number

			/**
			 * The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish
			 * between explicit zero and not specified. Defaults to 10.
			 */
			revisionHistoryLimit?: number

			/**
			 * The deployment strategy to use to replace existing pods with new ones.
			 */
			strategy?: apps.v1.DeploymentStrategy
		}

		/**
		 * DeploymentStrategy describes how to replace existing pods with new ones.
		 */
		export interface DeploymentStrategy {
			/**
			 * Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
			 */
			rollingUpdate?: apps.v1.RollingUpdateDeployment

			/**
			 * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
			 */
			type?: string
		}

		/**
		 * ReplicaSet ensures that a specified number of pod replicas are running at any given time.
		 */
		export interface ReplicaSet {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ReplicaSet'

			/**
			 * If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
			 * that the ReplicaSet manages. Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the specification of the desired behavior of the ReplicaSet. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: apps.v1.ReplicaSetSpec
		}

		export function isReplicaSet(o: any): o is ReplicaSet {
			return o.apiVersion == 'apps/v1' && o.kind == 'ReplicaSet'
		}

		/**
		 * ReplicaSetCondition describes the state of a replica set at a certain point.
		 */
		export interface ReplicaSetCondition {
			/**
			 * Type of replica set condition.
			 */
			type: string

			/**
			 * The last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * ReplicaSetList is a collection of ReplicaSets.
		 */
		export interface ReplicaSetList {
			/**
			 * List of ReplicaSets. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
			 */
			items: apps.v1.ReplicaSet[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ReplicaSetList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isReplicaSetList(o: any): o is ReplicaSetList {
			return o.apiVersion == 'apps/v1' && o.kind == 'ReplicaSetList'
		}

		/**
		 * ReplicaSetSpec is the specification of a ReplicaSet.
		 */
		export interface ReplicaSetSpec {
			/**
			 * Selector is a label query over pods that should match the replica count. Label keys and
			 * values that must match in order to be controlled by this replica set. It must match the pod
			 * template's labels. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
			 */
			selector: meta.v1.LabelSelector

			/**
			 * Minimum number of seconds for which a newly created pod should be ready without any of its
			 * container crashing, for it to be considered available. Defaults to 0 (pod will be
			 * considered available as soon as it is ready)
			 */
			minReadySeconds?: number

			/**
			 * Replicas is the number of desired replicas. This is a pointer to distinguish between
			 * explicit zero and unspecified. Defaults to 1. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
			 */
			replicas?: number

			/**
			 * Template is the object that describes the pod that will be created if insufficient replicas
			 * are detected. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
			 */
			template?: core.v1.PodTemplateSpec
		}

		/**
		 * Spec to control the desired behavior of daemon set rolling update.
		 */
		export interface RollingUpdateDaemonSet {
			/**
			 * The maximum number of DaemonSet pods that can be unavailable during the update. Value can
			 * be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the
			 * start of the update (ex: 10%). Absolute number is calculated from percentage by rounding
			 * up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at most 30% of
			 * the total number of nodes that should be running the daemon pod (i.e.
			 * status.desiredNumberScheduled) can have their pods stopped for an update at any given time.
			 * The update starts by stopping at most 30% of those DaemonSet pods and then brings up new
			 * DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other
			 * DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are
			 * available at all times during the update.
			 */
			maxUnavailable?: number | string
		}

		/**
		 * Spec to control the desired behavior of rolling update.
		 */
		export interface RollingUpdateDeployment {
			/**
			 * The maximum number of pods that can be scheduled above the desired number of pods. Value
			 * can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not
			 * be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up.
			 * Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up
			 * immediately when the rolling update starts, such that the total number of old and new pods
			 * do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be
			 * scaled up further, ensuring that total number of pods running at any time during the update
			 * is at most 130% of desired pods.
			 */
			maxSurge?: number | string

			/**
			 * The maximum number of pods that can be unavailable during the update. Value can be an
			 * absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
			 * calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults
			 * to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of
			 * desired pods immediately when the rolling update starts. Once new pods are ready, old
			 * ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
			 * that the total number of pods available at all times during the update is at least 70% of
			 * desired pods.
			 */
			maxUnavailable?: number | string
		}

		/**
		 * RollingUpdateStatefulSetStrategy is used to communicate parameter for
		 * RollingUpdateStatefulSetStrategyType.
		 */
		export interface RollingUpdateStatefulSetStrategy {
			/**
			 * Partition indicates the ordinal at which the StatefulSet should be partitioned. Default
			 * value is 0.
			 */
			partition?: number
		}

		/**
		 * StatefulSet represents a set of pods with consistent identities. Identities are defined as:
		 *  - Network: A single stable DNS and hostname.
		 *  - Storage: As many VolumeClaims as requested.
		 * The StatefulSet guarantees that a given network identity will always map to the same storage
		 * identity.
		 */
		export interface StatefulSet {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'StatefulSet'

			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the desired identities of pods in this set.
			 */
			spec?: apps.v1.StatefulSetSpec
		}

		export function isStatefulSet(o: any): o is StatefulSet {
			return o.apiVersion == 'apps/v1' && o.kind == 'StatefulSet'
		}

		/**
		 * StatefulSetCondition describes the state of a statefulset at a certain point.
		 */
		export interface StatefulSetCondition {
			/**
			 * Type of statefulset condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * StatefulSetList is a collection of StatefulSets.
		 */
		export interface StatefulSetList {
			items: apps.v1.StatefulSet[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'StatefulSetList'

			metadata?: meta.v1.ListMeta
		}

		export function isStatefulSetList(o: any): o is StatefulSetList {
			return o.apiVersion == 'apps/v1' && o.kind == 'StatefulSetList'
		}

		/**
		 * A StatefulSetSpec is the specification of a StatefulSet.
		 */
		export interface StatefulSetSpec {
			/**
			 * selector is a label query over pods that should match the replica count. It must match the
			 * pod template's labels. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
			 */
			selector: meta.v1.LabelSelector

			/**
			 * serviceName is the name of the service that governs this StatefulSet. This service must
			 * exist before the StatefulSet, and is responsible for the network identity of the set. Pods
			 * get DNS/hostnames that follow the pattern:
			 * pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
			 * managed by the StatefulSet controller.
			 */
			serviceName: string

			/**
			 * template is the object that describes the pod that will be created if insufficient replicas
			 * are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have
			 * a unique identity from the rest of the StatefulSet.
			 */
			template: core.v1.PodTemplateSpec

			/**
			 * podManagementPolicy controls how pods are created during initial scale up, when replacing
			 * pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are
			 * created in increasing order (pod-0, then pod-1, etc) and the controller will wait until
			 * each pod is ready before continuing. When scaling down, the pods are removed in the
			 * opposite order. The alternative policy is `Parallel` which will create pods in parallel to
			 * match the desired scale without waiting, and on scale down will delete all pods at once.
			 */
			podManagementPolicy?: string

			/**
			 * replicas is the desired number of replicas of the given Template. These are replicas in the
			 * sense that they are instantiations of the same Template, but individual replicas also have
			 * a consistent identity. If unspecified, defaults to 1.
			 */
			replicas?: number

			/**
			 * revisionHistoryLimit is the maximum number of revisions that will be maintained in the
			 * StatefulSet's revision history. The revision history consists of all revisions not
			 * represented by a currently applied StatefulSetSpec version. The default value is 10.
			 */
			revisionHistoryLimit?: number

			/**
			 * updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods
			 * in the StatefulSet when a revision is made to Template.
			 */
			updateStrategy?: apps.v1.StatefulSetUpdateStrategy

			/**
			 * volumeClaimTemplates is a list of claims that pods are allowed to reference. The
			 * StatefulSet controller is responsible for mapping network identities to claims in a way
			 * that maintains the identity of a pod. Every claim in this list must have at least one
			 * matching (by name) volumeMount in one container in the template. A claim in this list takes
			 * precedence over any volumes in the template, with the same name.
			 */
			volumeClaimTemplates?: core.v1.PersistentVolumeClaim[]
		}

		/**
		 * StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
		 * perform updates. It includes any additional parameters necessary to perform the update for
		 * the indicated strategy.
		 */
		export interface StatefulSetUpdateStrategy {
			/**
			 * RollingUpdate is used to communicate parameters when Type is
			 * RollingUpdateStatefulSetStrategyType.
			 */
			rollingUpdate?: apps.v1.RollingUpdateStatefulSetStrategy

			/**
			 * Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
			 */
			type?: string
		}
	}
	export namespace v1beta1 {
		/**
		 * ControllerRevision implements an immutable snapshot of state data. Clients are responsible
		 * for serializing and deserializing the objects that contain their internal state. Once a
		 * ControllerRevision has been successfully created, it can not be updated. The API Server will
		 * fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
		 * may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
		 * controllers for update and rollback, this object is beta. However, it may be subject to name
		 * and representation changes in future releases, and clients should not depend on its
		 * stability. It is primarily for internal use by controllers.
		 *
		 * @deprecated apps/v1beta1/ControllerRevision is deprecated by apps/v1/ControllerRevision and
		 * not supported by Kubernetes v1.16+ clusters.
		 */
		export interface ControllerRevision {
			/**
			 * Revision indicates the revision of the state represented by Data.
			 */
			revision: number

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta1'

			/**
			 * Data is the serialized representation of the state.
			 */
			data?: object

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ControllerRevision'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isControllerRevision(o: any): o is ControllerRevision {
			return o.apiVersion == 'apps/v1beta1' && o.kind == 'ControllerRevision'
		}

		/**
		 * ControllerRevisionList is a resource containing a list of ControllerRevision objects.
		 */
		export interface ControllerRevisionList {
			/**
			 * Items is the list of ControllerRevisions
			 */
			items: apps.v1beta1.ControllerRevision[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ControllerRevisionList'

			/**
			 * More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isControllerRevisionList(
			o: any
		): o is ControllerRevisionList {
			return (
				o.apiVersion == 'apps/v1beta1' && o.kind == 'ControllerRevisionList'
			)
		}

		/**
		 * Deployment enables declarative updates for Pods and ReplicaSets.
		 *
		 * @deprecated apps/v1beta1/Deployment is deprecated by apps/v1/Deployment and not supported by
		 * Kubernetes v1.16+ clusters.
		 */
		export interface Deployment {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Deployment'

			/**
			 * Standard object metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of the Deployment.
			 */
			spec?: apps.v1beta1.DeploymentSpec
		}

		export function isDeployment(o: any): o is Deployment {
			return o.apiVersion == 'apps/v1beta1' && o.kind == 'Deployment'
		}

		/**
		 * DeploymentCondition describes the state of a deployment at a certain point.
		 */
		export interface DeploymentCondition {
			/**
			 * Type of deployment condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * The last time this condition was updated.
			 */
			lastUpdateTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * DeploymentList is a list of Deployments.
		 */
		export interface DeploymentList {
			/**
			 * Items is the list of Deployments.
			 */
			items: apps.v1beta1.Deployment[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'DeploymentList'

			/**
			 * Standard list metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isDeploymentList(o: any): o is DeploymentList {
			return o.apiVersion == 'apps/v1beta1' && o.kind == 'DeploymentList'
		}

		/**
		 * DEPRECATED. DeploymentRollback stores the information required to rollback a deployment.
		 */
		export interface DeploymentRollback {
			/**
			 * Required: This must match the Name of a deployment.
			 */
			name: string

			/**
			 * The config of this deployment rollback.
			 */
			rollbackTo: apps.v1beta1.RollbackConfig

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string

			/**
			 * The annotations to be updated to a deployment
			 */
			updatedAnnotations?: { [key: string]: string }
		}

		export function isDeploymentRollback(o: any): o is DeploymentRollback {
			return o.apiVersion == 'apps/v1beta1' && o.kind == 'DeploymentRollback'
		}

		/**
		 * DeploymentSpec is the specification of the desired behavior of the Deployment.
		 */
		export interface DeploymentSpec {
			/**
			 * Template describes the pods that will be created.
			 */
			template: core.v1.PodTemplateSpec

			/**
			 * Minimum number of seconds for which a newly created pod should be ready without any of its
			 * container crashing, for it to be considered available. Defaults to 0 (pod will be
			 * considered available as soon as it is ready)
			 */
			minReadySeconds?: number

			/**
			 * Indicates that the deployment is paused.
			 */
			paused?: boolean

			/**
			 * The maximum time in seconds for a deployment to make progress before it is considered to be
			 * failed. The deployment controller will continue to process failed deployments and a
			 * condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status.
			 * Note that progress will not be estimated during the time a deployment is paused. Defaults
			 * to 600s.
			 */
			progressDeadlineSeconds?: number

			/**
			 * Number of desired pods. This is a pointer to distinguish between explicit zero and not
			 * specified. Defaults to 1.
			 */
			replicas?: number

			/**
			 * The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish
			 * between explicit zero and not specified. Defaults to 2.
			 */
			revisionHistoryLimit?: number

			/**
			 * DEPRECATED. The config this deployment is rolling back to. Will be cleared after rollback
			 * is done.
			 */
			rollbackTo?: apps.v1beta1.RollbackConfig

			/**
			 * Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the
			 * ones affected by this deployment.
			 */
			selector?: meta.v1.LabelSelector

			/**
			 * The deployment strategy to use to replace existing pods with new ones.
			 */
			strategy?: apps.v1beta1.DeploymentStrategy
		}

		/**
		 * DeploymentStrategy describes how to replace existing pods with new ones.
		 */
		export interface DeploymentStrategy {
			/**
			 * Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
			 */
			rollingUpdate?: apps.v1beta1.RollingUpdateDeployment

			/**
			 * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
			 */
			type?: string
		}

		/**
		 * DEPRECATED.
		 */
		export interface RollbackConfig {
			/**
			 * The revision to rollback to. If set to 0, rollback to the last revision.
			 */
			revision?: number
		}

		/**
		 * Spec to control the desired behavior of rolling update.
		 */
		export interface RollingUpdateDeployment {
			/**
			 * The maximum number of pods that can be scheduled above the desired number of pods. Value
			 * can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not
			 * be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up.
			 * Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up
			 * immediately when the rolling update starts, such that the total number of old and new pods
			 * do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be
			 * scaled up further, ensuring that total number of pods running at any time during the update
			 * is at most 130% of desired pods.
			 */
			maxSurge?: number | string

			/**
			 * The maximum number of pods that can be unavailable during the update. Value can be an
			 * absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
			 * calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults
			 * to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of
			 * desired pods immediately when the rolling update starts. Once new pods are ready, old
			 * ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
			 * that the total number of pods available at all times during the update is at least 70% of
			 * desired pods.
			 */
			maxUnavailable?: number | string
		}

		/**
		 * RollingUpdateStatefulSetStrategy is used to communicate parameter for
		 * RollingUpdateStatefulSetStrategyType.
		 */
		export interface RollingUpdateStatefulSetStrategy {
			/**
			 * Partition indicates the ordinal at which the StatefulSet should be partitioned.
			 */
			partition?: number
		}

		/**
		 * Scale represents a scaling request for a resource.
		 */
		export interface Scale {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string

			/**
			 * Standard object metadata; More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * defines the behavior of the scale. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
			 */
			spec?: apps.v1beta1.ScaleSpec
		}

		export function isScale(o: any): o is Scale {
			return o.apiVersion == 'apps/v1beta1' && o.kind == 'Scale'
		}

		/**
		 * ScaleSpec describes the attributes of a scale subresource
		 */
		export interface ScaleSpec {
			/**
			 * desired number of instances for the scaled object.
			 */
			replicas?: number
		}

		/**
		 * StatefulSet represents a set of pods with consistent identities. Identities are defined as:
		 *  - Network: A single stable DNS and hostname.
		 *  - Storage: As many VolumeClaims as requested.
		 * The StatefulSet guarantees that a given network identity will always map to the same storage
		 * identity.
		 *
		 * @deprecated apps/v1beta1/StatefulSet is deprecated by apps/v1/StatefulSet and not supported
		 * by Kubernetes v1.16+ clusters.
		 */
		export interface StatefulSet {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'StatefulSet'

			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the desired identities of pods in this set.
			 */
			spec?: apps.v1beta1.StatefulSetSpec
		}

		export function isStatefulSet(o: any): o is StatefulSet {
			return o.apiVersion == 'apps/v1beta1' && o.kind == 'StatefulSet'
		}

		/**
		 * StatefulSetCondition describes the state of a statefulset at a certain point.
		 */
		export interface StatefulSetCondition {
			/**
			 * Type of statefulset condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * StatefulSetList is a collection of StatefulSets.
		 */
		export interface StatefulSetList {
			items: apps.v1beta1.StatefulSet[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'StatefulSetList'

			metadata?: meta.v1.ListMeta
		}

		export function isStatefulSetList(o: any): o is StatefulSetList {
			return o.apiVersion == 'apps/v1beta1' && o.kind == 'StatefulSetList'
		}

		/**
		 * A StatefulSetSpec is the specification of a StatefulSet.
		 */
		export interface StatefulSetSpec {
			/**
			 * serviceName is the name of the service that governs this StatefulSet. This service must
			 * exist before the StatefulSet, and is responsible for the network identity of the set. Pods
			 * get DNS/hostnames that follow the pattern:
			 * pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
			 * managed by the StatefulSet controller.
			 */
			serviceName: string

			/**
			 * template is the object that describes the pod that will be created if insufficient replicas
			 * are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have
			 * a unique identity from the rest of the StatefulSet.
			 */
			template: core.v1.PodTemplateSpec

			/**
			 * podManagementPolicy controls how pods are created during initial scale up, when replacing
			 * pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are
			 * created in increasing order (pod-0, then pod-1, etc) and the controller will wait until
			 * each pod is ready before continuing. When scaling down, the pods are removed in the
			 * opposite order. The alternative policy is `Parallel` which will create pods in parallel to
			 * match the desired scale without waiting, and on scale down will delete all pods at once.
			 */
			podManagementPolicy?: string

			/**
			 * replicas is the desired number of replicas of the given Template. These are replicas in the
			 * sense that they are instantiations of the same Template, but individual replicas also have
			 * a consistent identity. If unspecified, defaults to 1.
			 */
			replicas?: number

			/**
			 * revisionHistoryLimit is the maximum number of revisions that will be maintained in the
			 * StatefulSet's revision history. The revision history consists of all revisions not
			 * represented by a currently applied StatefulSetSpec version. The default value is 10.
			 */
			revisionHistoryLimit?: number

			/**
			 * selector is a label query over pods that should match the replica count. If empty,
			 * defaulted to labels on the pod template. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
			 */
			selector?: meta.v1.LabelSelector

			/**
			 * updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods
			 * in the StatefulSet when a revision is made to Template.
			 */
			updateStrategy?: apps.v1beta1.StatefulSetUpdateStrategy

			/**
			 * volumeClaimTemplates is a list of claims that pods are allowed to reference. The
			 * StatefulSet controller is responsible for mapping network identities to claims in a way
			 * that maintains the identity of a pod. Every claim in this list must have at least one
			 * matching (by name) volumeMount in one container in the template. A claim in this list takes
			 * precedence over any volumes in the template, with the same name.
			 */
			volumeClaimTemplates?: core.v1.PersistentVolumeClaim[]
		}

		/**
		 * StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
		 * perform updates. It includes any additional parameters necessary to perform the update for
		 * the indicated strategy.
		 */
		export interface StatefulSetUpdateStrategy {
			/**
			 * RollingUpdate is used to communicate parameters when Type is
			 * RollingUpdateStatefulSetStrategyType.
			 */
			rollingUpdate?: apps.v1beta1.RollingUpdateStatefulSetStrategy

			/**
			 * Type indicates the type of the StatefulSetUpdateStrategy.
			 */
			type?: string
		}
	}
	export namespace v1beta2 {
		/**
		 * ControllerRevision implements an immutable snapshot of state data. Clients are responsible
		 * for serializing and deserializing the objects that contain their internal state. Once a
		 * ControllerRevision has been successfully created, it can not be updated. The API Server will
		 * fail validation of all requests that attempt to mutate the Data field. ControllerRevisions
		 * may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet
		 * controllers for update and rollback, this object is beta. However, it may be subject to name
		 * and representation changes in future releases, and clients should not depend on its
		 * stability. It is primarily for internal use by controllers.
		 *
		 * @deprecated apps/v1beta2/ControllerRevision is deprecated by apps/v1/ControllerRevision and
		 * not supported by Kubernetes v1.16+ clusters.
		 */
		export interface ControllerRevision {
			/**
			 * Revision indicates the revision of the state represented by Data.
			 */
			revision: number

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta2'

			/**
			 * Data is the serialized representation of the state.
			 */
			data?: object

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ControllerRevision'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isControllerRevision(o: any): o is ControllerRevision {
			return o.apiVersion == 'apps/v1beta2' && o.kind == 'ControllerRevision'
		}

		/**
		 * ControllerRevisionList is a resource containing a list of ControllerRevision objects.
		 */
		export interface ControllerRevisionList {
			/**
			 * Items is the list of ControllerRevisions
			 */
			items: apps.v1beta2.ControllerRevision[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta2'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ControllerRevisionList'

			/**
			 * More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isControllerRevisionList(
			o: any
		): o is ControllerRevisionList {
			return (
				o.apiVersion == 'apps/v1beta2' && o.kind == 'ControllerRevisionList'
			)
		}

		/**
		 * DaemonSet represents the configuration of a daemon set.
		 *
		 * @deprecated apps/v1beta2/DaemonSet is deprecated by apps/v1/DaemonSet and not supported by
		 * Kubernetes v1.16+ clusters.
		 */
		export interface DaemonSet {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta2'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'DaemonSet'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * The desired behavior of this daemon set. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: apps.v1beta2.DaemonSetSpec
		}

		export function isDaemonSet(o: any): o is DaemonSet {
			return o.apiVersion == 'apps/v1beta2' && o.kind == 'DaemonSet'
		}

		/**
		 * DaemonSetCondition describes the state of a DaemonSet at a certain point.
		 */
		export interface DaemonSetCondition {
			/**
			 * Type of DaemonSet condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * DaemonSetList is a collection of daemon sets.
		 */
		export interface DaemonSetList {
			/**
			 * A list of daemon sets.
			 */
			items: apps.v1beta2.DaemonSet[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta2'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'DaemonSetList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isDaemonSetList(o: any): o is DaemonSetList {
			return o.apiVersion == 'apps/v1beta2' && o.kind == 'DaemonSetList'
		}

		/**
		 * DaemonSetSpec is the specification of a daemon set.
		 */
		export interface DaemonSetSpec {
			/**
			 * A label query over pods that are managed by the daemon set. Must match in order to be
			 * controlled. It must match the pod template's labels. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
			 */
			selector: meta.v1.LabelSelector

			/**
			 * An object that describes the pod that will be created. The DaemonSet will create exactly
			 * one copy of this pod on every node that matches the template's node selector (or on every
			 * node if no node selector is specified). More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
			 */
			template: core.v1.PodTemplateSpec

			/**
			 * The minimum number of seconds for which a newly created DaemonSet pod should be ready
			 * without any of its container crashing, for it to be considered available. Defaults to 0
			 * (pod will be considered available as soon as it is ready).
			 */
			minReadySeconds?: number

			/**
			 * The number of old history to retain to allow rollback. This is a pointer to distinguish
			 * between explicit zero and not specified. Defaults to 10.
			 */
			revisionHistoryLimit?: number

			/**
			 * An update strategy to replace existing DaemonSet pods with new pods.
			 */
			updateStrategy?: apps.v1beta2.DaemonSetUpdateStrategy
		}

		/**
		 * DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
		 */
		export interface DaemonSetUpdateStrategy {
			/**
			 * Rolling update config params. Present only if type = "RollingUpdate".
			 */
			rollingUpdate?: apps.v1beta2.RollingUpdateDaemonSet

			/**
			 * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
			 */
			type?: string
		}

		/**
		 * Deployment enables declarative updates for Pods and ReplicaSets.
		 *
		 * @deprecated apps/v1beta2/Deployment is deprecated by apps/v1/Deployment and not supported by
		 * Kubernetes v1.16+ clusters.
		 */
		export interface Deployment {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta2'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Deployment'

			/**
			 * Standard object metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of the Deployment.
			 */
			spec?: apps.v1beta2.DeploymentSpec
		}

		export function isDeployment(o: any): o is Deployment {
			return o.apiVersion == 'apps/v1beta2' && o.kind == 'Deployment'
		}

		/**
		 * DeploymentCondition describes the state of a deployment at a certain point.
		 */
		export interface DeploymentCondition {
			/**
			 * Type of deployment condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * The last time this condition was updated.
			 */
			lastUpdateTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * DeploymentList is a list of Deployments.
		 */
		export interface DeploymentList {
			/**
			 * Items is the list of Deployments.
			 */
			items: apps.v1beta2.Deployment[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta2'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'DeploymentList'

			/**
			 * Standard list metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isDeploymentList(o: any): o is DeploymentList {
			return o.apiVersion == 'apps/v1beta2' && o.kind == 'DeploymentList'
		}

		/**
		 * DeploymentSpec is the specification of the desired behavior of the Deployment.
		 */
		export interface DeploymentSpec {
			/**
			 * Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the
			 * ones affected by this deployment. It must match the pod template's labels.
			 */
			selector: meta.v1.LabelSelector

			/**
			 * Template describes the pods that will be created.
			 */
			template: core.v1.PodTemplateSpec

			/**
			 * Minimum number of seconds for which a newly created pod should be ready without any of its
			 * container crashing, for it to be considered available. Defaults to 0 (pod will be
			 * considered available as soon as it is ready)
			 */
			minReadySeconds?: number

			/**
			 * Indicates that the deployment is paused.
			 */
			paused?: boolean

			/**
			 * The maximum time in seconds for a deployment to make progress before it is considered to be
			 * failed. The deployment controller will continue to process failed deployments and a
			 * condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status.
			 * Note that progress will not be estimated during the time a deployment is paused. Defaults
			 * to 600s.
			 */
			progressDeadlineSeconds?: number

			/**
			 * Number of desired pods. This is a pointer to distinguish between explicit zero and not
			 * specified. Defaults to 1.
			 */
			replicas?: number

			/**
			 * The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish
			 * between explicit zero and not specified. Defaults to 10.
			 */
			revisionHistoryLimit?: number

			/**
			 * The deployment strategy to use to replace existing pods with new ones.
			 */
			strategy?: apps.v1beta2.DeploymentStrategy
		}

		/**
		 * DeploymentStrategy describes how to replace existing pods with new ones.
		 */
		export interface DeploymentStrategy {
			/**
			 * Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
			 */
			rollingUpdate?: apps.v1beta2.RollingUpdateDeployment

			/**
			 * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
			 */
			type?: string
		}

		/**
		 * ReplicaSet ensures that a specified number of pod replicas are running at any given time.
		 *
		 * @deprecated apps/v1beta2/ReplicaSet is deprecated by apps/v1/ReplicaSet and not supported by
		 * Kubernetes v1.16+ clusters.
		 */
		export interface ReplicaSet {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta2'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ReplicaSet'

			/**
			 * If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
			 * that the ReplicaSet manages. Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the specification of the desired behavior of the ReplicaSet. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: apps.v1beta2.ReplicaSetSpec
		}

		export function isReplicaSet(o: any): o is ReplicaSet {
			return o.apiVersion == 'apps/v1beta2' && o.kind == 'ReplicaSet'
		}

		/**
		 * ReplicaSetCondition describes the state of a replica set at a certain point.
		 */
		export interface ReplicaSetCondition {
			/**
			 * Type of replica set condition.
			 */
			type: string

			/**
			 * The last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * ReplicaSetList is a collection of ReplicaSets.
		 */
		export interface ReplicaSetList {
			/**
			 * List of ReplicaSets. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
			 */
			items: apps.v1beta2.ReplicaSet[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta2'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ReplicaSetList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isReplicaSetList(o: any): o is ReplicaSetList {
			return o.apiVersion == 'apps/v1beta2' && o.kind == 'ReplicaSetList'
		}

		/**
		 * ReplicaSetSpec is the specification of a ReplicaSet.
		 */
		export interface ReplicaSetSpec {
			/**
			 * Selector is a label query over pods that should match the replica count. Label keys and
			 * values that must match in order to be controlled by this replica set. It must match the pod
			 * template's labels. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
			 */
			selector: meta.v1.LabelSelector

			/**
			 * Minimum number of seconds for which a newly created pod should be ready without any of its
			 * container crashing, for it to be considered available. Defaults to 0 (pod will be
			 * considered available as soon as it is ready)
			 */
			minReadySeconds?: number

			/**
			 * Replicas is the number of desired replicas. This is a pointer to distinguish between
			 * explicit zero and unspecified. Defaults to 1. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
			 */
			replicas?: number

			/**
			 * Template is the object that describes the pod that will be created if insufficient replicas
			 * are detected. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
			 */
			template?: core.v1.PodTemplateSpec
		}

		/**
		 * Spec to control the desired behavior of daemon set rolling update.
		 */
		export interface RollingUpdateDaemonSet {
			/**
			 * The maximum number of DaemonSet pods that can be unavailable during the update. Value can
			 * be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the
			 * start of the update (ex: 10%). Absolute number is calculated from percentage by rounding
			 * up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at most 30% of
			 * the total number of nodes that should be running the daemon pod (i.e.
			 * status.desiredNumberScheduled) can have their pods stopped for an update at any given time.
			 * The update starts by stopping at most 30% of those DaemonSet pods and then brings up new
			 * DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other
			 * DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are
			 * available at all times during the update.
			 */
			maxUnavailable?: number | string
		}

		/**
		 * Spec to control the desired behavior of rolling update.
		 */
		export interface RollingUpdateDeployment {
			/**
			 * The maximum number of pods that can be scheduled above the desired number of pods. Value
			 * can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not
			 * be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up.
			 * Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up
			 * immediately when the rolling update starts, such that the total number of old and new pods
			 * do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be
			 * scaled up further, ensuring that total number of pods running at any time during the update
			 * is at most 130% of desired pods.
			 */
			maxSurge?: number | string

			/**
			 * The maximum number of pods that can be unavailable during the update. Value can be an
			 * absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
			 * calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults
			 * to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of
			 * desired pods immediately when the rolling update starts. Once new pods are ready, old
			 * ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
			 * that the total number of pods available at all times during the update is at least 70% of
			 * desired pods.
			 */
			maxUnavailable?: number | string
		}

		/**
		 * RollingUpdateStatefulSetStrategy is used to communicate parameter for
		 * RollingUpdateStatefulSetStrategyType.
		 */
		export interface RollingUpdateStatefulSetStrategy {
			/**
			 * Partition indicates the ordinal at which the StatefulSet should be partitioned. Default
			 * value is 0.
			 */
			partition?: number
		}

		/**
		 * Scale represents a scaling request for a resource.
		 */
		export interface Scale {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string

			/**
			 * Standard object metadata; More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * defines the behavior of the scale. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
			 */
			spec?: apps.v1beta2.ScaleSpec
		}

		export function isScale(o: any): o is Scale {
			return o.apiVersion == 'apps/v1beta2' && o.kind == 'Scale'
		}

		/**
		 * ScaleSpec describes the attributes of a scale subresource
		 */
		export interface ScaleSpec {
			/**
			 * desired number of instances for the scaled object.
			 */
			replicas?: number
		}

		/**
		 * StatefulSet represents a set of pods with consistent identities. Identities are defined as:
		 *  - Network: A single stable DNS and hostname.
		 *  - Storage: As many VolumeClaims as requested.
		 * The StatefulSet guarantees that a given network identity will always map to the same storage
		 * identity.
		 *
		 * @deprecated apps/v1beta2/StatefulSet is deprecated by apps/v1/StatefulSet and not supported
		 * by Kubernetes v1.16+ clusters.
		 */
		export interface StatefulSet {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta2'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'StatefulSet'

			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the desired identities of pods in this set.
			 */
			spec?: apps.v1beta2.StatefulSetSpec
		}

		export function isStatefulSet(o: any): o is StatefulSet {
			return o.apiVersion == 'apps/v1beta2' && o.kind == 'StatefulSet'
		}

		/**
		 * StatefulSetCondition describes the state of a statefulset at a certain point.
		 */
		export interface StatefulSetCondition {
			/**
			 * Type of statefulset condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * StatefulSetList is a collection of StatefulSets.
		 */
		export interface StatefulSetList {
			items: apps.v1beta2.StatefulSet[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'apps/v1beta2'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'StatefulSetList'

			metadata?: meta.v1.ListMeta
		}

		export function isStatefulSetList(o: any): o is StatefulSetList {
			return o.apiVersion == 'apps/v1beta2' && o.kind == 'StatefulSetList'
		}

		/**
		 * A StatefulSetSpec is the specification of a StatefulSet.
		 */
		export interface StatefulSetSpec {
			/**
			 * selector is a label query over pods that should match the replica count. It must match the
			 * pod template's labels. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
			 */
			selector: meta.v1.LabelSelector

			/**
			 * serviceName is the name of the service that governs this StatefulSet. This service must
			 * exist before the StatefulSet, and is responsible for the network identity of the set. Pods
			 * get DNS/hostnames that follow the pattern:
			 * pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is
			 * managed by the StatefulSet controller.
			 */
			serviceName: string

			/**
			 * template is the object that describes the pod that will be created if insufficient replicas
			 * are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have
			 * a unique identity from the rest of the StatefulSet.
			 */
			template: core.v1.PodTemplateSpec

			/**
			 * podManagementPolicy controls how pods are created during initial scale up, when replacing
			 * pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are
			 * created in increasing order (pod-0, then pod-1, etc) and the controller will wait until
			 * each pod is ready before continuing. When scaling down, the pods are removed in the
			 * opposite order. The alternative policy is `Parallel` which will create pods in parallel to
			 * match the desired scale without waiting, and on scale down will delete all pods at once.
			 */
			podManagementPolicy?: string

			/**
			 * replicas is the desired number of replicas of the given Template. These are replicas in the
			 * sense that they are instantiations of the same Template, but individual replicas also have
			 * a consistent identity. If unspecified, defaults to 1.
			 */
			replicas?: number

			/**
			 * revisionHistoryLimit is the maximum number of revisions that will be maintained in the
			 * StatefulSet's revision history. The revision history consists of all revisions not
			 * represented by a currently applied StatefulSetSpec version. The default value is 10.
			 */
			revisionHistoryLimit?: number

			/**
			 * updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods
			 * in the StatefulSet when a revision is made to Template.
			 */
			updateStrategy?: apps.v1beta2.StatefulSetUpdateStrategy

			/**
			 * volumeClaimTemplates is a list of claims that pods are allowed to reference. The
			 * StatefulSet controller is responsible for mapping network identities to claims in a way
			 * that maintains the identity of a pod. Every claim in this list must have at least one
			 * matching (by name) volumeMount in one container in the template. A claim in this list takes
			 * precedence over any volumes in the template, with the same name.
			 */
			volumeClaimTemplates?: core.v1.PersistentVolumeClaim[]
		}

		/**
		 * StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to
		 * perform updates. It includes any additional parameters necessary to perform the update for
		 * the indicated strategy.
		 */
		export interface StatefulSetUpdateStrategy {
			/**
			 * RollingUpdate is used to communicate parameters when Type is
			 * RollingUpdateStatefulSetStrategyType.
			 */
			rollingUpdate?: apps.v1beta2.RollingUpdateStatefulSetStrategy

			/**
			 * Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
			 */
			type?: string
		}
	}
}

export namespace auditregistration {
	export namespace v1alpha1 {
		/**
		 * AuditSink represents a cluster level audit sink
		 */
		export interface AuditSink {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'auditregistration.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'AuditSink'

			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the audit configuration spec
			 */
			spec?: auditregistration.v1alpha1.AuditSinkSpec
		}

		export function isAuditSink(o: any): o is AuditSink {
			return (
				o.apiVersion == 'auditregistration.k8s.io/v1alpha1' &&
				o.kind == 'AuditSink'
			)
		}

		/**
		 * AuditSinkList is a list of AuditSink items.
		 */
		export interface AuditSinkList {
			/**
			 * List of audit configurations.
			 */
			items: auditregistration.v1alpha1.AuditSink[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'auditregistration.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'AuditSinkList'

			metadata?: meta.v1.ListMeta
		}

		export function isAuditSinkList(o: any): o is AuditSinkList {
			return (
				o.apiVersion == 'auditregistration.k8s.io/v1alpha1' &&
				o.kind == 'AuditSinkList'
			)
		}

		/**
		 * AuditSinkSpec holds the spec for the audit sink
		 */
		export interface AuditSinkSpec {
			/**
			 * Policy defines the policy for selecting which events should be sent to the webhook required
			 */
			policy: auditregistration.v1alpha1.Policy

			/**
			 * Webhook to send events required
			 */
			webhook: auditregistration.v1alpha1.Webhook
		}

		/**
		 * Policy defines the configuration of how audit events are logged
		 */
		export interface Policy {
			/**
			 * The Level that all requests are recorded at. available options: None, Metadata, Request,
			 * RequestResponse required
			 */
			level: string

			/**
			 * Stages is a list of stages for which events are created.
			 */
			stages?: string[]
		}

		/**
		 * ServiceReference holds a reference to Service.legacy.k8s.io
		 */
		export interface ServiceReference {
			/**
			 * `name` is the name of the service. Required
			 */
			name: string

			/**
			 * `namespace` is the namespace of the service. Required
			 */
			namespace: string

			/**
			 * `path` is an optional URL path which will be sent in any request to this service.
			 */
			path?: string

			/**
			 * If specified, the port on the service that hosting webhook. Default to 443 for backward
			 * compatibility. `port` should be a valid port number (1-65535, inclusive).
			 */
			port?: number
		}

		/**
		 * Webhook holds the configuration of the webhook
		 */
		export interface Webhook {
			/**
			 * ClientConfig holds the connection parameters for the webhook required
			 */
			clientConfig: auditregistration.v1alpha1.WebhookClientConfig

			/**
			 * Throttle holds the options for throttling the webhook
			 */
			throttle?: auditregistration.v1alpha1.WebhookThrottleConfig
		}

		/**
		 * WebhookClientConfig contains the information to make a connection with the webhook
		 */
		export interface WebhookClientConfig {
			/**
			 * `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server
			 * certificate. If unspecified, system trust roots on the apiserver are used.
			 */
			caBundle?: string

			/**
			 * `service` is a reference to the service for this webhook. Either `service` or `url` must be
			 * specified.
			 *
			 * If the webhook is running within the cluster, then you should use `service`.
			 */
			service?: auditregistration.v1alpha1.ServiceReference

			/**
			 * `url` gives the location of the webhook, in standard URL form (`scheme://host:port/path`).
			 * Exactly one of `url` or `service` must be specified.
			 *
			 * The `host` should not refer to a service running in the cluster; use the `service` field
			 * instead. The host might be resolved via external DNS in some apiservers (e.g.,
			 * `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation).
			 * `host` may also be an IP address.
			 *
			 * Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take
			 * great care to run this webhook on all hosts which run an apiserver which might need to make
			 * calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn
			 * up in a new cluster.
			 *
			 * The scheme must be "https"; the URL must begin with "https://".
			 *
			 * A path is optional, and if present may be any string permissible in a URL. You may use the
			 * path to pass an arbitrary string to the webhook, for example, a cluster identifier.
			 *
			 * Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments
			 * ("#...") and query parameters ("?...") are not allowed, either.
			 */
			url?: string
		}

		/**
		 * WebhookThrottleConfig holds the configuration for throttling events
		 */
		export interface WebhookThrottleConfig {
			/**
			 * ThrottleBurst is the maximum number of events sent at the same moment default 15 QPS
			 */
			burst?: number

			/**
			 * ThrottleQPS maximum number of batches per second default 10 QPS
			 */
			qps?: number
		}
	}
}

export namespace authentication {
	export namespace v1 {
		/**
		 * BoundObjectReference is a reference to an object that a token is bound to.
		 */
		export interface BoundObjectReference {
			/**
			 * API version of the referent.
			 */
			apiVersion?: string

			/**
			 * Kind of the referent. Valid kinds are 'Pod' and 'Secret'.
			 */
			kind?: string

			/**
			 * Name of the referent.
			 */
			name?: string

			/**
			 * UID of the referent.
			 */
			uid?: string
		}

		export function isBoundObjectReference(o: any): o is BoundObjectReference {
			return (
				o.apiVersion == 'authentication/v1' && o.kind == 'BoundObjectReference'
			)
		}

		/**
		 * TokenRequest requests a token for a given service account.
		 */
		export interface TokenRequest {
			spec: authentication.v1.TokenRequestSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'authentication.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'TokenRequest'

			metadata?: meta.v1.ObjectMeta
		}

		export function isTokenRequest(o: any): o is TokenRequest {
			return (
				o.apiVersion == 'authentication.k8s.io/v1' && o.kind == 'TokenRequest'
			)
		}

		/**
		 * TokenRequestSpec contains client provided parameters of a token request.
		 */
		export interface TokenRequestSpec {
			/**
			 * Audiences are the intendend audiences of the token. A recipient of a token must identitfy
			 * themself with an identifier in the list of audiences of the token, and otherwise should
			 * reject the token. A token issued for multiple audiences may be used to authenticate against
			 * any of the audiences listed but implies a high degree of trust between the target
			 * audiences.
			 */
			audiences: string[]

			/**
			 * BoundObjectRef is a reference to an object that the token will be bound to. The token will
			 * only be valid for as long as the bound object exists. NOTE: The API server's TokenReview
			 * endpoint will validate the BoundObjectRef, but other audiences may not. Keep
			 * ExpirationSeconds small if you want prompt revocation.
			 */
			boundObjectRef?: authentication.v1.BoundObjectReference

			/**
			 * ExpirationSeconds is the requested duration of validity of the request. The token issuer
			 * may return a token with a different validity duration so a client needs to check the
			 * 'expiration' field in a response.
			 */
			expirationSeconds?: number
		}

		/**
		 * TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may
		 * be cached by the webhook token authenticator plugin in the kube-apiserver.
		 */
		export interface TokenReview {
			/**
			 * Spec holds information about the request being evaluated
			 */
			spec: authentication.v1.TokenReviewSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'authentication.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'TokenReview'

			metadata?: meta.v1.ObjectMeta
		}

		export function isTokenReview(o: any): o is TokenReview {
			return (
				o.apiVersion == 'authentication.k8s.io/v1' && o.kind == 'TokenReview'
			)
		}

		/**
		 * TokenReviewSpec is a description of the token authentication request.
		 */
		export interface TokenReviewSpec {
			/**
			 * Audiences is a list of the identifiers that the resource server presented with the token
			 * identifies as. Audience-aware token authenticators will verify that the token was intended
			 * for at least one of the audiences in this list. If no audiences are provided, the audience
			 * will default to the audience of the Kubernetes apiserver.
			 */
			audiences?: string[]

			/**
			 * Token is the opaque bearer token.
			 */
			token?: string
		}

		/**
		 * UserInfo holds the information about the user needed to implement the user.Info interface.
		 */
		export interface UserInfo {
			/**
			 * Any additional information provided by the authenticator.
			 */
			extra?: object

			/**
			 * The names of groups this user is a part of.
			 */
			groups?: string[]

			/**
			 * A unique value that identifies this user across time. If this user is deleted and another
			 * user by the same name is added, they will have different UIDs.
			 */
			uid?: string

			/**
			 * The name that uniquely identifies this user among all active users.
			 */
			username?: string
		}
	}
	export namespace v1beta1 {
		/**
		 * TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may
		 * be cached by the webhook token authenticator plugin in the kube-apiserver.
		 */
		export interface TokenReview {
			/**
			 * Spec holds information about the request being evaluated
			 */
			spec: authentication.v1beta1.TokenReviewSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'authentication.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'TokenReview'

			metadata?: meta.v1.ObjectMeta
		}

		export function isTokenReview(o: any): o is TokenReview {
			return (
				o.apiVersion == 'authentication.k8s.io/v1beta1' &&
				o.kind == 'TokenReview'
			)
		}

		/**
		 * TokenReviewSpec is a description of the token authentication request.
		 */
		export interface TokenReviewSpec {
			/**
			 * Audiences is a list of the identifiers that the resource server presented with the token
			 * identifies as. Audience-aware token authenticators will verify that the token was intended
			 * for at least one of the audiences in this list. If no audiences are provided, the audience
			 * will default to the audience of the Kubernetes apiserver.
			 */
			audiences?: string[]

			/**
			 * Token is the opaque bearer token.
			 */
			token?: string
		}

		/**
		 * UserInfo holds the information about the user needed to implement the user.Info interface.
		 */
		export interface UserInfo {
			/**
			 * Any additional information provided by the authenticator.
			 */
			extra?: object

			/**
			 * The names of groups this user is a part of.
			 */
			groups?: string[]

			/**
			 * A unique value that identifies this user across time. If this user is deleted and another
			 * user by the same name is added, they will have different UIDs.
			 */
			uid?: string

			/**
			 * The name that uniquely identifies this user among all active users.
			 */
			username?: string
		}
	}
}

export namespace authorization {
	export namespace v1 {
		/**
		 * LocalSubjectAccessReview checks whether or not a user or group can perform an action in a
		 * given namespace. Having a namespace scoped resource makes it much easier to grant namespace
		 * scoped policy that includes permissions checking.
		 */
		export interface LocalSubjectAccessReview {
			/**
			 * Spec holds information about the request being evaluated.  spec.namespace must be equal to
			 * the namespace you made the request against.  If empty, it is defaulted.
			 */
			spec: authorization.v1.SubjectAccessReviewSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'LocalSubjectAccessReview'

			metadata?: meta.v1.ObjectMeta
		}

		export function isLocalSubjectAccessReview(
			o: any
		): o is LocalSubjectAccessReview {
			return (
				o.apiVersion == 'authorization.k8s.io/v1' &&
				o.kind == 'LocalSubjectAccessReview'
			)
		}

		/**
		 * NonResourceAttributes includes the authorization attributes available for non-resource
		 * requests to the Authorizer interface
		 */
		export interface NonResourceAttributes {
			/**
			 * Path is the URL path of the request
			 */
			path?: string

			/**
			 * Verb is the standard HTTP verb
			 */
			verb?: string
		}

		/**
		 * NonResourceRule holds information that describes a rule for the non-resource
		 */
		export interface NonResourceRule {
			/**
			 * Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete, patch,
			 * head, options.  "*" means all.
			 */
			verbs: string[]

			/**
			 * NonResourceURLs is a set of partial urls that a user should have access to.  *s are
			 * allowed, but only as the full, final step in the path.  "*" means all.
			 */
			nonResourceURLs?: string[]
		}

		/**
		 * ResourceAttributes includes the authorization attributes available for resource requests to
		 * the Authorizer interface
		 */
		export interface ResourceAttributes {
			/**
			 * Group is the API Group of the Resource.  "*" means all.
			 */
			group?: string

			/**
			 * Name is the name of the resource being requested for a "get" or deleted for a "delete". ""
			 * (empty) means all.
			 */
			name?: string

			/**
			 * Namespace is the namespace of the action being requested.  Currently, there is no
			 * distinction between no namespace and all namespaces "" (empty) is defaulted for
			 * LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty) means
			 * "all" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview
			 */
			namespace?: string

			/**
			 * Resource is one of the existing resource types.  "*" means all.
			 */
			resource?: string

			/**
			 * Subresource is one of the existing resource types.  "" means none.
			 */
			subresource?: string

			/**
			 * Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete,
			 * proxy.  "*" means all.
			 */
			verb?: string

			/**
			 * Version is the API Version of the Resource.  "*" means all.
			 */
			version?: string
		}

		/**
		 * ResourceRule is the list of actions the subject is allowed to perform on resources. The list
		 * ordering isn't significant, may contain duplicates, and possibly be incomplete.
		 */
		export interface ResourceRule {
			/**
			 * Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update,
			 * delete, proxy.  "*" means all.
			 */
			verbs: string[]

			/**
			 * APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups
			 * are specified, any action requested against one of the enumerated resources in any API
			 * group will be allowed.  "*" means all.
			 */
			apiGroups?: string[]

			/**
			 * ResourceNames is an optional white list of names that the rule applies to.  An empty set
			 * means that everything is allowed.  "*" means all.
			 */
			resourceNames?: string[]

			/**
			 * Resources is a list of resources this rule applies to.  "*" means all in the specified
			 * apiGroups.
			 *  "*&#8205;/foo" represents the subresource 'foo' for all resources in the specified
			 * apiGroups.
			 */
			resources?: string[]
		}

		/**
		 * SelfSubjectAccessReview checks whether or the current user can perform an action.  Not
		 * filling in a spec.namespace means "in all namespaces".  Self is a special case, because users
		 * should always be able to check whether they can perform an action
		 */
		export interface SelfSubjectAccessReview {
			/**
			 * Spec holds information about the request being evaluated.  user and groups must be empty
			 */
			spec: authorization.v1.SelfSubjectAccessReviewSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'SelfSubjectAccessReview'

			metadata?: meta.v1.ObjectMeta
		}

		export function isSelfSubjectAccessReview(
			o: any
		): o is SelfSubjectAccessReview {
			return (
				o.apiVersion == 'authorization.k8s.io/v1' &&
				o.kind == 'SelfSubjectAccessReview'
			)
		}

		/**
		 * SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of
		 * ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
		 */
		export interface SelfSubjectAccessReviewSpec {
			/**
			 * NonResourceAttributes describes information for a non-resource access request
			 */
			nonResourceAttributes?: authorization.v1.NonResourceAttributes

			/**
			 * ResourceAuthorizationAttributes describes information for a resource access request
			 */
			resourceAttributes?: authorization.v1.ResourceAttributes
		}

		/**
		 * SelfSubjectRulesReview enumerates the set of actions the current user can perform within a
		 * namespace. The returned list of actions may be incomplete depending on the server's
		 * authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview
		 * should be used by UIs to show/hide actions, or to quickly let an end user reason about their
		 * permissions. It should NOT Be used by external systems to drive authorization decisions as
		 * this raises confused deputy, cache lifetime/revocation, and correctness concerns.
		 * SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization
		 * decisions to the API server.
		 */
		export interface SelfSubjectRulesReview {
			/**
			 * Spec holds information about the request being evaluated.
			 */
			spec: authorization.v1.SelfSubjectRulesReviewSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'SelfSubjectRulesReview'

			metadata?: meta.v1.ObjectMeta
		}

		export function isSelfSubjectRulesReview(
			o: any
		): o is SelfSubjectRulesReview {
			return (
				o.apiVersion == 'authorization.k8s.io/v1' &&
				o.kind == 'SelfSubjectRulesReview'
			)
		}

		/**
		 *
		 */
		export interface SelfSubjectRulesReviewSpec {
			/**
			 * Namespace to evaluate rules for. Required.
			 */
			namespace?: string
		}

		/**
		 * SubjectAccessReview checks whether or not a user or group can perform an action.
		 */
		export interface SubjectAccessReview {
			/**
			 * Spec holds information about the request being evaluated
			 */
			spec: authorization.v1.SubjectAccessReviewSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'SubjectAccessReview'

			metadata?: meta.v1.ObjectMeta
		}

		export function isSubjectAccessReview(o: any): o is SubjectAccessReview {
			return (
				o.apiVersion == 'authorization.k8s.io/v1' &&
				o.kind == 'SubjectAccessReview'
			)
		}

		/**
		 * SubjectAccessReviewSpec is a description of the access request.  Exactly one of
		 * ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
		 */
		export interface SubjectAccessReviewSpec {
			/**
			 * Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that is
			 * input to the authorizer it needs a reflection here.
			 */
			extra?: object

			/**
			 * Groups is the groups you're testing for.
			 */
			groups?: string[]

			/**
			 * NonResourceAttributes describes information for a non-resource access request
			 */
			nonResourceAttributes?: authorization.v1.NonResourceAttributes

			/**
			 * ResourceAuthorizationAttributes describes information for a resource access request
			 */
			resourceAttributes?: authorization.v1.ResourceAttributes

			/**
			 * UID information about the requesting user.
			 */
			uid?: string

			/**
			 * User is the user you're testing for. If you specify "User" but not "Groups", then is it
			 * interpreted as "What if User were not a member of any groups
			 */
			user?: string
		}
	}
	export namespace v1beta1 {
		/**
		 * LocalSubjectAccessReview checks whether or not a user or group can perform an action in a
		 * given namespace. Having a namespace scoped resource makes it much easier to grant namespace
		 * scoped policy that includes permissions checking.
		 */
		export interface LocalSubjectAccessReview {
			/**
			 * Spec holds information about the request being evaluated.  spec.namespace must be equal to
			 * the namespace you made the request against.  If empty, it is defaulted.
			 */
			spec: authorization.v1beta1.SubjectAccessReviewSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'LocalSubjectAccessReview'

			metadata?: meta.v1.ObjectMeta
		}

		export function isLocalSubjectAccessReview(
			o: any
		): o is LocalSubjectAccessReview {
			return (
				o.apiVersion == 'authorization.k8s.io/v1beta1' &&
				o.kind == 'LocalSubjectAccessReview'
			)
		}

		/**
		 * NonResourceAttributes includes the authorization attributes available for non-resource
		 * requests to the Authorizer interface
		 */
		export interface NonResourceAttributes {
			/**
			 * Path is the URL path of the request
			 */
			path?: string

			/**
			 * Verb is the standard HTTP verb
			 */
			verb?: string
		}

		/**
		 * NonResourceRule holds information that describes a rule for the non-resource
		 */
		export interface NonResourceRule {
			/**
			 * Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete, patch,
			 * head, options.  "*" means all.
			 */
			verbs: string[]

			/**
			 * NonResourceURLs is a set of partial urls that a user should have access to.  *s are
			 * allowed, but only as the full, final step in the path.  "*" means all.
			 */
			nonResourceURLs?: string[]
		}

		/**
		 * ResourceAttributes includes the authorization attributes available for resource requests to
		 * the Authorizer interface
		 */
		export interface ResourceAttributes {
			/**
			 * Group is the API Group of the Resource.  "*" means all.
			 */
			group?: string

			/**
			 * Name is the name of the resource being requested for a "get" or deleted for a "delete". ""
			 * (empty) means all.
			 */
			name?: string

			/**
			 * Namespace is the namespace of the action being requested.  Currently, there is no
			 * distinction between no namespace and all namespaces "" (empty) is defaulted for
			 * LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty) means
			 * "all" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview
			 */
			namespace?: string

			/**
			 * Resource is one of the existing resource types.  "*" means all.
			 */
			resource?: string

			/**
			 * Subresource is one of the existing resource types.  "" means none.
			 */
			subresource?: string

			/**
			 * Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete,
			 * proxy.  "*" means all.
			 */
			verb?: string

			/**
			 * Version is the API Version of the Resource.  "*" means all.
			 */
			version?: string
		}

		/**
		 * ResourceRule is the list of actions the subject is allowed to perform on resources. The list
		 * ordering isn't significant, may contain duplicates, and possibly be incomplete.
		 */
		export interface ResourceRule {
			/**
			 * Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update,
			 * delete, proxy.  "*" means all.
			 */
			verbs: string[]

			/**
			 * APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups
			 * are specified, any action requested against one of the enumerated resources in any API
			 * group will be allowed.  "*" means all.
			 */
			apiGroups?: string[]

			/**
			 * ResourceNames is an optional white list of names that the rule applies to.  An empty set
			 * means that everything is allowed.  "*" means all.
			 */
			resourceNames?: string[]

			/**
			 * Resources is a list of resources this rule applies to.  "*" means all in the specified
			 * apiGroups.
			 *  "*&#8205;/foo" represents the subresource 'foo' for all resources in the specified
			 * apiGroups.
			 */
			resources?: string[]
		}

		/**
		 * SelfSubjectAccessReview checks whether or the current user can perform an action.  Not
		 * filling in a spec.namespace means "in all namespaces".  Self is a special case, because users
		 * should always be able to check whether they can perform an action
		 */
		export interface SelfSubjectAccessReview {
			/**
			 * Spec holds information about the request being evaluated.  user and groups must be empty
			 */
			spec: authorization.v1beta1.SelfSubjectAccessReviewSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'SelfSubjectAccessReview'

			metadata?: meta.v1.ObjectMeta
		}

		export function isSelfSubjectAccessReview(
			o: any
		): o is SelfSubjectAccessReview {
			return (
				o.apiVersion == 'authorization.k8s.io/v1beta1' &&
				o.kind == 'SelfSubjectAccessReview'
			)
		}

		/**
		 * SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of
		 * ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
		 */
		export interface SelfSubjectAccessReviewSpec {
			/**
			 * NonResourceAttributes describes information for a non-resource access request
			 */
			nonResourceAttributes?: authorization.v1beta1.NonResourceAttributes

			/**
			 * ResourceAuthorizationAttributes describes information for a resource access request
			 */
			resourceAttributes?: authorization.v1beta1.ResourceAttributes
		}

		/**
		 * SelfSubjectRulesReview enumerates the set of actions the current user can perform within a
		 * namespace. The returned list of actions may be incomplete depending on the server's
		 * authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview
		 * should be used by UIs to show/hide actions, or to quickly let an end user reason about their
		 * permissions. It should NOT Be used by external systems to drive authorization decisions as
		 * this raises confused deputy, cache lifetime/revocation, and correctness concerns.
		 * SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization
		 * decisions to the API server.
		 */
		export interface SelfSubjectRulesReview {
			/**
			 * Spec holds information about the request being evaluated.
			 */
			spec: authorization.v1beta1.SelfSubjectRulesReviewSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'SelfSubjectRulesReview'

			metadata?: meta.v1.ObjectMeta
		}

		export function isSelfSubjectRulesReview(
			o: any
		): o is SelfSubjectRulesReview {
			return (
				o.apiVersion == 'authorization.k8s.io/v1beta1' &&
				o.kind == 'SelfSubjectRulesReview'
			)
		}

		/**
		 *
		 */
		export interface SelfSubjectRulesReviewSpec {
			/**
			 * Namespace to evaluate rules for. Required.
			 */
			namespace?: string
		}

		/**
		 * SubjectAccessReview checks whether or not a user or group can perform an action.
		 */
		export interface SubjectAccessReview {
			/**
			 * Spec holds information about the request being evaluated
			 */
			spec: authorization.v1beta1.SubjectAccessReviewSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'SubjectAccessReview'

			metadata?: meta.v1.ObjectMeta
		}

		export function isSubjectAccessReview(o: any): o is SubjectAccessReview {
			return (
				o.apiVersion == 'authorization.k8s.io/v1beta1' &&
				o.kind == 'SubjectAccessReview'
			)
		}

		/**
		 * SubjectAccessReviewSpec is a description of the access request.  Exactly one of
		 * ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
		 */
		export interface SubjectAccessReviewSpec {
			/**
			 * Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that is
			 * input to the authorizer it needs a reflection here.
			 */
			extra?: object

			/**
			 * Groups is the groups you're testing for.
			 */
			group?: string[]

			/**
			 * NonResourceAttributes describes information for a non-resource access request
			 */
			nonResourceAttributes?: authorization.v1beta1.NonResourceAttributes

			/**
			 * ResourceAuthorizationAttributes describes information for a resource access request
			 */
			resourceAttributes?: authorization.v1beta1.ResourceAttributes

			/**
			 * UID information about the requesting user.
			 */
			uid?: string

			/**
			 * User is the user you're testing for. If you specify "User" but not "Group", then is it
			 * interpreted as "What if User were not a member of any groups
			 */
			user?: string
		}
	}
}

export namespace autoscaling {
	export namespace v1 {
		/**
		 * CrossVersionObjectReference contains enough information to let you identify the referred
		 * resource.
		 */
		export interface CrossVersionObjectReference {
			/**
			 * Kind of the referent; More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
			 */
			kind: string

			/**
			 * Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
			 */
			name: string

			/**
			 * API version of the referent
			 */
			apiVersion?: string
		}

		export function isCrossVersionObjectReference(
			o: any
		): o is CrossVersionObjectReference {
			return (
				o.apiVersion == 'autoscaling/v1' &&
				o.kind == 'CrossVersionObjectReference'
			)
		}

		/**
		 * configuration of a horizontal pod autoscaler.
		 */
		export interface HorizontalPodAutoscaler {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'autoscaling/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'HorizontalPodAutoscaler'

			/**
			 * Standard object metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * behaviour of autoscaler. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
			 */
			spec?: autoscaling.v1.HorizontalPodAutoscalerSpec
		}

		export function isHorizontalPodAutoscaler(
			o: any
		): o is HorizontalPodAutoscaler {
			return (
				o.apiVersion == 'autoscaling/v1' && o.kind == 'HorizontalPodAutoscaler'
			)
		}

		/**
		 * list of horizontal pod autoscaler objects.
		 */
		export interface HorizontalPodAutoscalerList {
			/**
			 * list of horizontal pod autoscaler objects.
			 */
			items: autoscaling.v1.HorizontalPodAutoscaler[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'autoscaling/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'HorizontalPodAutoscalerList'

			/**
			 * Standard list metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isHorizontalPodAutoscalerList(
			o: any
		): o is HorizontalPodAutoscalerList {
			return (
				o.apiVersion == 'autoscaling/v1' &&
				o.kind == 'HorizontalPodAutoscalerList'
			)
		}

		/**
		 * specification of a horizontal pod autoscaler.
		 */
		export interface HorizontalPodAutoscalerSpec {
			/**
			 * upper limit for the number of pods that can be set by the autoscaler; cannot be smaller
			 * than MinReplicas.
			 */
			maxReplicas: number

			/**
			 * reference to scaled resource; horizontal pod autoscaler will learn the current resource
			 * consumption and will set the desired number of pods by using its Scale subresource.
			 */
			scaleTargetRef: autoscaling.v1.CrossVersionObjectReference

			/**
			 * minReplicas is the lower limit for the number of replicas to which the autoscaler can scale
			 * down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature gate
			 * HPAScaleToZero is enabled and at least one Object or External metric is configured.
			 * Scaling is active as long as at least one metric value is available.
			 */
			minReplicas?: number

			/**
			 * target average CPU utilization (represented as a percentage of requested CPU) over all the
			 * pods; if not specified the default autoscaling policy will be used.
			 */
			targetCPUUtilizationPercentage?: number
		}

		/**
		 * Scale represents a scaling request for a resource.
		 */
		export interface Scale {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string

			/**
			 * Standard object metadata; More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * defines the behavior of the scale. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
			 */
			spec?: autoscaling.v1.ScaleSpec
		}

		export function isScale(o: any): o is Scale {
			return o.apiVersion == 'autoscaling/v1' && o.kind == 'Scale'
		}

		/**
		 * ScaleSpec describes the attributes of a scale subresource.
		 */
		export interface ScaleSpec {
			/**
			 * desired number of instances for the scaled object.
			 */
			replicas?: number
		}
	}
	export namespace v2beta1 {
		/**
		 * CrossVersionObjectReference contains enough information to let you identify the referred
		 * resource.
		 */
		export interface CrossVersionObjectReference {
			/**
			 * Kind of the referent; More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
			 */
			kind: string

			/**
			 * Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
			 */
			name: string

			/**
			 * API version of the referent
			 */
			apiVersion?: string
		}

		export function isCrossVersionObjectReference(
			o: any
		): o is CrossVersionObjectReference {
			return (
				o.apiVersion == 'autoscaling/v2beta1' &&
				o.kind == 'CrossVersionObjectReference'
			)
		}

		/**
		 * ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes
		 * object (for example length of queue in cloud messaging service, or QPS from loadbalancer
		 * running outside of cluster). Exactly one "target" type should be set.
		 */
		export interface ExternalMetricSource {
			/**
			 * metricName is the name of the metric in question.
			 */
			metricName: string

			/**
			 * metricSelector is used to identify a specific time series within a given metric.
			 */
			metricSelector?: meta.v1.LabelSelector

			/**
			 * targetAverageValue is the target per-pod value of global metric (as a quantity). Mutually
			 * exclusive with TargetValue.
			 */
			targetAverageValue?: string

			/**
			 * targetValue is the target value of the metric (as a quantity). Mutually exclusive with
			 * TargetAverageValue.
			 */
			targetValue?: string
		}

		/**
		 * HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which
		 * automatically manages the replica count of any resource implementing the scale subresource
		 * based on the metrics specified.
		 */
		export interface HorizontalPodAutoscaler {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'autoscaling/v2beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'HorizontalPodAutoscaler'

			/**
			 * metadata is the standard object metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * spec is the specification for the behaviour of the autoscaler. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
			 */
			spec?: autoscaling.v2beta1.HorizontalPodAutoscalerSpec
		}

		export function isHorizontalPodAutoscaler(
			o: any
		): o is HorizontalPodAutoscaler {
			return (
				o.apiVersion == 'autoscaling/v2beta1' &&
				o.kind == 'HorizontalPodAutoscaler'
			)
		}

		/**
		 * HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a
		 * certain point.
		 */
		export interface HorizontalPodAutoscalerCondition {
			/**
			 * type describes the current condition
			 */
			type: string

			/**
			 * lastTransitionTime is the last time the condition transitioned from one status to another
			 */
			lastTransitionTime?: string

			/**
			 * message is a human-readable explanation containing details about the transition
			 */
			message?: string

			/**
			 * reason is the reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * HorizontalPodAutoscaler is a list of horizontal pod autoscaler objects.
		 */
		export interface HorizontalPodAutoscalerList {
			/**
			 * items is the list of horizontal pod autoscaler objects.
			 */
			items: autoscaling.v2beta1.HorizontalPodAutoscaler[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'autoscaling/v2beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'HorizontalPodAutoscalerList'

			/**
			 * metadata is the standard list metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isHorizontalPodAutoscalerList(
			o: any
		): o is HorizontalPodAutoscalerList {
			return (
				o.apiVersion == 'autoscaling/v2beta1' &&
				o.kind == 'HorizontalPodAutoscalerList'
			)
		}

		/**
		 * HorizontalPodAutoscalerSpec describes the desired functionality of the
		 * HorizontalPodAutoscaler.
		 */
		export interface HorizontalPodAutoscalerSpec {
			/**
			 * maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale
			 * up. It cannot be less that minReplicas.
			 */
			maxReplicas: number

			/**
			 * scaleTargetRef points to the target resource to scale, and is used to the pods for which
			 * metrics should be collected, as well as to actually change the replica count.
			 */
			scaleTargetRef: autoscaling.v2beta1.CrossVersionObjectReference

			/**
			 * metrics contains the specifications for which to use to calculate the desired replica count
			 * (the maximum replica count across all metrics will be used).  The desired replica count is
			 * calculated multiplying the ratio between the target value and the current value by the
			 * current number of pods.  Ergo, metrics used must decrease as the pod count is increased,
			 * and vice-versa.  See the individual metric source types for more information about how each
			 * type of metric must respond.
			 */
			metrics?: autoscaling.v2beta1.MetricSpec[]

			/**
			 * minReplicas is the lower limit for the number of replicas to which the autoscaler can scale
			 * down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature gate
			 * HPAScaleToZero is enabled and at least one Object or External metric is configured.
			 * Scaling is active as long as at least one metric value is available.
			 */
			minReplicas?: number
		}

		/**
		 * MetricSpec specifies how to scale based on a single metric (only `type` and one other
		 * matching field should be set at once).
		 */
		export interface MetricSpec {
			/**
			 * type is the type of metric source.  It should be one of "Object", "Pods" or "Resource",
			 * each mapping to a matching field in the object.
			 */
			type: string

			/**
			 * external refers to a global metric that is not associated with any Kubernetes object. It
			 * allows autoscaling based on information coming from components running outside of cluster
			 * (for example length of queue in cloud messaging service, or QPS from loadbalancer running
			 * outside of cluster).
			 */
			external?: autoscaling.v2beta1.ExternalMetricSource

			/**
			 * object refers to a metric describing a single kubernetes object (for example,
			 * hits-per-second on an Ingress object).
			 */
			object?: autoscaling.v2beta1.ObjectMetricSource

			/**
			 * pods refers to a metric describing each pod in the current scale target (for example,
			 * transactions-processed-per-second).  The values will be averaged together before being
			 * compared to the target value.
			 */
			pods?: autoscaling.v2beta1.PodsMetricSource

			/**
			 * resource refers to a resource metric (such as those specified in requests and limits) known
			 * to Kubernetes describing each pod in the current scale target (e.g. CPU or memory). Such
			 * metrics are built in to Kubernetes, and have special scaling options on top of those
			 * available to normal per-pod metrics using the "pods" source.
			 */
			resource?: autoscaling.v2beta1.ResourceMetricSource
		}

		/**
		 * ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for
		 * example, hits-per-second on an Ingress object).
		 */
		export interface ObjectMetricSource {
			/**
			 * metricName is the name of the metric in question.
			 */
			metricName: string

			/**
			 * target is the described Kubernetes object.
			 */
			target: autoscaling.v2beta1.CrossVersionObjectReference

			/**
			 * targetValue is the target value of the metric (as a quantity).
			 */
			targetValue: string

			/**
			 * averageValue is the target value of the average of the metric across all relevant pods (as
			 * a quantity)
			 */
			averageValue?: string

			/**
			 * selector is the string-encoded form of a standard kubernetes label selector for the given
			 * metric When set, it is passed as an additional parameter to the metrics server for more
			 * specific metrics scoping When unset, just the metricName will be used to gather metrics.
			 */
			selector?: meta.v1.LabelSelector
		}

		/**
		 * PodsMetricSource indicates how to scale on a metric describing each pod in the current scale
		 * target (for example, transactions-processed-per-second). The values will be averaged together
		 * before being compared to the target value.
		 */
		export interface PodsMetricSource {
			/**
			 * metricName is the name of the metric in question
			 */
			metricName: string

			/**
			 * targetAverageValue is the target value of the average of the metric across all relevant
			 * pods (as a quantity)
			 */
			targetAverageValue: string

			/**
			 * selector is the string-encoded form of a standard kubernetes label selector for the given
			 * metric When set, it is passed as an additional parameter to the metrics server for more
			 * specific metrics scoping When unset, just the metricName will be used to gather metrics.
			 */
			selector?: meta.v1.LabelSelector
		}

		/**
		 * ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as
		 * specified in requests and limits, describing each pod in the current scale target (e.g. CPU
		 * or memory).  The values will be averaged together before being compared to the target.  Such
		 * metrics are built in to Kubernetes, and have special scaling options on top of those
		 * available to normal per-pod metrics using the "pods" source.  Only one "target" type should
		 * be set.
		 */
		export interface ResourceMetricSource {
			/**
			 * name is the name of the resource in question.
			 */
			name: string

			/**
			 * targetAverageUtilization is the target value of the average of the resource metric across
			 * all relevant pods, represented as a percentage of the requested value of the resource for
			 * the pods.
			 */
			targetAverageUtilization?: number

			/**
			 * targetAverageValue is the target value of the average of the resource metric across all
			 * relevant pods, as a raw value (instead of as a percentage of the request), similar to the
			 * "pods" metric source type.
			 */
			targetAverageValue?: string
		}
	}
	export namespace v2beta2 {
		/**
		 * CrossVersionObjectReference contains enough information to let you identify the referred
		 * resource.
		 */
		export interface CrossVersionObjectReference {
			/**
			 * Kind of the referent; More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
			 */
			kind: string

			/**
			 * Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
			 */
			name: string

			/**
			 * API version of the referent
			 */
			apiVersion?: string
		}

		export function isCrossVersionObjectReference(
			o: any
		): o is CrossVersionObjectReference {
			return (
				o.apiVersion == 'autoscaling/v2beta2' &&
				o.kind == 'CrossVersionObjectReference'
			)
		}

		/**
		 * ExternalMetricSource indicates how to scale on a metric not associated with any Kubernetes
		 * object (for example length of queue in cloud messaging service, or QPS from loadbalancer
		 * running outside of cluster).
		 */
		export interface ExternalMetricSource {
			/**
			 * metric identifies the target metric by name and selector
			 */
			metric: autoscaling.v2beta2.MetricIdentifier

			/**
			 * target specifies the target value for the given metric
			 */
			target: autoscaling.v2beta2.MetricTarget
		}

		/**
		 * HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which
		 * automatically manages the replica count of any resource implementing the scale subresource
		 * based on the metrics specified.
		 */
		export interface HorizontalPodAutoscaler {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'autoscaling/v2beta2'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'HorizontalPodAutoscaler'

			/**
			 * metadata is the standard object metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * spec is the specification for the behaviour of the autoscaler. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
			 */
			spec?: autoscaling.v2beta2.HorizontalPodAutoscalerSpec
		}

		export function isHorizontalPodAutoscaler(
			o: any
		): o is HorizontalPodAutoscaler {
			return (
				o.apiVersion == 'autoscaling/v2beta2' &&
				o.kind == 'HorizontalPodAutoscaler'
			)
		}

		/**
		 * HorizontalPodAutoscalerCondition describes the state of a HorizontalPodAutoscaler at a
		 * certain point.
		 */
		export interface HorizontalPodAutoscalerCondition {
			/**
			 * type describes the current condition
			 */
			type: string

			/**
			 * lastTransitionTime is the last time the condition transitioned from one status to another
			 */
			lastTransitionTime?: string

			/**
			 * message is a human-readable explanation containing details about the transition
			 */
			message?: string

			/**
			 * reason is the reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * HorizontalPodAutoscalerList is a list of horizontal pod autoscaler objects.
		 */
		export interface HorizontalPodAutoscalerList {
			/**
			 * items is the list of horizontal pod autoscaler objects.
			 */
			items: autoscaling.v2beta2.HorizontalPodAutoscaler[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'autoscaling/v2beta2'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'HorizontalPodAutoscalerList'

			/**
			 * metadata is the standard list metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isHorizontalPodAutoscalerList(
			o: any
		): o is HorizontalPodAutoscalerList {
			return (
				o.apiVersion == 'autoscaling/v2beta2' &&
				o.kind == 'HorizontalPodAutoscalerList'
			)
		}

		/**
		 * HorizontalPodAutoscalerSpec describes the desired functionality of the
		 * HorizontalPodAutoscaler.
		 */
		export interface HorizontalPodAutoscalerSpec {
			/**
			 * maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale
			 * up. It cannot be less that minReplicas.
			 */
			maxReplicas: number

			/**
			 * scaleTargetRef points to the target resource to scale, and is used to the pods for which
			 * metrics should be collected, as well as to actually change the replica count.
			 */
			scaleTargetRef: autoscaling.v2beta2.CrossVersionObjectReference

			/**
			 * metrics contains the specifications for which to use to calculate the desired replica count
			 * (the maximum replica count across all metrics will be used).  The desired replica count is
			 * calculated multiplying the ratio between the target value and the current value by the
			 * current number of pods.  Ergo, metrics used must decrease as the pod count is increased,
			 * and vice-versa.  See the individual metric source types for more information about how each
			 * type of metric must respond. If not set, the default metric will be set to 80% average CPU
			 * utilization.
			 */
			metrics?: autoscaling.v2beta2.MetricSpec[]

			/**
			 * minReplicas is the lower limit for the number of replicas to which the autoscaler can scale
			 * down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the alpha feature gate
			 * HPAScaleToZero is enabled and at least one Object or External metric is configured.
			 * Scaling is active as long as at least one metric value is available.
			 */
			minReplicas?: number
		}

		/**
		 * MetricIdentifier defines the name and optionally selector for a metric
		 */
		export interface MetricIdentifier {
			/**
			 * name is the name of the given metric
			 */
			name: string

			/**
			 * selector is the string-encoded form of a standard kubernetes label selector for the given
			 * metric When set, it is passed as an additional parameter to the metrics server for more
			 * specific metrics scoping. When unset, just the metricName will be used to gather metrics.
			 */
			selector?: meta.v1.LabelSelector
		}

		/**
		 * MetricSpec specifies how to scale based on a single metric (only `type` and one other
		 * matching field should be set at once).
		 */
		export interface MetricSpec {
			/**
			 * type is the type of metric source.  It should be one of "Object", "Pods" or "Resource",
			 * each mapping to a matching field in the object.
			 */
			type: string

			/**
			 * external refers to a global metric that is not associated with any Kubernetes object. It
			 * allows autoscaling based on information coming from components running outside of cluster
			 * (for example length of queue in cloud messaging service, or QPS from loadbalancer running
			 * outside of cluster).
			 */
			external?: autoscaling.v2beta2.ExternalMetricSource

			/**
			 * object refers to a metric describing a single kubernetes object (for example,
			 * hits-per-second on an Ingress object).
			 */
			object?: autoscaling.v2beta2.ObjectMetricSource

			/**
			 * pods refers to a metric describing each pod in the current scale target (for example,
			 * transactions-processed-per-second).  The values will be averaged together before being
			 * compared to the target value.
			 */
			pods?: autoscaling.v2beta2.PodsMetricSource

			/**
			 * resource refers to a resource metric (such as those specified in requests and limits) known
			 * to Kubernetes describing each pod in the current scale target (e.g. CPU or memory). Such
			 * metrics are built in to Kubernetes, and have special scaling options on top of those
			 * available to normal per-pod metrics using the "pods" source.
			 */
			resource?: autoscaling.v2beta2.ResourceMetricSource
		}

		/**
		 * MetricTarget defines the target value, average value, or average utilization of a specific
		 * metric
		 */
		export interface MetricTarget {
			/**
			 * type represents whether the metric type is Utilization, Value, or AverageValue
			 */
			type: string

			/**
			 * averageUtilization is the target value of the average of the resource metric across all
			 * relevant pods, represented as a percentage of the requested value of the resource for the
			 * pods. Currently only valid for Resource metric source type
			 */
			averageUtilization?: number

			/**
			 * averageValue is the target value of the average of the metric across all relevant pods (as
			 * a quantity)
			 */
			averageValue?: string

			/**
			 * value is the target value of the metric (as a quantity).
			 */
			value?: string
		}

		/**
		 * ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for
		 * example, hits-per-second on an Ingress object).
		 */
		export interface ObjectMetricSource {
			describedObject: autoscaling.v2beta2.CrossVersionObjectReference

			/**
			 * metric identifies the target metric by name and selector
			 */
			metric: autoscaling.v2beta2.MetricIdentifier

			/**
			 * target specifies the target value for the given metric
			 */
			target: autoscaling.v2beta2.MetricTarget
		}

		/**
		 * PodsMetricSource indicates how to scale on a metric describing each pod in the current scale
		 * target (for example, transactions-processed-per-second). The values will be averaged together
		 * before being compared to the target value.
		 */
		export interface PodsMetricSource {
			/**
			 * metric identifies the target metric by name and selector
			 */
			metric: autoscaling.v2beta2.MetricIdentifier

			/**
			 * target specifies the target value for the given metric
			 */
			target: autoscaling.v2beta2.MetricTarget
		}

		/**
		 * ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as
		 * specified in requests and limits, describing each pod in the current scale target (e.g. CPU
		 * or memory).  The values will be averaged together before being compared to the target.  Such
		 * metrics are built in to Kubernetes, and have special scaling options on top of those
		 * available to normal per-pod metrics using the "pods" source.  Only one "target" type should
		 * be set.
		 */
		export interface ResourceMetricSource {
			/**
			 * name is the name of the resource in question.
			 */
			name: string

			/**
			 * target specifies the target value for the given metric
			 */
			target: autoscaling.v2beta2.MetricTarget
		}
	}
}

export namespace batch {
	export namespace v1 {
		/**
		 * Job represents the configuration of a single job.
		 */
		export interface Job {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'batch/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Job'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of a job. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: batch.v1.JobSpec
		}

		export function isJob(o: any): o is Job {
			return o.apiVersion == 'batch/v1' && o.kind == 'Job'
		}

		/**
		 * JobCondition describes current state of a job.
		 */
		export interface JobCondition {
			/**
			 * Type of job condition, Complete or Failed.
			 */
			type: string

			/**
			 * Last time the condition was checked.
			 */
			lastProbeTime?: string

			/**
			 * Last time the condition transit from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * Human readable message indicating details about last transition.
			 */
			message?: string

			/**
			 * (brief) reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * JobList is a collection of jobs.
		 */
		export interface JobList {
			/**
			 * items is the list of Jobs.
			 */
			items: batch.v1.Job[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'batch/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'JobList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isJobList(o: any): o is JobList {
			return o.apiVersion == 'batch/v1' && o.kind == 'JobList'
		}

		/**
		 * JobSpec describes how the job execution will look like.
		 */
		export interface JobSpec {
			/**
			 * Describes the pod that will be created when executing a job. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
			 */
			template: core.v1.PodTemplateSpec

			/**
			 * Specifies the duration in seconds relative to the startTime that the job may be active
			 * before the system tries to terminate it; value must be positive integer
			 */
			activeDeadlineSeconds?: number

			/**
			 * Specifies the number of retries before marking this job failed. Defaults to 6
			 */
			backoffLimit?: number

			/**
			 * Specifies the desired number of successfully finished pods the job should be run with.
			 * Setting to nil means that the success of any pod signals the success of all pods, and
			 * allows parallelism to have any positive value.  Setting to 1 means that parallelism is
			 * limited to 1 and the success of that pod signals the success of the job. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
			 */
			completions?: number

			/**
			 * manualSelector controls generation of pod labels and pod selectors. Leave `manualSelector`
			 * unset unless you are certain what you are doing. When false or unset, the system pick
			 * labels unique to this job and appends those labels to the pod template.  When true, the
			 * user is responsible for picking unique labels and specifying the selector.  Failure to pick
			 * a unique label may cause this and other jobs to not function correctly.  However, You may
			 * see `manualSelector=true` in jobs that were created with the old `extensions/v1beta1` API.
			 * More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
			 */
			manualSelector?: boolean

			/**
			 * Specifies the maximum desired number of pods the job should run at any given time. The
			 * actual number of pods running in steady state will be less than this number when
			 * ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to
			 * do is less than max parallelism. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
			 */
			parallelism?: number

			/**
			 * A label query over pods that should match the pod count. Normally, the system sets this
			 * field for you. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
			 */
			selector?: meta.v1.LabelSelector

			/**
			 * ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either
			 * Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes,
			 * it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle
			 * guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be
			 * automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted
			 * immediately after it finishes. This field is alpha-level and is only honored by servers
			 * that enable the TTLAfterFinished feature.
			 */
			ttlSecondsAfterFinished?: number
		}
	}
	export namespace v1beta1 {
		/**
		 * CronJob represents the configuration of a single cron job.
		 */
		export interface CronJob {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'batch/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CronJob'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of a cron job, including the schedule. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: batch.v1beta1.CronJobSpec
		}

		export function isCronJob(o: any): o is CronJob {
			return o.apiVersion == 'batch/v1beta1' && o.kind == 'CronJob'
		}

		/**
		 * CronJobList is a collection of cron jobs.
		 */
		export interface CronJobList {
			/**
			 * items is the list of CronJobs.
			 */
			items: batch.v1beta1.CronJob[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'batch/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CronJobList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isCronJobList(o: any): o is CronJobList {
			return o.apiVersion == 'batch/v1beta1' && o.kind == 'CronJobList'
		}

		/**
		 * CronJobSpec describes how the job execution will look like and when it will actually run.
		 */
		export interface CronJobSpec {
			/**
			 * Specifies the job that will be created when executing a CronJob.
			 */
			jobTemplate: batch.v1beta1.JobTemplateSpec

			/**
			 * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
			 */
			schedule: string

			/**
			 * Specifies how to treat concurrent executions of a Job. Valid values are: - "Allow"
			 * (default): allows CronJobs to run concurrently; - "Forbid": forbids concurrent runs,
			 * skipping next run if previous run hasn't finished yet; - "Replace": cancels currently
			 * running job and replaces it with a new one
			 */
			concurrencyPolicy?: string

			/**
			 * The number of failed finished jobs to retain. This is a pointer to distinguish between
			 * explicit zero and not specified. Defaults to 1.
			 */
			failedJobsHistoryLimit?: number

			/**
			 * Optional deadline in seconds for starting the job if it misses scheduled time for any
			 * reason.  Missed jobs executions will be counted as failed ones.
			 */
			startingDeadlineSeconds?: number

			/**
			 * The number of successful finished jobs to retain. This is a pointer to distinguish between
			 * explicit zero and not specified. Defaults to 3.
			 */
			successfulJobsHistoryLimit?: number

			/**
			 * This flag tells the controller to suspend subsequent executions, it does not apply to
			 * already started executions.  Defaults to false.
			 */
			suspend?: boolean
		}

		/**
		 * JobTemplateSpec describes the data a Job should have when created from a template
		 */
		export interface JobTemplateSpec {
			/**
			 * Standard object's metadata of the jobs created from this template. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of the job. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: batch.v1.JobSpec
		}
	}
	export namespace v2alpha1 {
		/**
		 * CronJob represents the configuration of a single cron job.
		 */
		export interface CronJob {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'batch/v2alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CronJob'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of a cron job, including the schedule. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: batch.v2alpha1.CronJobSpec
		}

		export function isCronJob(o: any): o is CronJob {
			return o.apiVersion == 'batch/v2alpha1' && o.kind == 'CronJob'
		}

		/**
		 * CronJobList is a collection of cron jobs.
		 */
		export interface CronJobList {
			/**
			 * items is the list of CronJobs.
			 */
			items: batch.v2alpha1.CronJob[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'batch/v2alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CronJobList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isCronJobList(o: any): o is CronJobList {
			return o.apiVersion == 'batch/v2alpha1' && o.kind == 'CronJobList'
		}

		/**
		 * CronJobSpec describes how the job execution will look like and when it will actually run.
		 */
		export interface CronJobSpec {
			/**
			 * Specifies the job that will be created when executing a CronJob.
			 */
			jobTemplate: batch.v2alpha1.JobTemplateSpec

			/**
			 * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
			 */
			schedule: string

			/**
			 * Specifies how to treat concurrent executions of a Job. Valid values are: - "Allow"
			 * (default): allows CronJobs to run concurrently; - "Forbid": forbids concurrent runs,
			 * skipping next run if previous run hasn't finished yet; - "Replace": cancels currently
			 * running job and replaces it with a new one
			 */
			concurrencyPolicy?: string

			/**
			 * The number of failed finished jobs to retain. This is a pointer to distinguish between
			 * explicit zero and not specified.
			 */
			failedJobsHistoryLimit?: number

			/**
			 * Optional deadline in seconds for starting the job if it misses scheduled time for any
			 * reason.  Missed jobs executions will be counted as failed ones.
			 */
			startingDeadlineSeconds?: number

			/**
			 * The number of successful finished jobs to retain. This is a pointer to distinguish between
			 * explicit zero and not specified.
			 */
			successfulJobsHistoryLimit?: number

			/**
			 * This flag tells the controller to suspend subsequent executions, it does not apply to
			 * already started executions.  Defaults to false.
			 */
			suspend?: boolean
		}

		/**
		 * JobTemplateSpec describes the data a Job should have when created from a template
		 */
		export interface JobTemplateSpec {
			/**
			 * Standard object's metadata of the jobs created from this template. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of the job. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: batch.v1.JobSpec
		}
	}
}

export namespace certificates {
	export namespace v1beta1 {
		/**
		 * Describes a certificate signing request
		 */
		export interface CertificateSigningRequest {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'certificates.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CertificateSigningRequest'

			metadata?: meta.v1.ObjectMeta

			/**
			 * The certificate request itself and any additional information.
			 */
			spec?: certificates.v1beta1.CertificateSigningRequestSpec
		}

		export function isCertificateSigningRequest(
			o: any
		): o is CertificateSigningRequest {
			return (
				o.apiVersion == 'certificates.k8s.io/v1beta1' &&
				o.kind == 'CertificateSigningRequest'
			)
		}

		/**
		 *
		 */
		export interface CertificateSigningRequestCondition {
			/**
			 * request approval state, currently Approved or Denied.
			 */
			type: string

			/**
			 * timestamp for the last update to this condition
			 */
			lastUpdateTime?: string

			/**
			 * human readable message with details about the request state
			 */
			message?: string

			/**
			 * brief reason for the request state
			 */
			reason?: string
		}

		/**
		 *
		 */
		export interface CertificateSigningRequestList {
			items: certificates.v1beta1.CertificateSigningRequest[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'certificates.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CertificateSigningRequestList'

			metadata?: meta.v1.ListMeta
		}

		export function isCertificateSigningRequestList(
			o: any
		): o is CertificateSigningRequestList {
			return (
				o.apiVersion == 'certificates.k8s.io/v1beta1' &&
				o.kind == 'CertificateSigningRequestList'
			)
		}

		/**
		 * This information is immutable after the request is created. Only the Request and Usages
		 * fields can be set on creation, other fields are derived by Kubernetes and cannot be modified
		 * by users.
		 */
		export interface CertificateSigningRequestSpec {
			/**
			 * Base64-encoded PKCS#10 CSR data
			 */
			request: string

			/**
			 * Extra information about the requesting user. See user.Info interface for details.
			 */
			extra?: object

			/**
			 * Group information about the requesting user. See user.Info interface for details.
			 */
			groups?: string[]

			/**
			 * UID information about the requesting user. See user.Info interface for details.
			 */
			uid?: string

			/**
			 * allowedUsages specifies a set of usage contexts the key will be valid for. See:
			 * https://tools.ietf.org/html/rfc5280#section-4.2.1.3
			 *      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
			 */
			usages?: string[]

			/**
			 * Information about the requesting user. See user.Info interface for details.
			 */
			username?: string
		}
	}
}

export namespace coordination {
	export namespace v1 {
		/**
		 * Lease defines a lease concept.
		 */
		export interface Lease {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'coordination.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Lease'

			/**
			 * More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the Lease. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: coordination.v1.LeaseSpec
		}

		export function isLease(o: any): o is Lease {
			return o.apiVersion == 'coordination.k8s.io/v1' && o.kind == 'Lease'
		}

		/**
		 * LeaseList is a list of Lease objects.
		 */
		export interface LeaseList {
			/**
			 * Items is a list of schema objects.
			 */
			items: coordination.v1.Lease[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'coordination.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'LeaseList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isLeaseList(o: any): o is LeaseList {
			return o.apiVersion == 'coordination.k8s.io/v1' && o.kind == 'LeaseList'
		}

		/**
		 * LeaseSpec is a specification of a Lease.
		 */
		export interface LeaseSpec {
			/**
			 * acquireTime is a time when the current lease was acquired.
			 */
			acquireTime?: string

			/**
			 * holderIdentity contains the identity of the holder of a current lease.
			 */
			holderIdentity?: string

			/**
			 * leaseDurationSeconds is a duration that candidates for a lease need to wait to force
			 * acquire it. This is measure against time of last observed RenewTime.
			 */
			leaseDurationSeconds?: number

			/**
			 * leaseTransitions is the number of transitions of a lease between holders.
			 */
			leaseTransitions?: number

			/**
			 * renewTime is a time when the current holder of a lease has last updated the lease.
			 */
			renewTime?: string
		}
	}
	export namespace v1beta1 {
		/**
		 * Lease defines a lease concept.
		 */
		export interface Lease {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'coordination.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Lease'

			/**
			 * More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the Lease. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: coordination.v1beta1.LeaseSpec
		}

		export function isLease(o: any): o is Lease {
			return o.apiVersion == 'coordination.k8s.io/v1beta1' && o.kind == 'Lease'
		}

		/**
		 * LeaseList is a list of Lease objects.
		 */
		export interface LeaseList {
			/**
			 * Items is a list of schema objects.
			 */
			items: coordination.v1beta1.Lease[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'coordination.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'LeaseList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isLeaseList(o: any): o is LeaseList {
			return (
				o.apiVersion == 'coordination.k8s.io/v1beta1' && o.kind == 'LeaseList'
			)
		}

		/**
		 * LeaseSpec is a specification of a Lease.
		 */
		export interface LeaseSpec {
			/**
			 * acquireTime is a time when the current lease was acquired.
			 */
			acquireTime?: string

			/**
			 * holderIdentity contains the identity of the holder of a current lease.
			 */
			holderIdentity?: string

			/**
			 * leaseDurationSeconds is a duration that candidates for a lease need to wait to force
			 * acquire it. This is measure against time of last observed RenewTime.
			 */
			leaseDurationSeconds?: number

			/**
			 * leaseTransitions is the number of transitions of a lease between holders.
			 */
			leaseTransitions?: number

			/**
			 * renewTime is a time when the current holder of a lease has last updated the lease.
			 */
			renewTime?: string
		}
	}
}

export namespace core {
	export namespace v1 {
		/**
		 * Represents a Persistent Disk resource in AWS.
		 *
		 * An AWS EBS disk must exist before mounting to a container. The disk must also be in the same
		 * AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS
		 * volumes support ownership management and SELinux relabeling.
		 */
		export interface AWSElasticBlockStoreVolumeSource {
			/**
			 * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
			 */
			volumeID: string

			/**
			 * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type
			 * is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
			 * inferred to be "ext4" if unspecified. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
			 */
			fsType?: string

			/**
			 * The partition in the volume that you want to mount. If omitted, the default is to mount by
			 * volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly,
			 * the volume partition for /dev/sda is "0" (or you can leave the property empty).
			 */
			partition?: number

			/**
			 * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If
			 * omitted, the default is "false". More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
			 */
			readOnly?: boolean
		}

		/**
		 * Affinity is a group of affinity scheduling rules.
		 */
		export interface Affinity {
			/**
			 * Describes node affinity scheduling rules for the pod.
			 */
			nodeAffinity?: core.v1.NodeAffinity

			/**
			 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
			 * etc. as some other pod(s)).
			 */
			podAffinity?: core.v1.PodAffinity

			/**
			 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
			 * zone, etc. as some other pod(s)).
			 */
			podAntiAffinity?: core.v1.PodAntiAffinity
		}

		/**
		 * AttachedVolume describes a volume attached to a node
		 */
		export interface AttachedVolume {
			/**
			 * DevicePath represents the device path where the volume should be available
			 */
			devicePath: string

			/**
			 * Name of the attached volume
			 */
			name: string
		}

		/**
		 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
		 */
		export interface AzureDiskVolumeSource {
			/**
			 * The Name of the data disk in the blob storage
			 */
			diskName: string

			/**
			 * The URI the data disk in the blob storage
			 */
			diskURI: string

			/**
			 * Host Caching mode: None, Read Only, Read Write.
			 */
			cachingMode?: string

			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
			 */
			fsType?: string

			/**
			 * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob
			 * disk per storage account  Managed: azure managed data disk (only in managed availability
			 * set). defaults to shared
			 */
			kind?: string

			/**
			 * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts.
			 */
			readOnly?: boolean
		}

		/**
		 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
		 */
		export interface AzureFilePersistentVolumeSource {
			/**
			 * the name of secret that contains Azure Storage Account Name and Key
			 */
			secretName: string

			/**
			 * Share Name
			 */
			shareName: string

			/**
			 * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts.
			 */
			readOnly?: boolean

			/**
			 * the namespace of the secret that contains Azure Storage Account Name and Key default is the
			 * same as the Pod
			 */
			secretNamespace?: string
		}

		/**
		 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
		 */
		export interface AzureFileVolumeSource {
			/**
			 * the name of secret that contains Azure Storage Account Name and Key
			 */
			secretName: string

			/**
			 * Share Name
			 */
			shareName: string

			/**
			 * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts.
			 */
			readOnly?: boolean
		}

		/**
		 * Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
		 *
		 * @deprecated core/v1/Binding is deprecated by the bindings subresource of pods and not
		 * supported by Kubernetes v1.7+ clusters.
		 */
		export interface Binding {
			/**
			 * The target object that you want to bind to the standard object.
			 */
			target: core.v1.ObjectReference

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Binding'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isBinding(o: any): o is Binding {
			return o.apiVersion == 'v1' && o.kind == 'Binding'
		}

		/**
		 * Represents storage that is managed by an external CSI volume driver (Beta feature)
		 */
		export interface CSIPersistentVolumeSource {
			/**
			 * Driver is the name of the driver to use for this volume. Required.
			 */
			driver: string

			/**
			 * VolumeHandle is the unique volume name returned by the CSI volume plugins CreateVolume
			 * to refer to the volume on all subsequent calls. Required.
			 */
			volumeHandle: string

			/**
			 * ControllerExpandSecretRef is a reference to the secret object containing sensitive
			 * information to pass to the CSI driver to complete the CSI ControllerExpandVolume call. This
			 * is an alpha field and requires enabling ExpandCSIVolumes feature gate. This field is
			 * optional, and may be empty if no secret is required. If the secret object contains more
			 * than one secret, all secrets are passed.
			 */
			controllerExpandSecretRef?: core.v1.SecretReference

			/**
			 * ControllerPublishSecretRef is a reference to the secret object containing sensitive
			 * information to pass to the CSI driver to complete the CSI ControllerPublishVolume and
			 * ControllerUnpublishVolume calls. This field is optional, and may be empty if no secret is
			 * required. If the secret object contains more than one secret, all secrets are passed.
			 */
			controllerPublishSecretRef?: core.v1.SecretReference

			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Ex. "ext4", "xfs", "ntfs".
			 */
			fsType?: string

			/**
			 * NodePublishSecretRef is a reference to the secret object containing sensitive information
			 * to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume
			 * calls. This field is optional, and may be empty if no secret is required. If the secret
			 * object contains more than one secret, all secrets are passed.
			 */
			nodePublishSecretRef?: core.v1.SecretReference

			/**
			 * NodeStageSecretRef is a reference to the secret object containing sensitive information to
			 * pass to the CSI driver to complete the CSI NodeStageVolume and NodeStageVolume and
			 * NodeUnstageVolume calls. This field is optional, and may be empty if no secret is required.
			 * If the secret object contains more than one secret, all secrets are passed.
			 */
			nodeStageSecretRef?: core.v1.SecretReference

			/**
			 * Optional: The value to pass to ControllerPublishVolumeRequest. Defaults to false
			 * (read/write).
			 */
			readOnly?: boolean

			/**
			 * Attributes of the volume to publish.
			 */
			volumeAttributes?: { [key: string]: string }
		}

		/**
		 * Represents a source location of a volume to mount, managed by an external CSI driver
		 */
		export interface CSIVolumeSource {
			/**
			 * Driver is the name of the CSI driver that handles this volume. Consult with your admin for
			 * the correct name as registered in the cluster.
			 */
			driver: string

			/**
			 * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is
			 * passed to the associated CSI driver which will determine the default filesystem to apply.
			 */
			fsType?: string

			/**
			 * NodePublishSecretRef is a reference to the secret object containing sensitive information
			 * to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume
			 * calls. This field is optional, and  may be empty if no secret is required. If the secret
			 * object contains more than one secret, all secret references are passed.
			 */
			nodePublishSecretRef?: core.v1.LocalObjectReference

			/**
			 * Specifies a read-only configuration for the volume. Defaults to false (read/write).
			 */
			readOnly?: boolean

			/**
			 * VolumeAttributes stores driver-specific properties that are passed to the CSI driver.
			 * Consult your driver's documentation for supported values.
			 */
			volumeAttributes?: { [key: string]: string }
		}

		/**
		 * Adds and removes POSIX capabilities from running containers.
		 */
		export interface Capabilities {
			/**
			 * Added capabilities
			 */
			add?: string[]

			/**
			 * Removed capabilities
			 */
			drop?: string[]
		}

		/**
		 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not
		 * support ownership management or SELinux relabeling.
		 */
		export interface CephFSPersistentVolumeSource {
			/**
			 * Required: Monitors is a collection of Ceph monitors More info:
			 * https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			 */
			monitors: string[]

			/**
			 * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
			 */
			path?: string

			/**
			 * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			 */
			readOnly?: boolean

			/**
			 * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
			 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			 */
			secretFile?: string

			/**
			 * Optional: SecretRef is reference to the authentication secret for User, default is empty.
			 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			 */
			secretRef?: core.v1.SecretReference

			/**
			 * Optional: User is the rados user name, default is admin More info:
			 * https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			 */
			user?: string
		}

		/**
		 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not
		 * support ownership management or SELinux relabeling.
		 */
		export interface CephFSVolumeSource {
			/**
			 * Required: Monitors is a collection of Ceph monitors More info:
			 * https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			 */
			monitors: string[]

			/**
			 * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
			 */
			path?: string

			/**
			 * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			 */
			readOnly?: boolean

			/**
			 * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
			 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			 */
			secretFile?: string

			/**
			 * Optional: SecretRef is reference to the authentication secret for User, default is empty.
			 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			 */
			secretRef?: core.v1.LocalObjectReference

			/**
			 * Optional: User is the rados user name, default is admin More info:
			 * https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
			 */
			user?: string
		}

		/**
		 * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting
		 * to a container. The volume must also be in the same region as the kubelet. Cinder volumes
		 * support ownership management and SELinux relabeling.
		 */
		export interface CinderPersistentVolumeSource {
			/**
			 * volume id used to identify the volume in cinder. More info:
			 * https://examples.k8s.io/mysql-cinder-pd/README.md
			 */
			volumeID: string

			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More
			 * info: https://examples.k8s.io/mysql-cinder-pd/README.md
			 */
			fsType?: string

			/**
			 * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
			 */
			readOnly?: boolean

			/**
			 * Optional: points to a secret object containing parameters used to connect to OpenStack.
			 */
			secretRef?: core.v1.SecretReference
		}

		/**
		 * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting
		 * to a container. The volume must also be in the same region as the kubelet. Cinder volumes
		 * support ownership management and SELinux relabeling.
		 */
		export interface CinderVolumeSource {
			/**
			 * volume id used to identify the volume in cinder. More info:
			 * https://examples.k8s.io/mysql-cinder-pd/README.md
			 */
			volumeID: string

			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More
			 * info: https://examples.k8s.io/mysql-cinder-pd/README.md
			 */
			fsType?: string

			/**
			 * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
			 */
			readOnly?: boolean

			/**
			 * Optional: points to a secret object containing parameters used to connect to OpenStack.
			 */
			secretRef?: core.v1.LocalObjectReference
		}

		/**
		 * ClientIPConfig represents the configurations of Client IP based session affinity.
		 */
		export interface ClientIPConfig {
			/**
			 * timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must
			 * be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3
			 * hours).
			 */
			timeoutSeconds?: number
		}

		/**
		 * Information about the condition of a component.
		 */
		export interface ComponentCondition {
			/**
			 * Type of condition for a component. Valid value: "Healthy"
			 */
			type: string

			/**
			 * Condition error code for a component. For example, a health check error code.
			 */
			error?: string

			/**
			 * Message about the condition for a component. For example, information about a health check.
			 */
			message?: string
		}

		/**
		 * ConfigMap holds configuration data for pods to consume.
		 */
		export interface ConfigMap {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * BinaryData contains the binary data. Each key must consist of alphanumeric characters, '-',
			 * '_' or '.'. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys
			 * stored in BinaryData must not overlap with the ones in the Data field, this is enforced
			 * during validation process. Using this field will require 1.10+ apiserver and kubelet.
			 */
			binaryData?: object

			/**
			 * Data contains the configuration data. Each key must consist of alphanumeric characters,
			 * '-', '_' or '.'. Values with non-UTF-8 byte sequences must use the BinaryData field. The
			 * keys stored in Data must not overlap with the keys in the BinaryData field, this is
			 * enforced during validation process.
			 */
			data?: { [key: string]: string }

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ConfigMap'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isConfigMap(o: any): o is ConfigMap {
			return o.apiVersion == 'v1' && o.kind == 'ConfigMap'
		}

		/**
		 * ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.
		 *
		 * The contents of the target ConfigMap's Data field will represent the key-value pairs as
		 * environment variables.
		 */
		export interface ConfigMapEnvSource {
			/**
			 * Name of the referent. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			 */
			name?: string

			/**
			 * Specify whether the ConfigMap must be defined
			 */
			optional?: boolean
		}

		/**
		 * Selects a key from a ConfigMap.
		 */
		export interface ConfigMapKeySelector {
			/**
			 * The key to select.
			 */
			key: string

			/**
			 * Name of the referent. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			 */
			name?: string

			/**
			 * Specify whether the ConfigMap or its key must be defined
			 */
			optional?: boolean
		}

		/**
		 * ConfigMapList is a resource containing a list of ConfigMap objects.
		 */
		export interface ConfigMapList {
			/**
			 * Items is the list of ConfigMaps.
			 */
			items: core.v1.ConfigMap[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ConfigMapList'

			/**
			 * More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isConfigMapList(o: any): o is ConfigMapList {
			return o.apiVersion == 'v1' && o.kind == 'ConfigMapList'
		}

		/**
		 * ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config
		 * source for the Node.
		 */
		export interface ConfigMapNodeConfigSource {
			/**
			 * KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the
			 * KubeletConfiguration structure This field is required in all cases.
			 */
			kubeletConfigKey: string

			/**
			 * Name is the metadata.name of the referenced ConfigMap. This field is required in all cases.
			 */
			name: string

			/**
			 * Namespace is the metadata.namespace of the referenced ConfigMap. This field is required in
			 * all cases.
			 */
			namespace: string

			/**
			 * ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap. This field is
			 * forbidden in Node.Spec, and required in Node.Status.
			 */
			resourceVersion?: string

			/**
			 * UID is the metadata.UID of the referenced ConfigMap. This field is forbidden in Node.Spec,
			 * and required in Node.Status.
			 */
			uid?: string
		}

		/**
		 * Adapts a ConfigMap into a projected volume.
		 *
		 * The contents of the target ConfigMap's Data field will be presented in a projected volume as
		 * files using the keys in the Data field as the file names, unless the items element is
		 * populated with specific mappings of keys to paths. Note that this is identical to a configmap
		 * volume source without the default mode.
		 */
		export interface ConfigMapProjection {
			/**
			 * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be
			 * projected into the volume as a file whose name is the key and content is the value. If
			 * specified, the listed keys will be projected into the specified paths, and unlisted keys
			 * will not be present. If a key is specified which is not present in the ConfigMap, the
			 * volume setup will error unless it is marked optional. Paths must be relative and may not
			 * contain the '..' path or start with '..'.
			 */
			items?: core.v1.KeyToPath[]

			/**
			 * Name of the referent. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			 */
			name?: string

			/**
			 * Specify whether the ConfigMap or its keys must be defined
			 */
			optional?: boolean
		}

		/**
		 * Adapts a ConfigMap into a volume.
		 *
		 * The contents of the target ConfigMap's Data field will be presented in a volume as files
		 * using the keys in the Data field as the file names, unless the items element is populated
		 * with specific mappings of keys to paths. ConfigMap volumes support ownership management and
		 * SELinux relabeling.
		 */
		export interface ConfigMapVolumeSource {
			/**
			 * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777.
			 * Defaults to 0644. Directories within the path are not affected by this setting. This might
			 * be in conflict with other options that affect the file mode, like fsGroup, and the result
			 * can be other mode bits set.
			 */
			defaultMode?: number

			/**
			 * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be
			 * projected into the volume as a file whose name is the key and content is the value. If
			 * specified, the listed keys will be projected into the specified paths, and unlisted keys
			 * will not be present. If a key is specified which is not present in the ConfigMap, the
			 * volume setup will error unless it is marked optional. Paths must be relative and may not
			 * contain the '..' path or start with '..'.
			 */
			items?: core.v1.KeyToPath[]

			/**
			 * Name of the referent. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			 */
			name?: string

			/**
			 * Specify whether the ConfigMap or its keys must be defined
			 */
			optional?: boolean
		}

		/**
		 * A single application container that you want to run within a pod.
		 */
		export interface Container {
			/**
			 * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique
			 * name (DNS_LABEL). Cannot be updated.
			 */
			name: string

			/**
			 * Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
			 * Variable references $(VAR_NAME) are expanded using the container's environment. If a
			 * variable cannot be resolved, the reference in the input string will be unchanged. The
			 * $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references
			 * will never be expanded, regardless of whether the variable exists or not. Cannot be
			 * updated. More info:
			 * https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
			 */
			args?: string[]

			/**
			 * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if
			 * this is not provided. Variable references $(VAR_NAME) are expanded using the container's
			 * environment. If a variable cannot be resolved, the reference in the input string will be
			 * unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
			 * Escaped references will never be expanded, regardless of whether the variable exists or
			 * not. Cannot be updated. More info:
			 * https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
			 */
			command?: string[]

			/**
			 * List of environment variables to set in the container. Cannot be updated.
			 */
			env?: core.v1.EnvVar[]

			/**
			 * List of sources to populate environment variables in the container. The keys defined within
			 * a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the
			 * container is starting. When a key exists in multiple sources, the value associated with the
			 * last source will take precedence. Values defined by an Env with a duplicate key will take
			 * precedence. Cannot be updated.
			 */
			envFrom?: core.v1.EnvFromSource[]

			/**
			 * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This
			 * field is optional to allow higher level config management to default or override container
			 * images in workload controllers like Deployments and StatefulSets.
			 */
			image?: string

			/**
			 * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is
			 * specified, or IfNotPresent otherwise. Cannot be updated. More info:
			 * https://kubernetes.io/docs/concepts/containers/images#updating-images
			 */
			imagePullPolicy?: string

			/**
			 * Actions that the management system should take in response to container lifecycle events.
			 * Cannot be updated.
			 */
			lifecycle?: core.v1.Lifecycle

			/**
			 * Periodic probe of container liveness. Container will be restarted if the probe fails.
			 * Cannot be updated. More info:
			 * https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			 */
			livenessProbe?: core.v1.Probe

			/**
			 * List of ports to expose from the container. Exposing a port here gives the system
			 * additional information about the network connections a container uses, but is primarily
			 * informational. Not specifying a port here DOES NOT prevent that port from being exposed.
			 * Any port which is listening on the default "0.0.0.0" address inside a container will be
			 * accessible from the network. Cannot be updated.
			 */
			ports?: core.v1.ContainerPort[]

			/**
			 * Periodic probe of container service readiness. Container will be removed from service
			 * endpoints if the probe fails. Cannot be updated. More info:
			 * https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			 */
			readinessProbe?: core.v1.Probe

			/**
			 * Compute Resources required by this container. Cannot be updated. More info:
			 * https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
			 */
			resources?: core.v1.ResourceRequirements

			/**
			 * Security options the pod should run with. More info:
			 * https://kubernetes.io/docs/concepts/policy/security-context/ More info:
			 * https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
			 */
			securityContext?: core.v1.SecurityContext

			/**
			 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other
			 * probes are executed until this completes successfully. If this probe fails, the Pod will be
			 * restarted, just as if the livenessProbe failed. This can be used to provide different probe
			 * parameters at the beginning of a Pod's lifecycle, when it might take a long time to load
			 * data or warm a cache, than during steady-state operation. This cannot be updated. This is
			 * an alpha feature enabled by the StartupProbe feature flag. More info:
			 * https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			 */
			startupProbe?: core.v1.Probe

			/**
			 * Whether this container should allocate a buffer for stdin in the container runtime. If this
			 * is not set, reads from stdin in the container will always result in EOF. Default is false.
			 */
			stdin?: boolean

			/**
			 * Whether the container runtime should close the stdin channel after it has been opened by a
			 * single attach. When stdin is true the stdin stream will remain open across multiple attach
			 * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until
			 * the first client attaches to stdin, and then remains open and accepts data until the client
			 * disconnects, at which time stdin is closed and remains closed until the container is
			 * restarted. If this flag is false, a container processes that reads from stdin will never
			 * receive an EOF. Default is false
			 */
			stdinOnce?: boolean

			/**
			 * Optional: Path at which the file to which the container's termination message will be
			 * written is mounted into the container's filesystem. Message written is intended to be brief
			 * final status, such as an assertion failure message. Will be truncated by the node if
			 * greater than 4096 bytes. The total message length across all containers will be limited to
			 * 12kb. Defaults to /dev/termination-log. Cannot be updated.
			 */
			terminationMessagePath?: string

			/**
			 * Indicate how the termination message should be populated. File will use the contents of
			 * terminationMessagePath to populate the container status message on both success and
			 * failure. FallbackToLogsOnError will use the last chunk of container log output if the
			 * termination message file is empty and the container exited with an error. The log output is
			 * limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be
			 * updated.
			 */
			terminationMessagePolicy?: string

			/**
			 * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
			 * Default is false.
			 */
			tty?: boolean

			/**
			 * volumeDevices is the list of block devices to be used by the container. This is a beta
			 * feature.
			 */
			volumeDevices?: core.v1.VolumeDevice[]

			/**
			 * Pod volumes to mount into the container's filesystem. Cannot be updated.
			 */
			volumeMounts?: core.v1.VolumeMount[]

			/**
			 * Container's working directory. If not specified, the container runtime's default will be
			 * used, which might be configured in the container image. Cannot be updated.
			 */
			workingDir?: string
		}

		/**
		 * Describe a container image
		 */
		export interface ContainerImage {
			/**
			 * Names by which this image is known. e.g. ["k8s.gcr.io/hyperkube:v1.0.7",
			 * "dockerhub.io/google_containers/hyperkube:v1.0.7"]
			 */
			names: string[]

			/**
			 * The size of the image in bytes.
			 */
			sizeBytes?: number
		}

		/**
		 * ContainerPort represents a network port in a single container.
		 */
		export interface ContainerPort {
			/**
			 * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x <
			 * 65536.
			 */
			containerPort: number

			/**
			 * What host IP to bind the external port to.
			 */
			hostIP?: string

			/**
			 * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x
			 * < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not
			 * need this.
			 */
			hostPort?: number

			/**
			 * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a
			 * pod must have a unique name. Name for the port that can be referred to by services.
			 */
			name?: string

			/**
			 * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
			 */
			protocol?: string
		}

		/**
		 * ContainerState holds a possible state of container. Only one of its members may be specified.
		 * If none of them is specified, the default one is ContainerStateWaiting.
		 */
		export interface ContainerState {
			/**
			 * Details about a running container
			 */
			running?: core.v1.ContainerStateRunning

			/**
			 * Details about a terminated container
			 */
			terminated?: core.v1.ContainerStateTerminated

			/**
			 * Details about a waiting container
			 */
			waiting?: core.v1.ContainerStateWaiting
		}

		/**
		 * ContainerStateRunning is a running state of a container.
		 */
		export interface ContainerStateRunning {
			/**
			 * Time at which the container was last (re-)started
			 */
			startedAt?: string
		}

		/**
		 * ContainerStateTerminated is a terminated state of a container.
		 */
		export interface ContainerStateTerminated {
			/**
			 * Exit status from the last termination of the container
			 */
			exitCode: number

			/**
			 * Container's ID in the format 'docker://<container_id>'
			 */
			containerID?: string

			/**
			 * Time at which the container last terminated
			 */
			finishedAt?: string

			/**
			 * Message regarding the last termination of the container
			 */
			message?: string

			/**
			 * (brief) reason from the last termination of the container
			 */
			reason?: string

			/**
			 * Signal from the last termination of the container
			 */
			signal?: number

			/**
			 * Time at which previous execution of the container started
			 */
			startedAt?: string
		}

		/**
		 * ContainerStateWaiting is a waiting state of a container.
		 */
		export interface ContainerStateWaiting {
			/**
			 * Message regarding why the container is not yet running.
			 */
			message?: string

			/**
			 * (brief) reason the container is not yet running.
			 */
			reason?: string
		}

		/**
		 * DaemonEndpoint contains information about a single Daemon endpoint.
		 */
		export interface DaemonEndpoint {
			/**
			 * Port number of the given endpoint.
			 */
			Port: number
		}

		/**
		 * Represents downward API info for projecting into a projected volume. Note that this is
		 * identical to a downwardAPI volume source without the default mode.
		 */
		export interface DownwardAPIProjection {
			/**
			 * Items is a list of DownwardAPIVolume file
			 */
			items?: core.v1.DownwardAPIVolumeFile[]
		}

		/**
		 * DownwardAPIVolumeFile represents information to create the file containing the pod field
		 */
		export interface DownwardAPIVolumeFile {
			/**
			 * Required: Path is  the relative path name of the file to be created. Must not be absolute
			 * or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must
			 * not start with '..'
			 */
			path: string

			/**
			 * Required: Selects a field of the pod: only annotations, labels, name and namespace are
			 * supported.
			 */
			fieldRef?: core.v1.ObjectFieldSelector

			/**
			 * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not
			 * specified, the volume defaultMode will be used. This might be in conflict with other
			 * options that affect the file mode, like fsGroup, and the result can be other mode bits set.
			 */
			mode?: number

			/**
			 * Selects a resource of the container: only resources limits and requests (limits.cpu,
			 * limits.memory, requests.cpu and requests.memory) are currently supported.
			 */
			resourceFieldRef?: core.v1.ResourceFieldSelector
		}

		/**
		 * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API
		 * volumes support ownership management and SELinux relabeling.
		 */
		export interface DownwardAPIVolumeSource {
			/**
			 * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777.
			 * Defaults to 0644. Directories within the path are not affected by this setting. This might
			 * be in conflict with other options that affect the file mode, like fsGroup, and the result
			 * can be other mode bits set.
			 */
			defaultMode?: number

			/**
			 * Items is a list of downward API volume file
			 */
			items?: core.v1.DownwardAPIVolumeFile[]
		}

		/**
		 * Represents an empty directory for a pod. Empty directory volumes support ownership management
		 * and SELinux relabeling.
		 */
		export interface EmptyDirVolumeSource {
			/**
			 * What type of storage medium should back this directory. The default is "" which means to
			 * use the node's default medium. Must be an empty string (default) or Memory. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#emptydir
			 */
			medium?: string

			/**
			 * Total amount of local storage required for this EmptyDir volume. The size limit is also
			 * applicable for memory medium. The maximum usage on memory medium EmptyDir would be the
			 * minimum value between the SizeLimit specified here and the sum of memory limits of all
			 * containers in a pod. The default is nil which means that the limit is undefined. More info:
			 * http://kubernetes.io/docs/user-guide/volumes#emptydir
			 */
			sizeLimit?: string
		}

		/**
		 * EndpointAddress is a tuple that describes single IP address.
		 */
		export interface EndpointAddress {
			/**
			 * The IP of this endpoint. May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16), or
			 * link-local multicast ((224.0.0.0/24). IPv6 is also accepted but not fully supported on all
			 * platforms. Also, certain kubernetes components, like kube-proxy, are not IPv6 ready.
			 */
			ip: string

			/**
			 * The Hostname of this endpoint
			 */
			hostname?: string

			/**
			 * Optional: Node hosting this endpoint. This can be used to determine endpoints local to a
			 * node.
			 */
			nodeName?: string

			/**
			 * Reference to object providing the endpoint.
			 */
			targetRef?: core.v1.ObjectReference
		}

		/**
		 * EndpointPort is a tuple that describes a single port.
		 */
		export interface EndpointPort {
			/**
			 * The port number of the endpoint.
			 */
			port: number

			/**
			 * The name of this port.  This must match the 'name' field in the corresponding ServicePort.
			 * Must be a DNS_LABEL. Optional only if one port is defined.
			 */
			name?: string

			/**
			 * The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
			 */
			protocol?: string
		}

		/**
		 * EndpointSubset is a group of addresses with a common set of ports. The expanded set of
		 * endpoints is the Cartesian product of Addresses x Ports. For example, given:
		 *   {
		 *     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
		 *     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
		 *   }
		 * The resulting set of endpoints can be viewed as:
		 *     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
		 *     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
		 */
		export interface EndpointSubset {
			/**
			 * IP addresses which offer the related ports that are marked as ready. These endpoints should
			 * be considered safe for load balancers and clients to utilize.
			 */
			addresses?: core.v1.EndpointAddress[]

			/**
			 * IP addresses which offer the related ports but are not currently marked as ready because
			 * they have not yet finished starting, have recently failed a readiness check, or have
			 * recently failed a liveness check.
			 */
			notReadyAddresses?: core.v1.EndpointAddress[]

			/**
			 * Port numbers available on the related IP addresses.
			 */
			ports?: core.v1.EndpointPort[]
		}

		/**
		 * Endpoints is a collection of endpoints that implement the actual service. Example:
		 *   Name: "mysvc",
		 *   Subsets: [
		 *     {
		 *       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
		 *       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
		 *     },
		 *     {
		 *       Addresses: [{"ip": "10.10.3.3"}],
		 *       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
		 *     },
		 *  ]
		 */
		export interface Endpoints {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Endpoints'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * The set of all endpoints is the union of all subsets. Addresses are placed into subsets
			 * according to the IPs they share. A single address with multiple ports, some of which are
			 * ready and some of which are not (because they come from different containers) will result
			 * in the address being displayed in different subsets for the different ports. No address
			 * will appear in both Addresses and NotReadyAddresses in the same subset. Sets of addresses
			 * and ports that comprise a service.
			 */
			subsets?: core.v1.EndpointSubset[]
		}

		export function isEndpoints(o: any): o is Endpoints {
			return o.apiVersion == 'v1' && o.kind == 'Endpoints'
		}

		/**
		 * EndpointsList is a list of endpoints.
		 */
		export interface EndpointsList {
			/**
			 * List of endpoints.
			 */
			items: core.v1.Endpoints[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'EndpointsList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isEndpointsList(o: any): o is EndpointsList {
			return o.apiVersion == 'v1' && o.kind == 'EndpointsList'
		}

		/**
		 * EnvFromSource represents the source of a set of ConfigMaps
		 */
		export interface EnvFromSource {
			/**
			 * The ConfigMap to select from
			 */
			configMapRef?: core.v1.ConfigMapEnvSource

			/**
			 * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
			 */
			prefix?: string

			/**
			 * The Secret to select from
			 */
			secretRef?: core.v1.SecretEnvSource
		}

		/**
		 * EnvVar represents an environment variable present in a Container.
		 */
		export interface EnvVar {
			/**
			 * Name of the environment variable. Must be a C_IDENTIFIER.
			 */
			name: string

			/**
			 * Variable references $(VAR_NAME) are expanded using the previous defined environment
			 * variables in the container and any service environment variables. If a variable cannot be
			 * resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can
			 * be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
			 * regardless of whether the variable exists or not. Defaults to "".
			 */
			value?: string

			/**
			 * Source for the environment variable's value. Cannot be used if value is not empty.
			 */
			valueFrom?: core.v1.EnvVarSource
		}

		/**
		 * EnvVarSource represents a source for the value of an EnvVar.
		 */
		export interface EnvVarSource {
			/**
			 * Selects a key of a ConfigMap.
			 */
			configMapKeyRef?: core.v1.ConfigMapKeySelector

			/**
			 * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels,
			 * metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP,
			 * status.podIPs.
			 */
			fieldRef?: core.v1.ObjectFieldSelector

			/**
			 * Selects a resource of the container: only resources limits and requests (limits.cpu,
			 * limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and
			 * requests.ephemeral-storage) are currently supported.
			 */
			resourceFieldRef?: core.v1.ResourceFieldSelector

			/**
			 * Selects a key of a secret in the pod's namespace
			 */
			secretKeyRef?: core.v1.SecretKeySelector
		}

		/**
		 * An EphemeralContainer is a container that may be added temporarily to an existing pod for
		 * user-initiated activities such as debugging. Ephemeral containers have no resource or
		 * scheduling guarantees, and they will not be restarted when they exit or when a pod is removed
		 * or restarted. If an ephemeral container causes a pod to exceed its resource allocation, the
		 * pod may be evicted. Ephemeral containers may not be added by directly updating the pod spec.
		 * They must be added via the pod's ephemeralcontainers subresource, and they will appear in the
		 * pod spec once added. This is an alpha feature enabled by the EphemeralContainers feature
		 * flag.
		 */
		export interface EphemeralContainer {
			/**
			 * Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among
			 * all containers, init containers and ephemeral containers.
			 */
			name: string

			/**
			 * Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
			 * Variable references $(VAR_NAME) are expanded using the container's environment. If a
			 * variable cannot be resolved, the reference in the input string will be unchanged. The
			 * $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references
			 * will never be expanded, regardless of whether the variable exists or not. Cannot be
			 * updated. More info:
			 * https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
			 */
			args?: string[]

			/**
			 * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if
			 * this is not provided. Variable references $(VAR_NAME) are expanded using the container's
			 * environment. If a variable cannot be resolved, the reference in the input string will be
			 * unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
			 * Escaped references will never be expanded, regardless of whether the variable exists or
			 * not. Cannot be updated. More info:
			 * https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
			 */
			command?: string[]

			/**
			 * List of environment variables to set in the container. Cannot be updated.
			 */
			env?: core.v1.EnvVar[]

			/**
			 * List of sources to populate environment variables in the container. The keys defined within
			 * a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the
			 * container is starting. When a key exists in multiple sources, the value associated with the
			 * last source will take precedence. Values defined by an Env with a duplicate key will take
			 * precedence. Cannot be updated.
			 */
			envFrom?: core.v1.EnvFromSource[]

			/**
			 * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
			 */
			image?: string

			/**
			 * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is
			 * specified, or IfNotPresent otherwise. Cannot be updated. More info:
			 * https://kubernetes.io/docs/concepts/containers/images#updating-images
			 */
			imagePullPolicy?: string

			/**
			 * Lifecycle is not allowed for ephemeral containers.
			 */
			lifecycle?: core.v1.Lifecycle

			/**
			 * Probes are not allowed for ephemeral containers.
			 */
			livenessProbe?: core.v1.Probe

			/**
			 * Ports are not allowed for ephemeral containers.
			 */
			ports?: core.v1.ContainerPort[]

			/**
			 * Probes are not allowed for ephemeral containers.
			 */
			readinessProbe?: core.v1.Probe

			/**
			 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare
			 * resources already allocated to the pod.
			 */
			resources?: core.v1.ResourceRequirements

			/**
			 * SecurityContext is not allowed for ephemeral containers.
			 */
			securityContext?: core.v1.SecurityContext

			/**
			 * Probes are not allowed for ephemeral containers.
			 */
			startupProbe?: core.v1.Probe

			/**
			 * Whether this container should allocate a buffer for stdin in the container runtime. If this
			 * is not set, reads from stdin in the container will always result in EOF. Default is false.
			 */
			stdin?: boolean

			/**
			 * Whether the container runtime should close the stdin channel after it has been opened by a
			 * single attach. When stdin is true the stdin stream will remain open across multiple attach
			 * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until
			 * the first client attaches to stdin, and then remains open and accepts data until the client
			 * disconnects, at which time stdin is closed and remains closed until the container is
			 * restarted. If this flag is false, a container processes that reads from stdin will never
			 * receive an EOF. Default is false
			 */
			stdinOnce?: boolean

			/**
			 * If set, the name of the container from PodSpec that this ephemeral container targets. The
			 * ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not
			 * set then the ephemeral container is run in whatever namespaces are shared for the pod. Note
			 * that the container runtime must support this feature.
			 */
			targetContainerName?: string

			/**
			 * Optional: Path at which the file to which the container's termination message will be
			 * written is mounted into the container's filesystem. Message written is intended to be brief
			 * final status, such as an assertion failure message. Will be truncated by the node if
			 * greater than 4096 bytes. The total message length across all containers will be limited to
			 * 12kb. Defaults to /dev/termination-log. Cannot be updated.
			 */
			terminationMessagePath?: string

			/**
			 * Indicate how the termination message should be populated. File will use the contents of
			 * terminationMessagePath to populate the container status message on both success and
			 * failure. FallbackToLogsOnError will use the last chunk of container log output if the
			 * termination message file is empty and the container exited with an error. The log output is
			 * limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be
			 * updated.
			 */
			terminationMessagePolicy?: string

			/**
			 * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
			 * Default is false.
			 */
			tty?: boolean

			/**
			 * volumeDevices is the list of block devices to be used by the container. This is a beta
			 * feature.
			 */
			volumeDevices?: core.v1.VolumeDevice[]

			/**
			 * Pod volumes to mount into the container's filesystem. Cannot be updated.
			 */
			volumeMounts?: core.v1.VolumeMount[]

			/**
			 * Container's working directory. If not specified, the container runtime's default will be
			 * used, which might be configured in the container image. Cannot be updated.
			 */
			workingDir?: string
		}

		/**
		 * Event is a report of an event somewhere in the cluster.
		 */
		export interface Event {
			/**
			 * The object that this event is about.
			 */
			involvedObject: core.v1.ObjectReference

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata: meta.v1.ObjectMeta

			/**
			 * What action was taken/failed regarding to the Regarding object.
			 */
			action?: string

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * The number of times this event has occurred.
			 */
			count?: number

			/**
			 * Time when this Event was first observed.
			 */
			eventTime?: string

			/**
			 * The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
			 */
			firstTimestamp?: string

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Event'

			/**
			 * The time at which the most recent occurrence of this event was recorded.
			 */
			lastTimestamp?: string

			/**
			 * A human-readable description of the status of this operation.
			 */
			message?: string

			/**
			 * This should be a short, machine understandable string that gives the reason for the
			 * transition into the object's current status.
			 */
			reason?: string

			/**
			 * Optional secondary object for more complex actions.
			 */
			related?: core.v1.ObjectReference

			/**
			 * Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
			 */
			reportingComponent?: string

			/**
			 * ID of the controller instance, e.g. `kubelet-xyzf`.
			 */
			reportingInstance?: string

			/**
			 * Data about the Event series this event represents or nil if it's a singleton Event.
			 */
			series?: core.v1.EventSeries

			/**
			 * The component reporting this event. Should be a short machine understandable string.
			 */
			source?: core.v1.EventSource

			/**
			 * Type of this event (Normal, Warning), new types could be added in the future
			 */
			type?: string
		}

		export function isEvent(o: any): o is Event {
			return o.apiVersion == 'v1' && o.kind == 'Event'
		}

		/**
		 * EventList is a list of events.
		 */
		export interface EventList {
			/**
			 * List of events
			 */
			items: core.v1.Event[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'EventList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isEventList(o: any): o is EventList {
			return o.apiVersion == 'v1' && o.kind == 'EventList'
		}

		/**
		 * EventSeries contain information on series of events, i.e. thing that was/is happening
		 * continuously for some time.
		 */
		export interface EventSeries {
			/**
			 * Number of occurrences in this series up to the last heartbeat time
			 */
			count?: number

			/**
			 * Time of the last occurrence observed
			 */
			lastObservedTime?: string

			/**
			 * State of this Series: Ongoing or Finished Deprecated. Planned removal for 1.18
			 */
			state?: string
		}

		/**
		 * EventSource contains information for an event.
		 */
		export interface EventSource {
			/**
			 * Component from which the event is generated.
			 */
			component?: string

			/**
			 * Node name on which the event is generated.
			 */
			host?: string
		}

		/**
		 * ExecAction describes a "run in container" action.
		 */
		export interface ExecAction {
			/**
			 * Command is the command line to execute inside the container, the working directory for the
			 * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
			 * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a
			 * shell, you need to explicitly call out to that shell. Exit status of 0 is treated as
			 * live/healthy and non-zero is unhealthy.
			 */
			command?: string[]
		}

		/**
		 * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write
		 * once. Fibre Channel volumes support ownership management and SELinux relabeling.
		 */
		export interface FCVolumeSource {
			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
			 */
			fsType?: string

			/**
			 * Optional: FC target lun number
			 */
			lun?: number

			/**
			 * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts.
			 */
			readOnly?: boolean

			/**
			 * Optional: FC target worldwide names (WWNs)
			 */
			targetWWNs?: string[]

			/**
			 * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of
			 * targetWWNs and lun must be set, but not both simultaneously.
			 */
			wwids?: string[]
		}

		/**
		 * FlexPersistentVolumeSource represents a generic persistent volume resource that is
		 * provisioned/attached using an exec based plugin.
		 */
		export interface FlexPersistentVolumeSource {
			/**
			 * Driver is the name of the driver to use for this volume.
			 */
			driver: string

			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
			 */
			fsType?: string

			/**
			 * Optional: Extra command options if any.
			 */
			options?: { [key: string]: string }

			/**
			 * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts.
			 */
			readOnly?: boolean

			/**
			 * Optional: SecretRef is reference to the secret object containing sensitive information to
			 * pass to the plugin scripts. This may be empty if no secret object is specified. If the
			 * secret object contains more than one secret, all secrets are passed to the plugin scripts.
			 */
			secretRef?: core.v1.SecretReference
		}

		/**
		 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec
		 * based plugin.
		 */
		export interface FlexVolumeSource {
			/**
			 * Driver is the name of the driver to use for this volume.
			 */
			driver: string

			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
			 */
			fsType?: string

			/**
			 * Optional: Extra command options if any.
			 */
			options?: { [key: string]: string }

			/**
			 * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts.
			 */
			readOnly?: boolean

			/**
			 * Optional: SecretRef is reference to the secret object containing sensitive information to
			 * pass to the plugin scripts. This may be empty if no secret object is specified. If the
			 * secret object contains more than one secret, all secrets are passed to the plugin scripts.
			 */
			secretRef?: core.v1.LocalObjectReference
		}

		/**
		 * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and
		 * datasetUUID should be set. Flocker volumes do not support ownership management or SELinux
		 * relabeling.
		 */
		export interface FlockerVolumeSource {
			/**
			 * Name of the dataset stored as metadata -> name on the dataset for Flocker should be
			 * considered as deprecated
			 */
			datasetName?: string

			/**
			 * UUID of the dataset. This is unique identifier of a Flocker dataset
			 */
			datasetUUID?: string
		}

		/**
		 * Represents a Persistent Disk resource in Google Compute Engine.
		 *
		 * A GCE PD must exist before mounting to a container. The disk must also be in the same GCE
		 * project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only
		 * many times. GCE PDs support ownership management and SELinux relabeling.
		 */
		export interface GCEPersistentDiskVolumeSource {
			/**
			 * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
			 */
			pdName: string

			/**
			 * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type
			 * is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
			 * inferred to be "ext4" if unspecified. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
			 */
			fsType?: string

			/**
			 * The partition in the volume that you want to mount. If omitted, the default is to mount by
			 * volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly,
			 * the volume partition for /dev/sda is "0" (or you can leave the property empty). More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
			 */
			partition?: number

			/**
			 * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
			 * info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
			 */
			readOnly?: boolean
		}

		/**
		 * Represents a volume that is populated with the contents of a git repository. Git repo volumes
		 * do not support ownership management. Git repo volumes support SELinux relabeling.
		 *
		 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
		 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into
		 * the Pod's container.
		 */
		export interface GitRepoVolumeSource {
			/**
			 * Repository URL
			 */
			repository: string

			/**
			 * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume
			 * directory will be the git repository.  Otherwise, if specified, the volume will contain the
			 * git repository in the subdirectory with the given name.
			 */
			directory?: string

			/**
			 * Commit hash for the specified revision.
			 */
			revision?: string
		}

		/**
		 * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not
		 * support ownership management or SELinux relabeling.
		 */
		export interface GlusterfsPersistentVolumeSource {
			/**
			 * EndpointsName is the endpoint name that details Glusterfs topology. More info:
			 * https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
			 */
			endpoints: string

			/**
			 * Path is the Glusterfs volume path. More info:
			 * https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
			 */
			path: string

			/**
			 * EndpointsNamespace is the namespace that contains Glusterfs endpoint. If this field is
			 * empty, the EndpointNamespace defaults to the same namespace as the bound PVC. More info:
			 * https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
			 */
			endpointsNamespace?: string

			/**
			 * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
			 * Defaults to false. More info:
			 * https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
			 */
			readOnly?: boolean
		}

		/**
		 * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not
		 * support ownership management or SELinux relabeling.
		 */
		export interface GlusterfsVolumeSource {
			/**
			 * EndpointsName is the endpoint name that details Glusterfs topology. More info:
			 * https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
			 */
			endpoints: string

			/**
			 * Path is the Glusterfs volume path. More info:
			 * https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
			 */
			path: string

			/**
			 * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
			 * Defaults to false. More info:
			 * https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
			 */
			readOnly?: boolean
		}

		/**
		 * HTTPGetAction describes an action based on HTTP Get requests.
		 */
		export interface HTTPGetAction {
			/**
			 * Name or number of the port to access on the container. Number must be in the range 1 to
			 * 65535. Name must be an IANA_SVC_NAME.
			 */
			port: number | string

			/**
			 * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in
			 * httpHeaders instead.
			 */
			host?: string

			/**
			 * Custom headers to set in the request. HTTP allows repeated headers.
			 */
			httpHeaders?: core.v1.HTTPHeader[]

			/**
			 * Path to access on the HTTP server.
			 */
			path?: string

			/**
			 * Scheme to use for connecting to the host. Defaults to HTTP.
			 */
			scheme?: string
		}

		/**
		 * HTTPHeader describes a custom header to be used in HTTP probes
		 */
		export interface HTTPHeader {
			/**
			 * The header field name
			 */
			name: string

			/**
			 * The header field value
			 */
			value: string
		}

		/**
		 * Handler defines a specific action that should be taken
		 */
		export interface Handler {
			/**
			 * One and only one of the following should be specified. Exec specifies the action to take.
			 */
			exec?: core.v1.ExecAction

			/**
			 * HTTPGet specifies the http request to perform.
			 */
			httpGet?: core.v1.HTTPGetAction

			/**
			 * TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
			 */
			tcpSocket?: core.v1.TCPSocketAction
		}

		/**
		 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
		 * pod's hosts file.
		 */
		export interface HostAlias {
			/**
			 * Hostnames for the above IP address.
			 */
			hostnames?: string[]

			/**
			 * IP address of the host file entry.
			 */
			ip?: string
		}

		/**
		 * Represents a host path mapped into a pod. Host path volumes do not support ownership
		 * management or SELinux relabeling.
		 */
		export interface HostPathVolumeSource {
			/**
			 * Path of the directory on the host. If the path is a symlink, it will follow the link to the
			 * real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
			 */
			path: string

			/**
			 * Type for HostPath Volume Defaults to "" More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#hostpath
			 */
			type?: string
		}

		/**
		 * ISCSIPersistentVolumeSource represents an ISCSI disk. ISCSI volumes can only be mounted as
		 * read/write once. ISCSI volumes support ownership management and SELinux relabeling.
		 */
		export interface ISCSIPersistentVolumeSource {
			/**
			 * Target iSCSI Qualified Name.
			 */
			iqn: string

			/**
			 * iSCSI Target Lun number.
			 */
			lun: number

			/**
			 * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than
			 * default (typically TCP ports 860 and 3260).
			 */
			targetPortal: string

			/**
			 * whether support iSCSI Discovery CHAP authentication
			 */
			chapAuthDiscovery?: boolean

			/**
			 * whether support iSCSI Session CHAP authentication
			 */
			chapAuthSession?: boolean

			/**
			 * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type
			 * is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
			 * inferred to be "ext4" if unspecified. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#iscsi
			 */
			fsType?: string

			/**
			 * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface
			 * simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the
			 * connection.
			 */
			initiatorName?: string

			/**
			 * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
			 */
			iscsiInterface?: string

			/**
			 * iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port is other
			 * than default (typically TCP ports 860 and 3260).
			 */
			portals?: string[]

			/**
			 * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
			 */
			readOnly?: boolean

			/**
			 * CHAP Secret for iSCSI target and initiator authentication
			 */
			secretRef?: core.v1.SecretReference
		}

		/**
		 * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes
		 * support ownership management and SELinux relabeling.
		 */
		export interface ISCSIVolumeSource {
			/**
			 * Target iSCSI Qualified Name.
			 */
			iqn: string

			/**
			 * iSCSI Target Lun number.
			 */
			lun: number

			/**
			 * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than
			 * default (typically TCP ports 860 and 3260).
			 */
			targetPortal: string

			/**
			 * whether support iSCSI Discovery CHAP authentication
			 */
			chapAuthDiscovery?: boolean

			/**
			 * whether support iSCSI Session CHAP authentication
			 */
			chapAuthSession?: boolean

			/**
			 * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type
			 * is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
			 * inferred to be "ext4" if unspecified. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#iscsi
			 */
			fsType?: string

			/**
			 * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface
			 * simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the
			 * connection.
			 */
			initiatorName?: string

			/**
			 * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
			 */
			iscsiInterface?: string

			/**
			 * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other
			 * than default (typically TCP ports 860 and 3260).
			 */
			portals?: string[]

			/**
			 * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
			 */
			readOnly?: boolean

			/**
			 * CHAP Secret for iSCSI target and initiator authentication
			 */
			secretRef?: core.v1.LocalObjectReference
		}

		/**
		 * Maps a string key to a path within a volume.
		 */
		export interface KeyToPath {
			/**
			 * The key to project.
			 */
			key: string

			/**
			 * The relative path of the file to map the key to. May not be an absolute path. May not
			 * contain the path element '..'. May not start with the string '..'.
			 */
			path: string

			/**
			 * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not
			 * specified, the volume defaultMode will be used. This might be in conflict with other
			 * options that affect the file mode, like fsGroup, and the result can be other mode bits set.
			 */
			mode?: number
		}

		/**
		 * Lifecycle describes actions that the management system should take in response to container
		 * lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the
		 * container blocks until the action is complete, unless the container process fails, in which
		 * case the handler is aborted.
		 */
		export interface Lifecycle {
			/**
			 * PostStart is called immediately after a container is created. If the handler fails, the
			 * container is terminated and restarted according to its restart policy. Other management of
			 * the container blocks until the hook completes. More info:
			 * https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
			 */
			postStart?: core.v1.Handler

			/**
			 * PreStop is called immediately before a container is terminated due to an API request or
			 * management event such as liveness/startup probe failure, preemption, resource contention,
			 * etc. The handler is not called if the container crashes or exits. The reason for
			 * termination is passed to the handler. The Pod's termination grace period countdown begins
			 * before the PreStop hooked is executed. Regardless of the outcome of the handler, the
			 * container will eventually terminate within the Pod's termination grace period. Other
			 * management of the container blocks until the hook completes or until the termination grace
			 * period is reached. More info:
			 * https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
			 */
			preStop?: core.v1.Handler
		}

		/**
		 * LimitRange sets resource usage limits for each kind of resource in a Namespace.
		 */
		export interface LimitRange {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'LimitRange'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the limits enforced. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: core.v1.LimitRangeSpec
		}

		export function isLimitRange(o: any): o is LimitRange {
			return o.apiVersion == 'v1' && o.kind == 'LimitRange'
		}

		/**
		 * LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
		 */
		export interface LimitRangeItem {
			/**
			 * Default resource requirement limit value by resource name if resource limit is omitted.
			 */
			default?: object

			/**
			 * DefaultRequest is the default resource requirement request value by resource name if
			 * resource request is omitted.
			 */
			defaultRequest?: object

			/**
			 * Max usage constraints on this kind by resource name.
			 */
			max?: object

			/**
			 * MaxLimitRequestRatio if specified, the named resource must have a request and limit that
			 * are both non-zero where limit divided by request is less than or equal to the enumerated
			 * value; this represents the max burst for the named resource.
			 */
			maxLimitRequestRatio?: object

			/**
			 * Min usage constraints on this kind by resource name.
			 */
			min?: object

			/**
			 * Type of resource that this limit applies to.
			 */
			type?: string
		}

		/**
		 * LimitRangeList is a list of LimitRange items.
		 */
		export interface LimitRangeList {
			/**
			 * Items is a list of LimitRange objects. More info:
			 * https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
			 */
			items: core.v1.LimitRange[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'LimitRangeList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isLimitRangeList(o: any): o is LimitRangeList {
			return o.apiVersion == 'v1' && o.kind == 'LimitRangeList'
		}

		/**
		 * LimitRangeSpec defines a min/max usage limit for resources that match on kind.
		 */
		export interface LimitRangeSpec {
			/**
			 * Limits is the list of LimitRangeItem objects that are enforced.
			 */
			limits: core.v1.LimitRangeItem[]
		}

		/**
		 * LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended
		 * for the service should be sent to an ingress point.
		 */
		export interface LoadBalancerIngress {
			/**
			 * Hostname is set for load-balancer ingress points that are DNS based (typically AWS
			 * load-balancers)
			 */
			hostname?: string

			/**
			 * IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack
			 * load-balancers)
			 */
			ip?: string
		}

		/**
		 * LocalObjectReference contains enough information to let you locate the referenced object
		 * inside the same namespace.
		 */
		export interface LocalObjectReference {
			/**
			 * Name of the referent. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			 */
			name?: string
		}

		/**
		 * Local represents directly-attached storage with node affinity (Beta feature)
		 */
		export interface LocalVolumeSource {
			/**
			 * The full path to the volume on the node. It can be either a directory or block device
			 * (disk, partition, ...).
			 */
			path: string

			/**
			 * Filesystem type to mount. It applies only when the Path is a block device. Must be a
			 * filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The
			 * default value is to auto-select a fileystem if unspecified.
			 */
			fsType?: string
		}

		/**
		 * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support
		 * ownership management or SELinux relabeling.
		 */
		export interface NFSVolumeSource {
			/**
			 * Path that is exported by the NFS server. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#nfs
			 */
			path: string

			/**
			 * Server is the hostname or IP address of the NFS server. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#nfs
			 */
			server: string

			/**
			 * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults
			 * to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
			 */
			readOnly?: boolean
		}

		/**
		 * Namespace provides a scope for Names. Use of multiple namespaces is optional.
		 */
		export interface Namespace {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Namespace'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the behavior of the Namespace. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: core.v1.NamespaceSpec
		}

		export function isNamespace(o: any): o is Namespace {
			return o.apiVersion == 'v1' && o.kind == 'Namespace'
		}

		/**
		 * NamespaceCondition contains details about state of namespace.
		 */
		export interface NamespaceCondition {
			/**
			 * Type of namespace controller condition.
			 */
			type: string

			lastTransitionTime?: string

			message?: string

			reason?: string
		}

		/**
		 * NamespaceList is a list of Namespaces.
		 */
		export interface NamespaceList {
			/**
			 * Items is the list of Namespace objects in the list. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
			 */
			items: core.v1.Namespace[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'NamespaceList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isNamespaceList(o: any): o is NamespaceList {
			return o.apiVersion == 'v1' && o.kind == 'NamespaceList'
		}

		/**
		 * NamespaceSpec describes the attributes on a Namespace.
		 */
		export interface NamespaceSpec {
			/**
			 * Finalizers is an opaque list of values that must be empty to permanently remove object from
			 * storage. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
			 */
			finalizers?: string[]
		}

		/**
		 * Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache
		 * (i.e. in etcd).
		 */
		export interface Node {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Node'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the behavior of a node.
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: core.v1.NodeSpec
		}

		export function isNode(o: any): o is Node {
			return o.apiVersion == 'v1' && o.kind == 'Node'
		}

		/**
		 * NodeAddress contains information for the node's address.
		 */
		export interface NodeAddress {
			/**
			 * The node address.
			 */
			address: string

			/**
			 * Node address type, one of Hostname, ExternalIP or InternalIP.
			 */
			type: string
		}

		/**
		 * Node affinity is a group of node affinity scheduling rules.
		 */
		export interface NodeAffinity {
			/**
			 * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions
			 * specified by this field, but it may choose a node that violates one or more of the
			 * expressions. The node that is most preferred is the one with the greatest sum of weights,
			 * i.e. for each node that meets all of the scheduling requirements (resource request,
			 * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through
			 * the elements of this field and adding "weight" to the sum if the node matches the
			 * corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
			 */
			preferredDuringSchedulingIgnoredDuringExecution?: core.v1.PreferredSchedulingTerm[]

			/**
			 * If the affinity requirements specified by this field are not met at scheduling time, the
			 * pod will not be scheduled onto the node. If the affinity requirements specified by this
			 * field cease to be met at some point during pod execution (e.g. due to an update), the
			 * system may or may not try to eventually evict the pod from its node.
			 */
			requiredDuringSchedulingIgnoredDuringExecution?: core.v1.NodeSelector
		}

		/**
		 * NodeCondition contains condition information for a node.
		 */
		export interface NodeCondition {
			/**
			 * Type of node condition.
			 */
			type: string

			/**
			 * Last time we got an update on a given condition.
			 */
			lastHeartbeatTime?: string

			/**
			 * Last time the condition transit from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * Human readable message indicating details about last transition.
			 */
			message?: string

			/**
			 * (brief) reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding
		 * metadata) must be non-nil.
		 */
		export interface NodeConfigSource {
			/**
			 * ConfigMap is a reference to a Node's ConfigMap
			 */
			configMap?: core.v1.ConfigMapNodeConfigSource
		}

		/**
		 * NodeDaemonEndpoints lists ports opened by daemons running on the Node.
		 */
		export interface NodeDaemonEndpoints {
			/**
			 * Endpoint on which Kubelet is listening.
			 */
			kubeletEndpoint?: core.v1.DaemonEndpoint
		}

		/**
		 * NodeList is the whole list of all Nodes which have been registered with master.
		 */
		export interface NodeList {
			/**
			 * List of nodes
			 */
			items: core.v1.Node[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'NodeList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isNodeList(o: any): o is NodeList {
			return o.apiVersion == 'v1' && o.kind == 'NodeList'
		}

		/**
		 * A node selector represents the union of the results of one or more label queries over a set
		 * of nodes; that is, it represents the OR of the selectors represented by the node selector
		 * terms.
		 */
		export interface NodeSelector {
			/**
			 * Required. A list of node selector terms. The terms are ORed.
			 */
			nodeSelectorTerms: core.v1.NodeSelectorTerm[]
		}

		/**
		 * A node selector requirement is a selector that contains values, a key, and an operator that
		 * relates the key and values.
		 */
		export interface NodeSelectorRequirement {
			/**
			 * The label key that the selector applies to.
			 */
			key: string

			/**
			 * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists,
			 * DoesNotExist. Gt, and Lt.
			 */
			operator: string

			/**
			 * An array of string values. If the operator is In or NotIn, the values array must be
			 * non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If
			 * the operator is Gt or Lt, the values array must have a single element, which will be
			 * interpreted as an integer. This array is replaced during a strategic merge patch.
			 */
			values?: string[]
		}

		/**
		 * A null or empty node selector term matches no objects. The requirements of them are ANDed.
		 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
		 */
		export interface NodeSelectorTerm {
			/**
			 * A list of node selector requirements by node's labels.
			 */
			matchExpressions?: core.v1.NodeSelectorRequirement[]

			/**
			 * A list of node selector requirements by node's fields.
			 */
			matchFields?: core.v1.NodeSelectorRequirement[]
		}

		/**
		 * NodeSpec describes the attributes that a node is created with.
		 */
		export interface NodeSpec {
			/**
			 * If specified, the source to get node configuration from The DynamicKubeletConfig feature
			 * gate must be enabled for the Kubelet to use this field
			 */
			configSource?: core.v1.NodeConfigSource

			/**
			 * Deprecated. Not all kubelets will set this field. Remove field after 1.13. see:
			 * https://issues.k8s.io/61966
			 */
			externalID?: string

			/**
			 * PodCIDR represents the pod IP range assigned to the node.
			 */
			podCIDR?: string

			/**
			 * podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If
			 * this field is specified, the 0th entry must match the podCIDR field. It may contain at most
			 * 1 value for each of IPv4 and IPv6.
			 */
			podCIDRs?: string[]

			/**
			 * ID of the node assigned by the cloud provider in the format:
			 * <ProviderName>://<ProviderSpecificNodeID>
			 */
			providerID?: string

			/**
			 * If specified, the node's taints.
			 */
			taints?: core.v1.Taint[]

			/**
			 * Unschedulable controls node schedulability of new pods. By default, node is schedulable.
			 * More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
			 */
			unschedulable?: boolean
		}

		/**
		 * NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
		 */
		export interface NodeSystemInfo {
			/**
			 * The Architecture reported by the node
			 */
			architecture: string

			/**
			 * Boot ID reported by the node.
			 */
			bootID: string

			/**
			 * ContainerRuntime Version reported by the node through runtime remote API (e.g.
			 * docker://1.5.0).
			 */
			containerRuntimeVersion: string

			/**
			 * Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
			 */
			kernelVersion: string

			/**
			 * KubeProxy Version reported by the node.
			 */
			kubeProxyVersion: string

			/**
			 * Kubelet Version reported by the node.
			 */
			kubeletVersion: string

			/**
			 * MachineID reported by the node. For unique machine identification in the cluster this field
			 * is preferred. Learn more from man(5) machine-id:
			 * http://man7.org/linux/man-pages/man5/machine-id.5.html
			 */
			machineID: string

			/**
			 * The Operating System reported by the node
			 */
			operatingSystem: string

			/**
			 * OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
			 */
			osImage: string

			/**
			 * SystemUUID reported by the node. For unique machine identification MachineID is preferred.
			 * This field is specific to Red Hat hosts
			 * https://access.redhat.com/documentation/en-US/Red_Hat_Subscription_Management/1/html/RHSM/getting-system-uuid.html
			 */
			systemUUID: string
		}

		/**
		 * ObjectFieldSelector selects an APIVersioned field of an object.
		 */
		export interface ObjectFieldSelector {
			/**
			 * Path of the field to select in the specified API version.
			 */
			fieldPath: string

			/**
			 * Version of the schema the FieldPath is written in terms of, defaults to "v1".
			 */
			apiVersion?: string
		}

		export function isObjectFieldSelector(o: any): o is ObjectFieldSelector {
			return o.apiVersion == 'core/v1' && o.kind == 'ObjectFieldSelector'
		}

		/**
		 * ObjectReference contains enough information to let you inspect or modify the referred object.
		 */
		export interface ObjectReference {
			/**
			 * API version of the referent.
			 */
			apiVersion?: string

			/**
			 * If referring to a piece of an object instead of an entire object, this string should
			 * contain a valid JSON/Go field access statement, such as
			 * desiredState.manifest.containers[2]. For example, if the object reference is to a container
			 * within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers
			 * to the name of the container that triggered the event) or if no container name is specified
			 * "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to
			 * have some well-defined way of referencing a part of an object.
			 */
			fieldPath?: string

			/**
			 * Kind of the referent. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string

			/**
			 * Name of the referent. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			 */
			name?: string

			/**
			 * Namespace of the referent. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
			 */
			namespace?: string

			/**
			 * Specific resourceVersion to which this reference is made, if any. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
			 */
			resourceVersion?: string

			/**
			 * UID of the referent. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
			 */
			uid?: string
		}

		export function isObjectReference(o: any): o is ObjectReference {
			return o.apiVersion == 'core/v1' && o.kind == 'ObjectReference'
		}

		/**
		 * PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous
		 * to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
		 */
		export interface PersistentVolume {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PersistentVolume'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines a specification of a persistent volume owned by the cluster. Provisioned by an
			 * administrator. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
			 */
			spec?: core.v1.PersistentVolumeSpec
		}

		export function isPersistentVolume(o: any): o is PersistentVolume {
			return o.apiVersion == 'v1' && o.kind == 'PersistentVolume'
		}

		/**
		 * PersistentVolumeClaim is a user's request for and claim to a persistent volume
		 */
		export interface PersistentVolumeClaim {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PersistentVolumeClaim'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the desired characteristics of a volume requested by a pod author. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
			 */
			spec?: core.v1.PersistentVolumeClaimSpec
		}

		export function isPersistentVolumeClaim(
			o: any
		): o is PersistentVolumeClaim {
			return o.apiVersion == 'v1' && o.kind == 'PersistentVolumeClaim'
		}

		/**
		 * PersistentVolumeClaimCondition contails details about state of pvc
		 */
		export interface PersistentVolumeClaimCondition {
			type: string

			/**
			 * Last time we probed the condition.
			 */
			lastProbeTime?: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * Human-readable message indicating details about last transition.
			 */
			message?: string

			/**
			 * Unique, this should be a short, machine understandable string that gives the reason for
			 * condition's last transition. If it reports "ResizeStarted" that means the underlying
			 * persistent volume is being resized.
			 */
			reason?: string
		}

		/**
		 * PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
		 */
		export interface PersistentVolumeClaimList {
			/**
			 * A list of persistent volume claims. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
			 */
			items: core.v1.PersistentVolumeClaim[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PersistentVolumeClaimList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isPersistentVolumeClaimList(
			o: any
		): o is PersistentVolumeClaimList {
			return o.apiVersion == 'v1' && o.kind == 'PersistentVolumeClaimList'
		}

		/**
		 * PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a
		 * Source for provider-specific attributes
		 */
		export interface PersistentVolumeClaimSpec {
			/**
			 * AccessModes contains the desired access modes the volume should have. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
			 */
			accessModes?: string[]

			/**
			 * This field requires the VolumeSnapshotDataSource alpha feature gate to be enabled and
			 * currently VolumeSnapshot is the only supported data source. If the provisioner can support
			 * VolumeSnapshot data source, it will create a new volume and data will be restored to the
			 * volume at the same time. If the provisioner does not support VolumeSnapshot data source,
			 * volume will not be created and the failure will be reported as an event. In the future, we
			 * plan to support more data source types and the behavior of the provisioner may change.
			 */
			dataSource?: core.v1.TypedLocalObjectReference

			/**
			 * Resources represents the minimum resources the volume should have. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
			 */
			resources?: core.v1.ResourceRequirements

			/**
			 * A label query over volumes to consider for binding.
			 */
			selector?: meta.v1.LabelSelector

			/**
			 * Name of the StorageClass required by the claim. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
			 */
			storageClassName?: string

			/**
			 * volumeMode defines what type of volume is required by the claim. Value of Filesystem is
			 * implied when not included in claim spec. This is a beta feature.
			 */
			volumeMode?: string

			/**
			 * VolumeName is the binding reference to the PersistentVolume backing this claim.
			 */
			volumeName?: string
		}

		/**
		 * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This
		 * volume finds the bound PV and mounts that volume for the pod. A
		 * PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume
		 * that is owned by someone else (the system).
		 */
		export interface PersistentVolumeClaimVolumeSource {
			/**
			 * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using
			 * this volume. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
			 */
			claimName: string

			/**
			 * Will force the ReadOnly setting in VolumeMounts. Default false.
			 */
			readOnly?: boolean
		}

		/**
		 * PersistentVolumeList is a list of PersistentVolume items.
		 */
		export interface PersistentVolumeList {
			/**
			 * List of persistent volumes. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes
			 */
			items: core.v1.PersistentVolume[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PersistentVolumeList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isPersistentVolumeList(o: any): o is PersistentVolumeList {
			return o.apiVersion == 'v1' && o.kind == 'PersistentVolumeList'
		}

		/**
		 * PersistentVolumeSpec is the specification of a persistent volume.
		 */
		export interface PersistentVolumeSpec {
			/**
			 * AccessModes contains all ways the volume can be mounted. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
			 */
			accessModes?: string[]

			/**
			 * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host
			 * machine and then exposed to the pod. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
			 */
			awsElasticBlockStore?: core.v1.AWSElasticBlockStoreVolumeSource

			/**
			 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
			 */
			azureDisk?: core.v1.AzureDiskVolumeSource

			/**
			 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
			 */
			azureFile?: core.v1.AzureFilePersistentVolumeSource

			/**
			 * A description of the persistent volume's resources and capacity. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
			 */
			capacity?: object

			/**
			 * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
			 */
			cephfs?: core.v1.CephFSPersistentVolumeSource

			/**
			 * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info:
			 * https://examples.k8s.io/mysql-cinder-pd/README.md
			 */
			cinder?: core.v1.CinderPersistentVolumeSource

			/**
			 * ClaimRef is part of a bi-directional binding between PersistentVolume and
			 * PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the
			 * authoritative bind between PV and PVC. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
			 */
			claimRef?: core.v1.ObjectReference

			/**
			 * CSI represents storage that is handled by an external CSI driver (Beta feature).
			 */
			csi?: core.v1.CSIPersistentVolumeSource

			/**
			 * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and
			 * then exposed to the pod.
			 */
			fc?: core.v1.FCVolumeSource

			/**
			 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec
			 * based plugin.
			 */
			flexVolume?: core.v1.FlexPersistentVolumeSource

			/**
			 * Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the
			 * pod for its usage. This depends on the Flocker control service being running
			 */
			flocker?: core.v1.FlockerVolumeSource

			/**
			 * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host
			 * machine and then exposed to the pod. Provisioned by an admin. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
			 */
			gcePersistentDisk?: core.v1.GCEPersistentDiskVolumeSource

			/**
			 * Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod.
			 * Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md
			 */
			glusterfs?: core.v1.GlusterfsPersistentVolumeSource

			/**
			 * HostPath represents a directory on the host. Provisioned by a developer or tester. This is
			 * useful for single-node development and testing only! On-host storage is not supported in
			 * any way and WILL NOT WORK in a multi-node cluster. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#hostpath
			 */
			hostPath?: core.v1.HostPathVolumeSource

			/**
			 * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and
			 * then exposed to the pod. Provisioned by an admin.
			 */
			iscsi?: core.v1.ISCSIPersistentVolumeSource

			/**
			 * Local represents directly-attached storage with node affinity
			 */
			local?: core.v1.LocalVolumeSource

			/**
			 * A list of mount options, e.g. ["ro", "soft"]. Not validated - mount will simply fail if one
			 * is invalid. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
			 */
			mountOptions?: string[]

			/**
			 * NFS represents an NFS mount on the host. Provisioned by an admin. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#nfs
			 */
			nfs?: core.v1.NFSVolumeSource

			/**
			 * NodeAffinity defines constraints that limit what nodes this volume can be accessed from.
			 * This field influences the scheduling of pods that use this volume.
			 */
			nodeAffinity?: core.v1.VolumeNodeAffinity

			/**
			 * What happens to a persistent volume when released from its claim. Valid options are Retain
			 * (default for manually created PersistentVolumes), Delete (default for dynamically
			 * provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the
			 * volume plugin underlying this PersistentVolume. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
			 */
			persistentVolumeReclaimPolicy?: string

			/**
			 * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on
			 * kubelets host machine
			 */
			photonPersistentDisk?: core.v1.PhotonPersistentDiskVolumeSource

			/**
			 * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
			 */
			portworxVolume?: core.v1.PortworxVolumeSource

			/**
			 * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
			 */
			quobyte?: core.v1.QuobyteVolumeSource

			/**
			 * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More
			 * info: https://examples.k8s.io/volumes/rbd/README.md
			 */
			rbd?: core.v1.RBDPersistentVolumeSource

			/**
			 * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
			 */
			scaleIO?: core.v1.ScaleIOPersistentVolumeSource

			/**
			 * Name of StorageClass to which this persistent volume belongs. Empty value means that this
			 * volume does not belong to any StorageClass.
			 */
			storageClassName?: string

			/**
			 * StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and
			 * mounted into the pod More info: https://examples.k8s.io/volumes/storageos/README.md
			 */
			storageos?: core.v1.StorageOSPersistentVolumeSource

			/**
			 * volumeMode defines if a volume is intended to be used with a formatted filesystem or to
			 * remain in raw block state. Value of Filesystem is implied when not included in spec. This
			 * is a beta feature.
			 */
			volumeMode?: string

			/**
			 * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
			 */
			vsphereVolume?: core.v1.VsphereVirtualDiskVolumeSource
		}

		/**
		 * Represents a Photon Controller persistent disk resource.
		 */
		export interface PhotonPersistentDiskVolumeSource {
			/**
			 * ID that identifies Photon Controller persistent disk
			 */
			pdID: string

			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
			 */
			fsType?: string
		}

		/**
		 * Pod is a collection of containers that can run on a host. This resource is created by clients
		 * and scheduled onto hosts.
		 */
		export interface Pod {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Pod'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of the pod. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: core.v1.PodSpec
		}

		export function isPod(o: any): o is Pod {
			return o.apiVersion == 'v1' && o.kind == 'Pod'
		}

		/**
		 * Pod affinity is a group of inter pod affinity scheduling rules.
		 */
		export interface PodAffinity {
			/**
			 * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions
			 * specified by this field, but it may choose a node that violates one or more of the
			 * expressions. The node that is most preferred is the one with the greatest sum of weights,
			 * i.e. for each node that meets all of the scheduling requirements (resource request,
			 * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through
			 * the elements of this field and adding "weight" to the sum if the node has pods which
			 * matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most
			 * preferred.
			 */
			preferredDuringSchedulingIgnoredDuringExecution?: core.v1.WeightedPodAffinityTerm[]

			/**
			 * If the affinity requirements specified by this field are not met at scheduling time, the
			 * pod will not be scheduled onto the node. If the affinity requirements specified by this
			 * field cease to be met at some point during pod execution (e.g. due to a pod label update),
			 * the system may or may not try to eventually evict the pod from its node. When there are
			 * multiple elements, the lists of nodes corresponding to each podAffinityTerm are
			 * intersected, i.e. all terms must be satisfied.
			 */
			requiredDuringSchedulingIgnoredDuringExecution?: core.v1.PodAffinityTerm[]
		}

		/**
		 * Defines a set of pods (namely those matching the labelSelector relative to the given
		 * namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity)
		 * with, where co-located is defined as running on a node whose value of the label with key
		 * <topologyKey> matches that of any node on which a pod of the set of pods is running
		 */
		export interface PodAffinityTerm {
			/**
			 * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods
			 * matching the labelSelector in the specified namespaces, where co-located is defined as
			 * running on a node whose value of the label with key topologyKey matches that of any node on
			 * which any of the selected pods is running. Empty topologyKey is not allowed.
			 */
			topologyKey: string

			/**
			 * A label query over a set of resources, in this case pods.
			 */
			labelSelector?: meta.v1.LabelSelector

			/**
			 * namespaces specifies which namespaces the labelSelector applies to (matches against); null
			 * or empty list means "this pod's namespace"
			 */
			namespaces?: string[]
		}

		/**
		 * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
		 */
		export interface PodAntiAffinity {
			/**
			 * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity
			 * expressions specified by this field, but it may choose a node that violates one or more of
			 * the expressions. The node that is most preferred is the one with the greatest sum of
			 * weights, i.e. for each node that meets all of the scheduling requirements (resource
			 * request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by
			 * iterating through the elements of this field and adding "weight" to the sum if the node has
			 * pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are
			 * the most preferred.
			 */
			preferredDuringSchedulingIgnoredDuringExecution?: core.v1.WeightedPodAffinityTerm[]

			/**
			 * If the anti-affinity requirements specified by this field are not met at scheduling time,
			 * the pod will not be scheduled onto the node. If the anti-affinity requirements specified by
			 * this field cease to be met at some point during pod execution (e.g. due to a pod label
			 * update), the system may or may not try to eventually evict the pod from its node. When
			 * there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are
			 * intersected, i.e. all terms must be satisfied.
			 */
			requiredDuringSchedulingIgnoredDuringExecution?: core.v1.PodAffinityTerm[]
		}

		/**
		 * PodCondition contains details for the current condition of this pod.
		 */
		export interface PodCondition {
			/**
			 * Type is the type of the condition. More info:
			 * https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
			 */
			type: string

			/**
			 * Last time we probed the condition.
			 */
			lastProbeTime?: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * Human-readable message indicating details about last transition.
			 */
			message?: string

			/**
			 * Unique, one-word, CamelCase reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * PodDNSConfig defines the DNS parameters of a pod in addition to those generated from
		 * DNSPolicy.
		 */
		export interface PodDNSConfig {
			/**
			 * A list of DNS name server IP addresses. This will be appended to the base nameservers
			 * generated from DNSPolicy. Duplicated nameservers will be removed.
			 */
			nameservers?: string[]

			/**
			 * A list of DNS resolver options. This will be merged with the base options generated from
			 * DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will
			 * override those that appear in the base DNSPolicy.
			 */
			options?: core.v1.PodDNSConfigOption[]

			/**
			 * A list of DNS search domains for host-name lookup. This will be appended to the base search
			 * paths generated from DNSPolicy. Duplicated search paths will be removed.
			 */
			searches?: string[]
		}

		/**
		 * PodDNSConfigOption defines DNS resolver options of a pod.
		 */
		export interface PodDNSConfigOption {
			/**
			 * Required.
			 */
			name?: string

			value?: string
		}

		/**
		 * IP address information for entries in the (plural) PodIPs field. Each entry includes:
		 *    IP: An IP address allocated to the pod. Routable at least within the cluster.
		 */
		export interface PodIP {
			/**
			 * ip is an IP address (IPv4 or IPv6) assigned to the pod
			 */
			ip?: string
		}

		/**
		 * PodList is a list of Pods.
		 */
		export interface PodList {
			/**
			 * List of pods. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
			 */
			items: core.v1.Pod[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PodList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isPodList(o: any): o is PodList {
			return o.apiVersion == 'v1' && o.kind == 'PodList'
		}

		/**
		 * PodReadinessGate contains the reference to a pod condition
		 */
		export interface PodReadinessGate {
			/**
			 * ConditionType refers to a condition in the pod's condition list with matching type.
			 */
			conditionType: string
		}

		/**
		 * PodSecurityContext holds pod-level security attributes and common container settings. Some
		 * fields are also present in container.securityContext.  Field values of
		 * container.securityContext take precedence over field values of PodSecurityContext.
		 */
		export interface PodSecurityContext {
			/**
			 * A special supplemental group that applies to all containers in a pod. Some volume types
			 * allow the Kubelet to change the ownership of that volume to be owned by the pod:
			 *
			 * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the
			 * volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
			 *
			 * If unset, the Kubelet will not modify the ownership and permissions of any volume.
			 */
			fsGroup?: number

			/**
			 * The GID to run the entrypoint of the container process. Uses runtime default if unset. May
			 * also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the
			 * value specified in SecurityContext takes precedence for that container.
			 */
			runAsGroup?: number

			/**
			 * Indicates that the container must run as a non-root user. If true, the Kubelet will
			 * validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to
			 * start the container if it does. If unset or false, no such validation will be performed.
			 * May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext,
			 * the value specified in SecurityContext takes precedence.
			 */
			runAsNonRoot?: boolean

			/**
			 * The UID to run the entrypoint of the container process. Defaults to user specified in image
			 * metadata if unspecified. May also be set in SecurityContext.  If set in both
			 * SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
			 * precedence for that container.
			 */
			runAsUser?: number

			/**
			 * The SELinux context to be applied to all containers. If unspecified, the container runtime
			 * will allocate a random SELinux context for each container.  May also be set in
			 * SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value
			 * specified in SecurityContext takes precedence for that container.
			 */
			seLinuxOptions?: core.v1.SELinuxOptions

			/**
			 * A list of groups applied to the first process run in each container, in addition to the
			 * container's primary GID.  If unspecified, no groups will be added to any container.
			 */
			supplementalGroups?: number[]

			/**
			 * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls
			 * (by the container runtime) might fail to launch.
			 */
			sysctls?: core.v1.Sysctl[]

			/**
			 * The Windows specific settings applied to all containers. If unspecified, the options within
			 * a container's SecurityContext will be used. If set in both SecurityContext and
			 * PodSecurityContext, the value specified in SecurityContext takes precedence.
			 */
			windowsOptions?: core.v1.WindowsSecurityContextOptions
		}

		/**
		 * PodSpec is a description of a pod.
		 */
		export interface PodSpec {
			/**
			 * List of containers belonging to the pod. Containers cannot currently be added or removed.
			 * There must be at least one container in a Pod. Cannot be updated.
			 */
			containers: core.v1.Container[]

			/**
			 * Optional duration in seconds the pod may be active on the node relative to StartTime before
			 * the system will actively try to mark it failed and kill associated containers. Value must
			 * be a positive integer.
			 */
			activeDeadlineSeconds?: number

			/**
			 * If specified, the pod's scheduling constraints
			 */
			affinity?: core.v1.Affinity

			/**
			 * AutomountServiceAccountToken indicates whether a service account token should be
			 * automatically mounted.
			 */
			automountServiceAccountToken?: boolean

			/**
			 * Specifies the DNS parameters of a pod. Parameters specified here will be merged to the
			 * generated DNS configuration based on DNSPolicy.
			 */
			dnsConfig?: core.v1.PodDNSConfig

			/**
			 * Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are
			 * 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in
			 * DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set
			 * along with hostNetwork, you have to specify DNS policy explicitly to
			 * 'ClusterFirstWithHostNet'.
			 */
			dnsPolicy?: string

			/**
			 * EnableServiceLinks indicates whether information about services should be injected into
			 * pod's environment variables, matching the syntax of Docker links. Optional: Defaults to
			 * true.
			 */
			enableServiceLinks?: boolean

			/**
			 * List of ephemeral containers run in this pod. Ephemeral containers may be run in an
			 * existing pod to perform user-initiated actions such as debugging. This list cannot be
			 * specified when creating a pod, and it cannot be modified by updating the pod spec. In order
			 * to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers
			 * subresource. This field is alpha-level and is only honored by servers that enable the
			 * EphemeralContainers feature.
			 */
			ephemeralContainers?: core.v1.EphemeralContainer[]

			/**
			 * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
			 * file if specified. This is only valid for non-hostNetwork pods.
			 */
			hostAliases?: core.v1.HostAlias[]

			/**
			 * Use the host's ipc namespace. Optional: Default to false.
			 */
			hostIPC?: boolean

			/**
			 * Host networking requested for this pod. Use the host's network namespace. If this option is
			 * set, the ports that will be used must be specified. Default to false.
			 */
			hostNetwork?: boolean

			/**
			 * Use the host's pid namespace. Optional: Default to false.
			 */
			hostPID?: boolean

			/**
			 * Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a
			 * system-defined value.
			 */
			hostname?: string

			/**
			 * ImagePullSecrets is an optional list of references to secrets in the same namespace to use
			 * for pulling any of the images used by this PodSpec. If specified, these secrets will be
			 * passed to individual puller implementations for them to use. For example, in the case of
			 * docker, only DockerConfig type secrets are honored. More info:
			 * https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
			 */
			imagePullSecrets?: core.v1.LocalObjectReference[]

			/**
			 * List of initialization containers belonging to the pod. Init containers are executed in
			 * order prior to containers being started. If any init container fails, the pod is considered
			 * to have failed and is handled according to its restartPolicy. The name for an init
			 * container or normal container must be unique among all containers. Init containers may not
			 * have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The
			 * resourceRequirements of an init container are taken into account during scheduling by
			 * finding the highest request/limit for each resource type, and then using the max of of that
			 * value or the sum of the normal containers. Limits are applied to init containers in a
			 * similar fashion. Init containers cannot currently be added or removed. Cannot be updated.
			 * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
			 */
			initContainers?: core.v1.Container[]

			/**
			 * NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the
			 * scheduler simply schedules this pod onto that node, assuming that it fits resource
			 * requirements.
			 */
			nodeName?: string

			/**
			 * NodeSelector is a selector which must be true for the pod to fit on a node. Selector which
			 * must match a node's labels for the pod to be scheduled on that node. More info:
			 * https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
			 */
			nodeSelector?: { [key: string]: string }

			/**
			 * Overhead represents the resource overhead associated with running a pod for a given
			 * RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass
			 * admission controller. If the RuntimeClass admission controller is enabled, overhead must
			 * not be set in Pod create requests. The RuntimeClass admission controller will reject Pod
			 * create requests which have the overhead already set. If RuntimeClass is configured and
			 * selected in the PodSpec, Overhead will be set to the value defined in the corresponding
			 * RuntimeClass, otherwise it will remain unset and treated as zero. More info:
			 * https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
			 * alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the
			 * PodOverhead feature.
			 */
			overhead?: object

			/**
			 * PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
			 * PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is alpha-level
			 * and is only honored by servers that enable the NonPreemptingPriority feature.
			 */
			preemptionPolicy?: string

			/**
			 * The priority value. Various system components use this field to find the priority of the
			 * pod. When Priority Admission Controller is enabled, it prevents users from setting this
			 * field. The admission controller populates this field from PriorityClassName. The higher the
			 * value, the higher the priority.
			 */
			priority?: number

			/**
			 * If specified, indicates the pod's priority. "system-node-critical" and
			 * "system-cluster-critical" are two special keywords which indicate the highest priorities
			 * with the former being the highest priority. Any other name must be defined by creating a
			 * PriorityClass object with that name. If not specified, the pod priority will be default or
			 * zero if there is no default.
			 */
			priorityClassName?: string

			/**
			 * If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when
			 * all its containers are ready AND all conditions specified in the readiness gates have
			 * status equal to "True" More info:
			 * https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
			 */
			readinessGates?: core.v1.PodReadinessGate[]

			/**
			 * Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default
			 * to Always. More info:
			 * https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
			 */
			restartPolicy?: string

			/**
			 * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be
			 * used to run this pod.  If no RuntimeClass resource matches the named class, the pod will
			 * not be run. If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
			 * class with an empty definition that uses the default runtime handler. More info:
			 * https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md This is a beta feature as of
			 * Kubernetes v1.14.
			 */
			runtimeClassName?: string

			/**
			 * If specified, the pod will be dispatched by specified scheduler. If not specified, the pod
			 * will be dispatched by default scheduler.
			 */
			schedulerName?: string

			/**
			 * SecurityContext holds pod-level security attributes and common container settings.
			 * Optional: Defaults to empty.  See type description for default values of each field.
			 */
			securityContext?: core.v1.PodSecurityContext

			/**
			 * DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use
			 * serviceAccountName instead.
			 */
			serviceAccount?: string

			/**
			 * ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info:
			 * https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
			 */
			serviceAccountName?: string

			/**
			 * Share a single process namespace between all of the containers in a pod. When this is set
			 * containers will be able to view and signal processes from other containers in the same pod,
			 * and the first process in each container will not be assigned PID 1. HostPID and
			 * ShareProcessNamespace cannot both be set. Optional: Default to false.
			 */
			shareProcessNamespace?: boolean

			/**
			 * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod
			 * namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at
			 * all.
			 */
			subdomain?: string

			/**
			 * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in
			 * delete request. Value must be non-negative integer. The value zero indicates delete
			 * immediately. If this value is nil, the default grace period will be used instead. The grace
			 * period is the duration in seconds after the processes running in the pod are sent a
			 * termination signal and the time when the processes are forcibly halted with a kill signal.
			 * Set this value longer than the expected cleanup time for your process. Defaults to 30
			 * seconds.
			 */
			terminationGracePeriodSeconds?: number

			/**
			 * If specified, the pod's tolerations.
			 */
			tolerations?: core.v1.Toleration[]

			/**
			 * TopologySpreadConstraints describes how a group of pods ought to spread across topology
			 * domains. Scheduler will schedule pods in a way which abides by the constraints. This field
			 * is alpha-level and is only honored by clusters that enables the EvenPodsSpread feature. All
			 * topologySpreadConstraints are ANDed.
			 */
			topologySpreadConstraints?: core.v1.TopologySpreadConstraint[]

			/**
			 * List of volumes that can be mounted by containers belonging to the pod. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes
			 */
			volumes?: core.v1.Volume[]
		}

		/**
		 * PodTemplate describes a template for creating copies of a predefined pod.
		 */
		export interface PodTemplate {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PodTemplate'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Template defines the pods that will be created from this pod template.
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			template?: core.v1.PodTemplateSpec
		}

		export function isPodTemplate(o: any): o is PodTemplate {
			return o.apiVersion == 'v1' && o.kind == 'PodTemplate'
		}

		/**
		 * PodTemplateList is a list of PodTemplates.
		 */
		export interface PodTemplateList {
			/**
			 * List of pod templates
			 */
			items: core.v1.PodTemplate[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PodTemplateList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isPodTemplateList(o: any): o is PodTemplateList {
			return o.apiVersion == 'v1' && o.kind == 'PodTemplateList'
		}

		/**
		 * PodTemplateSpec describes the data a pod should have when created from a template
		 */
		export interface PodTemplateSpec {
			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of the pod. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: core.v1.PodSpec
		}

		/**
		 * PortworxVolumeSource represents a Portworx volume resource.
		 */
		export interface PortworxVolumeSource {
			/**
			 * VolumeID uniquely identifies a Portworx volume
			 */
			volumeID: string

			/**
			 * FSType represents the filesystem type to mount Must be a filesystem type supported by the
			 * host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
			 */
			fsType?: string

			/**
			 * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts.
			 */
			readOnly?: boolean
		}

		/**
		 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a
		 * no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
		 */
		export interface PreferredSchedulingTerm {
			/**
			 * A node selector term, associated with the corresponding weight.
			 */
			preference: core.v1.NodeSelectorTerm

			/**
			 * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
			 */
			weight: number
		}

		/**
		 * Probe describes a health check to be performed against a container to determine whether it is
		 * alive or ready to receive traffic.
		 */
		export interface Probe {
			/**
			 * One and only one of the following should be specified. Exec specifies the action to take.
			 */
			exec?: core.v1.ExecAction

			/**
			 * Minimum consecutive failures for the probe to be considered failed after having succeeded.
			 * Defaults to 3. Minimum value is 1.
			 */
			failureThreshold?: number

			/**
			 * HTTPGet specifies the http request to perform.
			 */
			httpGet?: core.v1.HTTPGetAction

			/**
			 * Number of seconds after the container has started before liveness probes are initiated.
			 * More info:
			 * https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			 */
			initialDelaySeconds?: number

			/**
			 * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
			 */
			periodSeconds?: number

			/**
			 * Minimum consecutive successes for the probe to be considered successful after having
			 * failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
			 */
			successThreshold?: number

			/**
			 * TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
			 */
			tcpSocket?: core.v1.TCPSocketAction

			/**
			 * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is
			 * 1. More info:
			 * https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			 */
			timeoutSeconds?: number
		}

		/**
		 * Represents a projected volume source
		 */
		export interface ProjectedVolumeSource {
			/**
			 * list of volume projections
			 */
			sources: core.v1.VolumeProjection[]

			/**
			 * Mode bits to use on created files by default. Must be a value between 0 and 0777.
			 * Directories within the path are not affected by this setting. This might be in conflict
			 * with other options that affect the file mode, like fsGroup, and the result can be other
			 * mode bits set.
			 */
			defaultMode?: number
		}

		/**
		 * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support
		 * ownership management or SELinux relabeling.
		 */
		export interface QuobyteVolumeSource {
			/**
			 * Registry represents a single or multiple Quobyte Registry services specified as a string as
			 * host:port pair (multiple entries are separated with commas) which acts as the central
			 * registry for volumes
			 */
			registry: string

			/**
			 * Volume is a string that references an already created Quobyte volume by name.
			 */
			volume: string

			/**
			 * Group to map volume access to Default is no group
			 */
			group?: string

			/**
			 * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
			 * Defaults to false.
			 */
			readOnly?: boolean

			/**
			 * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned
			 * Quobyte volumes, value is set by the plugin
			 */
			tenant?: string

			/**
			 * User to map volume access to Defaults to serivceaccount user
			 */
			user?: string
		}

		/**
		 * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support
		 * ownership management and SELinux relabeling.
		 */
		export interface RBDPersistentVolumeSource {
			/**
			 * The rados image name. More info:
			 * https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			image: string

			/**
			 * A collection of Ceph monitors. More info:
			 * https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			monitors: string[]

			/**
			 * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type
			 * is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
			 * inferred to be "ext4" if unspecified. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#rbd
			 */
			fsType?: string

			/**
			 * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info:
			 * https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			keyring?: string

			/**
			 * The rados pool name. Default is rbd. More info:
			 * https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			pool?: string

			/**
			 * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
			 * info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			readOnly?: boolean

			/**
			 * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring.
			 * Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			secretRef?: core.v1.SecretReference

			/**
			 * The rados user name. Default is admin. More info:
			 * https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			user?: string
		}

		/**
		 * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support
		 * ownership management and SELinux relabeling.
		 */
		export interface RBDVolumeSource {
			/**
			 * The rados image name. More info:
			 * https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			image: string

			/**
			 * A collection of Ceph monitors. More info:
			 * https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			monitors: string[]

			/**
			 * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type
			 * is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
			 * inferred to be "ext4" if unspecified. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#rbd
			 */
			fsType?: string

			/**
			 * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info:
			 * https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			keyring?: string

			/**
			 * The rados pool name. Default is rbd. More info:
			 * https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			pool?: string

			/**
			 * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More
			 * info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			readOnly?: boolean

			/**
			 * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring.
			 * Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			secretRef?: core.v1.LocalObjectReference

			/**
			 * The rados user name. Default is admin. More info:
			 * https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
			 */
			user?: string
		}

		/**
		 * ReplicationController represents the configuration of a replication controller.
		 */
		export interface ReplicationController {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ReplicationController'

			/**
			 * If the Labels of a ReplicationController are empty, they are defaulted to be the same as
			 * the Pod(s) that the replication controller manages. Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the specification of the desired behavior of the replication controller. More
			 * info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: core.v1.ReplicationControllerSpec
		}

		export function isReplicationController(
			o: any
		): o is ReplicationController {
			return o.apiVersion == 'v1' && o.kind == 'ReplicationController'
		}

		/**
		 * ReplicationControllerCondition describes the state of a replication controller at a certain
		 * point.
		 */
		export interface ReplicationControllerCondition {
			/**
			 * Type of replication controller condition.
			 */
			type: string

			/**
			 * The last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * ReplicationControllerList is a collection of replication controllers.
		 */
		export interface ReplicationControllerList {
			/**
			 * List of replication controllers. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
			 */
			items: core.v1.ReplicationController[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ReplicationControllerList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isReplicationControllerList(
			o: any
		): o is ReplicationControllerList {
			return o.apiVersion == 'v1' && o.kind == 'ReplicationControllerList'
		}

		/**
		 * ReplicationControllerSpec is the specification of a replication controller.
		 */
		export interface ReplicationControllerSpec {
			/**
			 * Minimum number of seconds for which a newly created pod should be ready without any of its
			 * container crashing, for it to be considered available. Defaults to 0 (pod will be
			 * considered available as soon as it is ready)
			 */
			minReadySeconds?: number

			/**
			 * Replicas is the number of desired replicas. This is a pointer to distinguish between
			 * explicit zero and unspecified. Defaults to 1. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
			 */
			replicas?: number

			/**
			 * Selector is a label query over pods that should match the Replicas count. If Selector is
			 * empty, it is defaulted to the labels present on the Pod template. Label keys and values
			 * that must match in order to be controlled by this replication controller, if empty
			 * defaulted to labels on Pod template. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
			 */
			selector?: { [key: string]: string }

			/**
			 * Template is the object that describes the pod that will be created if insufficient replicas
			 * are detected. This takes precedence over a TemplateRef. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
			 */
			template?: core.v1.PodTemplateSpec
		}

		/**
		 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
		 */
		export interface ResourceFieldSelector {
			/**
			 * Required: resource to select
			 */
			resource: string

			/**
			 * Container name: required for volumes, optional for env vars
			 */
			containerName?: string

			/**
			 * Specifies the output format of the exposed resources, defaults to "1"
			 */
			divisor?: string
		}

		/**
		 * ResourceQuota sets aggregate quota restrictions enforced per namespace
		 */
		export interface ResourceQuota {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ResourceQuota'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the desired quota.
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: core.v1.ResourceQuotaSpec
		}

		export function isResourceQuota(o: any): o is ResourceQuota {
			return o.apiVersion == 'v1' && o.kind == 'ResourceQuota'
		}

		/**
		 * ResourceQuotaList is a list of ResourceQuota items.
		 */
		export interface ResourceQuotaList {
			/**
			 * Items is a list of ResourceQuota objects. More info:
			 * https://kubernetes.io/docs/concepts/policy/resource-quotas/
			 */
			items: core.v1.ResourceQuota[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ResourceQuotaList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isResourceQuotaList(o: any): o is ResourceQuotaList {
			return o.apiVersion == 'v1' && o.kind == 'ResourceQuotaList'
		}

		/**
		 * ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
		 */
		export interface ResourceQuotaSpec {
			/**
			 * hard is the set of desired hard limits for each named resource. More info:
			 * https://kubernetes.io/docs/concepts/policy/resource-quotas/
			 */
			hard?: object

			/**
			 * scopeSelector is also a collection of filters like scopes that must match each object
			 * tracked by a quota but expressed using ScopeSelectorOperator in combination with possible
			 * values. For a resource to match, both scopes AND scopeSelector (if specified in spec), must
			 * be matched.
			 */
			scopeSelector?: core.v1.ScopeSelector

			/**
			 * A collection of filters that must match each object tracked by a quota. If not specified,
			 * the quota matches all objects.
			 */
			scopes?: string[]
		}

		/**
		 * ResourceRequirements describes the compute resource requirements.
		 */
		export interface ResourceRequirements {
			/**
			 * Limits describes the maximum amount of compute resources allowed. More info:
			 * https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
			 */
			limits?: object

			/**
			 * Requests describes the minimum amount of compute resources required. If Requests is omitted
			 * for a container, it defaults to Limits if that is explicitly specified, otherwise to an
			 * implementation-defined value. More info:
			 * https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
			 */
			requests?: object
		}

		/**
		 * SELinuxOptions are the labels to be applied to the container
		 */
		export interface SELinuxOptions {
			/**
			 * Level is SELinux level label that applies to the container.
			 */
			level?: string

			/**
			 * Role is a SELinux role label that applies to the container.
			 */
			role?: string

			/**
			 * Type is a SELinux type label that applies to the container.
			 */
			type?: string

			/**
			 * User is a SELinux user label that applies to the container.
			 */
			user?: string
		}

		/**
		 * ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume
		 */
		export interface ScaleIOPersistentVolumeSource {
			/**
			 * The host address of the ScaleIO API Gateway.
			 */
			gateway: string

			/**
			 * SecretRef references to the secret for ScaleIO user and other sensitive information. If
			 * this is not provided, Login operation will fail.
			 */
			secretRef: core.v1.SecretReference

			/**
			 * The name of the storage system as configured in ScaleIO.
			 */
			system: string

			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Ex. "ext4", "xfs", "ntfs". Default is "xfs"
			 */
			fsType?: string

			/**
			 * The name of the ScaleIO Protection Domain for the configured storage.
			 */
			protectionDomain?: string

			/**
			 * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts.
			 */
			readOnly?: boolean

			/**
			 * Flag to enable/disable SSL communication with Gateway, default false
			 */
			sslEnabled?: boolean

			/**
			 * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
			 * Default is ThinProvisioned.
			 */
			storageMode?: string

			/**
			 * The ScaleIO Storage Pool associated with the protection domain.
			 */
			storagePool?: string

			/**
			 * The name of a volume already created in the ScaleIO system that is associated with this
			 * volume source.
			 */
			volumeName?: string
		}

		/**
		 * ScaleIOVolumeSource represents a persistent ScaleIO volume
		 */
		export interface ScaleIOVolumeSource {
			/**
			 * The host address of the ScaleIO API Gateway.
			 */
			gateway: string

			/**
			 * SecretRef references to the secret for ScaleIO user and other sensitive information. If
			 * this is not provided, Login operation will fail.
			 */
			secretRef: core.v1.LocalObjectReference

			/**
			 * The name of the storage system as configured in ScaleIO.
			 */
			system: string

			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Ex. "ext4", "xfs", "ntfs". Default is "xfs".
			 */
			fsType?: string

			/**
			 * The name of the ScaleIO Protection Domain for the configured storage.
			 */
			protectionDomain?: string

			/**
			 * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts.
			 */
			readOnly?: boolean

			/**
			 * Flag to enable/disable SSL communication with Gateway, default false
			 */
			sslEnabled?: boolean

			/**
			 * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
			 * Default is ThinProvisioned.
			 */
			storageMode?: string

			/**
			 * The ScaleIO Storage Pool associated with the protection domain.
			 */
			storagePool?: string

			/**
			 * The name of a volume already created in the ScaleIO system that is associated with this
			 * volume source.
			 */
			volumeName?: string
		}

		/**
		 * A scope selector represents the AND of the selectors represented by the scoped-resource
		 * selector requirements.
		 */
		export interface ScopeSelector {
			/**
			 * A list of scope selector requirements by scope of the resources.
			 */
			matchExpressions?: core.v1.ScopedResourceSelectorRequirement[]
		}

		/**
		 * A scoped-resource selector requirement is a selector that contains values, a scope name, and
		 * an operator that relates the scope name and values.
		 */
		export interface ScopedResourceSelectorRequirement {
			/**
			 * Represents a scope's relationship to a set of values. Valid operators are In, NotIn,
			 * Exists, DoesNotExist.
			 */
			operator: string

			/**
			 * The name of the scope that the selector applies to.
			 */
			scopeName: string

			/**
			 * An array of string values. If the operator is In or NotIn, the values array must be
			 * non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This
			 * array is replaced during a strategic merge patch.
			 */
			values?: string[]
		}

		/**
		 * Secret holds secret data of a certain type. The total bytes of the values in the Data field
		 * must be less than MaxSecretSize bytes.
		 */
		export interface Secret {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Data contains the secret data. Each key must consist of alphanumeric characters, '-', '_'
			 * or '.'. The serialized form of the secret data is a base64 encoded string, representing the
			 * arbitrary (possibly non-string) data value here. Described in
			 * https://tools.ietf.org/html/rfc4648#section-4
			 */
			data?: object

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Secret'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * stringData allows specifying non-binary secret data in string form. It is provided as a
			 * write-only convenience method. All keys and values are merged into the data field on write,
			 * overwriting any existing values. It is never output when reading from the API.
			 */
			stringData?: { [key: string]: string }

			/**
			 * Used to facilitate programmatic handling of secret data.
			 */
			type?: string
		}

		export function isSecret(o: any): o is Secret {
			return o.apiVersion == 'v1' && o.kind == 'Secret'
		}

		/**
		 * SecretEnvSource selects a Secret to populate the environment variables with.
		 *
		 * The contents of the target Secret's Data field will represent the key-value pairs as
		 * environment variables.
		 */
		export interface SecretEnvSource {
			/**
			 * Name of the referent. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			 */
			name?: string

			/**
			 * Specify whether the Secret must be defined
			 */
			optional?: boolean
		}

		/**
		 * SecretKeySelector selects a key of a Secret.
		 */
		export interface SecretKeySelector {
			/**
			 * The key of the secret to select from.  Must be a valid secret key.
			 */
			key: string

			/**
			 * Name of the referent. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			 */
			name?: string

			/**
			 * Specify whether the Secret or its key must be defined
			 */
			optional?: boolean
		}

		/**
		 * SecretList is a list of Secret.
		 */
		export interface SecretList {
			/**
			 * Items is a list of secret objects. More info:
			 * https://kubernetes.io/docs/concepts/configuration/secret
			 */
			items: core.v1.Secret[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'SecretList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isSecretList(o: any): o is SecretList {
			return o.apiVersion == 'v1' && o.kind == 'SecretList'
		}

		/**
		 * Adapts a secret into a projected volume.
		 *
		 * The contents of the target Secret's Data field will be presented in a projected volume as
		 * files using the keys in the Data field as the file names. Note that this is identical to a
		 * secret volume source without the default mode.
		 */
		export interface SecretProjection {
			/**
			 * If unspecified, each key-value pair in the Data field of the referenced Secret will be
			 * projected into the volume as a file whose name is the key and content is the value. If
			 * specified, the listed keys will be projected into the specified paths, and unlisted keys
			 * will not be present. If a key is specified which is not present in the Secret, the volume
			 * setup will error unless it is marked optional. Paths must be relative and may not contain
			 * the '..' path or start with '..'.
			 */
			items?: core.v1.KeyToPath[]

			/**
			 * Name of the referent. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			 */
			name?: string

			/**
			 * Specify whether the Secret or its key must be defined
			 */
			optional?: boolean
		}

		/**
		 * SecretReference represents a Secret Reference. It has enough information to retrieve secret
		 * in any namespace
		 */
		export interface SecretReference {
			/**
			 * Name is unique within a namespace to reference a secret resource.
			 */
			name?: string

			/**
			 * Namespace defines the space within which the secret name must be unique.
			 */
			namespace?: string
		}

		/**
		 * Adapts a Secret into a volume.
		 *
		 * The contents of the target Secret's Data field will be presented in a volume as files using
		 * the keys in the Data field as the file names. Secret volumes support ownership management and
		 * SELinux relabeling.
		 */
		export interface SecretVolumeSource {
			/**
			 * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777.
			 * Defaults to 0644. Directories within the path are not affected by this setting. This might
			 * be in conflict with other options that affect the file mode, like fsGroup, and the result
			 * can be other mode bits set.
			 */
			defaultMode?: number

			/**
			 * If unspecified, each key-value pair in the Data field of the referenced Secret will be
			 * projected into the volume as a file whose name is the key and content is the value. If
			 * specified, the listed keys will be projected into the specified paths, and unlisted keys
			 * will not be present. If a key is specified which is not present in the Secret, the volume
			 * setup will error unless it is marked optional. Paths must be relative and may not contain
			 * the '..' path or start with '..'.
			 */
			items?: core.v1.KeyToPath[]

			/**
			 * Specify whether the Secret or its keys must be defined
			 */
			optional?: boolean

			/**
			 * Name of the secret in the pod's namespace to use. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#secret
			 */
			secretName?: string
		}

		/**
		 * SecurityContext holds security configuration that will be applied to a container. Some fields
		 * are present in both SecurityContext and PodSecurityContext.  When both are set, the values in
		 * SecurityContext take precedence.
		 */
		export interface SecurityContext {
			/**
			 * AllowPrivilegeEscalation controls whether a process can gain more privileges than its
			 * parent process. This bool directly controls if the no_new_privs flag will be set on the
			 * container process. AllowPrivilegeEscalation is true always when the container is: 1) run as
			 * Privileged 2) has CAP_SYS_ADMIN
			 */
			allowPrivilegeEscalation?: boolean

			/**
			 * The capabilities to add/drop when running containers. Defaults to the default set of
			 * capabilities granted by the container runtime.
			 */
			capabilities?: core.v1.Capabilities

			/**
			 * Run container in privileged mode. Processes in privileged containers are essentially
			 * equivalent to root on the host. Defaults to false.
			 */
			privileged?: boolean

			/**
			 * procMount denotes the type of proc mount to use for the containers. The default is
			 * DefaultProcMount which uses the container runtime defaults for readonly paths and masked
			 * paths. This requires the ProcMountType feature flag to be enabled.
			 */
			procMount?: string

			/**
			 * Whether this container has a read-only root filesystem. Default is false.
			 */
			readOnlyRootFilesystem?: boolean

			/**
			 * The GID to run the entrypoint of the container process. Uses runtime default if unset. May
			 * also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext,
			 * the value specified in SecurityContext takes precedence.
			 */
			runAsGroup?: number

			/**
			 * Indicates that the container must run as a non-root user. If true, the Kubelet will
			 * validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to
			 * start the container if it does. If unset or false, no such validation will be performed.
			 * May also be set in PodSecurityContext.  If set in both SecurityContext and
			 * PodSecurityContext, the value specified in SecurityContext takes precedence.
			 */
			runAsNonRoot?: boolean

			/**
			 * The UID to run the entrypoint of the container process. Defaults to user specified in image
			 * metadata if unspecified. May also be set in PodSecurityContext.  If set in both
			 * SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
			 * precedence.
			 */
			runAsUser?: number

			/**
			 * The SELinux context to be applied to the container. If unspecified, the container runtime
			 * will allocate a random SELinux context for each container.  May also be set in
			 * PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value
			 * specified in SecurityContext takes precedence.
			 */
			seLinuxOptions?: core.v1.SELinuxOptions

			/**
			 * The Windows specific settings applied to all containers. If unspecified, the options from
			 * the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext,
			 * the value specified in SecurityContext takes precedence.
			 */
			windowsOptions?: core.v1.WindowsSecurityContextOptions
		}

		/**
		 * Service is a named abstraction of software service (for example, mysql) consisting of local
		 * port (for example 3306) that the proxy listens on, and the selector that determines which
		 * pods will answer requests sent through the proxy.
		 */
		export interface Service {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Service'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the behavior of a service.
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: core.v1.ServiceSpec
		}

		export function isService(o: any): o is Service {
			return o.apiVersion == 'v1' && o.kind == 'Service'
		}

		/**
		 * ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral
		 * systems, for an identity * a principal that can be authenticated and authorized * a set of
		 * secrets
		 */
		export interface ServiceAccount {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * AutomountServiceAccountToken indicates whether pods running as this service account should
			 * have an API token automatically mounted. Can be overridden at the pod level.
			 */
			automountServiceAccountToken?: boolean

			/**
			 * ImagePullSecrets is a list of references to secrets in the same namespace to use for
			 * pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are
			 * distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are
			 * only accessed by the kubelet. More info:
			 * https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
			 */
			imagePullSecrets?: core.v1.LocalObjectReference[]

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ServiceAccount'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Secrets is the list of secrets allowed to be used by pods running using this
			 * ServiceAccount. More info: https://kubernetes.io/docs/concepts/configuration/secret
			 */
			secrets?: core.v1.ObjectReference[]
		}

		export function isServiceAccount(o: any): o is ServiceAccount {
			return o.apiVersion == 'v1' && o.kind == 'ServiceAccount'
		}

		/**
		 * ServiceAccountList is a list of ServiceAccount objects
		 */
		export interface ServiceAccountList {
			/**
			 * List of ServiceAccounts. More info:
			 * https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
			 */
			items: core.v1.ServiceAccount[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ServiceAccountList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isServiceAccountList(o: any): o is ServiceAccountList {
			return o.apiVersion == 'v1' && o.kind == 'ServiceAccountList'
		}

		/**
		 * ServiceAccountTokenProjection represents a projected service account token volume. This
		 * projection can be used to insert a service account token into the pods runtime filesystem for
		 * use against APIs (Kubernetes API Server or otherwise).
		 */
		export interface ServiceAccountTokenProjection {
			/**
			 * Path is the path relative to the mount point of the file to project the token into.
			 */
			path: string

			/**
			 * Audience is the intended audience of the token. A recipient of a token must identify itself
			 * with an identifier specified in the audience of the token, and otherwise should reject the
			 * token. The audience defaults to the identifier of the apiserver.
			 */
			audience?: string

			/**
			 * ExpirationSeconds is the requested duration of validity of the service account token. As
			 * the token approaches expiration, the kubelet volume plugin will proactively rotate the
			 * service account token. The kubelet will start trying to rotate the token if the token is
			 * older than 80 percent of its time to live or if the token is older than 24 hours.Defaults
			 * to 1 hour and must be at least 10 minutes.
			 */
			expirationSeconds?: number
		}

		/**
		 * ServiceList holds a list of services.
		 */
		export interface ServiceList {
			/**
			 * List of services
			 */
			items: core.v1.Service[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ServiceList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isServiceList(o: any): o is ServiceList {
			return o.apiVersion == 'v1' && o.kind == 'ServiceList'
		}

		/**
		 * ServicePort contains information on service's port.
		 */
		export interface ServicePort {
			/**
			 * The port that will be exposed by this service.
			 */
			port: number

			/**
			 * The name of this port within the service. This must be a DNS_LABEL. All ports within a
			 * ServiceSpec must have unique names. When considering the endpoints for a Service, this must
			 * match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on
			 * this service.
			 */
			name?: string

			/**
			 * The port on each node on which this service is exposed when type=NodePort or LoadBalancer.
			 * Usually assigned by the system. If specified, it will be allocated to the service if unused
			 * or else creation of the service will fail. Default is to auto-allocate a port if the
			 * ServiceType of this Service requires one. More info:
			 * https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
			 */
			nodePort?: number

			/**
			 * The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
			 */
			protocol?: string

			/**
			 * Number or name of the port to access on the pods targeted by the service. Number must be in
			 * the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked
			 * up as a named port in the target Pod's container ports. If this is not specified, the value
			 * of the 'port' field is used (an identity map). This field is ignored for services with
			 * clusterIP=None, and should be omitted or set equal to the 'port' field. More info:
			 * https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
			 */
			targetPort?: number | string
		}

		/**
		 * ServiceSpec describes the attributes that a user creates on a service.
		 */
		export interface ServiceSpec {
			/**
			 * clusterIP is the IP address of the service and is usually assigned randomly by the master.
			 * If an address is specified manually and is not in use by others, it will be allocated to
			 * the service; otherwise, creation of the service will fail. This field can not be changed
			 * through updates. Valid values are "None", empty string (""), or a valid IP address. "None"
			 * can be specified for headless services when proxying is not required. Only applies to types
			 * ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info:
			 * https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
			 */
			clusterIP?: string

			/**
			 * externalIPs is a list of IP addresses for which nodes in the cluster will also accept
			 * traffic for this service.  These IPs are not managed by Kubernetes.  The user is
			 * responsible for ensuring that traffic arrives at a node with this IP.  A common example is
			 * external load-balancers that are not part of the Kubernetes system.
			 */
			externalIPs?: string[]

			/**
			 * externalName is the external reference that kubedns or equivalent will return as a CNAME
			 * record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname
			 * (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.
			 */
			externalName?: string

			/**
			 * externalTrafficPolicy denotes if this Service desires to route external traffic to
			 * node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a
			 * second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced
			 * traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to
			 * another node, but should have good overall load-spreading.
			 */
			externalTrafficPolicy?: string

			/**
			 * healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified,
			 * HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will
			 * use user-specified nodePort value if specified by the client. Only effects when Type is set
			 * to LoadBalancer and ExternalTrafficPolicy is set to Local.
			 */
			healthCheckNodePort?: number

			/**
			 * ipFamily specifies whether this Service has a preference for a particular IP family (e.g.
			 * IPv4 vs. IPv6).  If a specific IP family is requested, the clusterIP field will be
			 * allocated from that family, if it is available in the cluster.  If no IP family is
			 * requested, the cluster's primary IP family will be used. Other IP fields (loadBalancerIP,
			 * loadBalancerSourceRanges, externalIPs) and controllers which allocate external
			 * load-balancers should use the same IP family.  Endpoints for this Service will be of this
			 * family.  This field is immutable after creation. Assigning a ServiceIPFamily not available
			 * in the cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and will fail during
			 * clusterIP assignment.
			 */
			ipFamily?: string

			/**
			 * Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP
			 * specified in this field. This feature depends on whether the underlying cloud-provider
			 * supports specifying the loadBalancerIP when a load balancer is created. This field will be
			 * ignored if the cloud-provider does not support the feature.
			 */
			loadBalancerIP?: string

			/**
			 * If specified and supported by the platform, this will restrict traffic through the
			 * cloud-provider load-balancer will be restricted to the specified client IPs. This field
			 * will be ignored if the cloud-provider does not support the feature." More info:
			 * https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
			 */
			loadBalancerSourceRanges?: string[]

			/**
			 * The list of ports that are exposed by this service. More info:
			 * https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
			 */
			ports?: core.v1.ServicePort[]

			/**
			 * publishNotReadyAddresses, when set to true, indicates that DNS implementations must publish
			 * the notReadyAddresses of subsets for the Endpoints associated with the Service. The default
			 * value is false. The primary use case for setting this field is to use a StatefulSet's
			 * Headless Service to propagate SRV records for its Pods without respect to their readiness
			 * for purpose of peer discovery.
			 */
			publishNotReadyAddresses?: boolean

			/**
			 * Route service traffic to pods with label keys and values matching this selector. If empty
			 * or not present, the service is assumed to have an external process managing its endpoints,
			 * which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and
			 * LoadBalancer. Ignored if type is ExternalName. More info:
			 * https://kubernetes.io/docs/concepts/services-networking/service/
			 */
			selector?: { [key: string]: string }

			/**
			 * Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based
			 * session affinity. Must be ClientIP or None. Defaults to None. More info:
			 * https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
			 */
			sessionAffinity?: string

			/**
			 * sessionAffinityConfig contains the configurations of session affinity.
			 */
			sessionAffinityConfig?: core.v1.SessionAffinityConfig

			/**
			 * topologyKeys is a preference-order list of topology keys which implementations of services
			 * should use to preferentially sort endpoints when accessing this Service, it can not be used
			 * at the same time as externalTrafficPolicy=Local. Topology keys must be valid label keys and
			 * at most 16 keys may be specified. Endpoints are chosen based on the first topology key with
			 * available backends. If this field is specified and all entries have no backends that match
			 * the topology of the client, the service has no backends for that client and connections
			 * should fail. The special value "*" may be used to mean "any topology". This catch-all
			 * value, if used, only makes sense as the last value in the list. If this is not specified or
			 * empty, no topology constraints will be applied.
			 */
			topologyKeys?: string[]

			/**
			 * type determines how the Service is exposed. Defaults to ClusterIP. Valid options are
			 * ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified
			 * externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to
			 * endpoints. Endpoints are determined by the selector or if that is not specified, by manual
			 * construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and
			 * the endpoints are published as a set of endpoints rather than a stable IP. "NodePort"
			 * builds on ClusterIP and allocates a port on every node which routes to the clusterIP.
			 * "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in
			 * the current cloud) which routes to the clusterIP. More info:
			 * https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
			 */
			type?: string
		}

		/**
		 * SessionAffinityConfig represents the configurations of session affinity.
		 */
		export interface SessionAffinityConfig {
			/**
			 * clientIP contains the configurations of Client IP based session affinity.
			 */
			clientIP?: core.v1.ClientIPConfig
		}

		/**
		 * Represents a StorageOS persistent volume resource.
		 */
		export interface StorageOSPersistentVolumeSource {
			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
			 */
			fsType?: string

			/**
			 * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts.
			 */
			readOnly?: boolean

			/**
			 * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not
			 * specified, default values will be attempted.
			 */
			secretRef?: core.v1.ObjectReference

			/**
			 * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only
			 * unique within a namespace.
			 */
			volumeName?: string

			/**
			 * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is
			 * specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping
			 * to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to
			 * override the default behaviour. Set to "default" if you are not using namespaces within
			 * StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
			 */
			volumeNamespace?: string
		}

		/**
		 * Represents a StorageOS persistent volume resource.
		 */
		export interface StorageOSVolumeSource {
			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
			 */
			fsType?: string

			/**
			 * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
			 * VolumeMounts.
			 */
			readOnly?: boolean

			/**
			 * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not
			 * specified, default values will be attempted.
			 */
			secretRef?: core.v1.LocalObjectReference

			/**
			 * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only
			 * unique within a namespace.
			 */
			volumeName?: string

			/**
			 * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is
			 * specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping
			 * to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to
			 * override the default behaviour. Set to "default" if you are not using namespaces within
			 * StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
			 */
			volumeNamespace?: string
		}

		/**
		 * Sysctl defines a kernel parameter to be set
		 */
		export interface Sysctl {
			/**
			 * Name of a property to set
			 */
			name: string

			/**
			 * Value of a property to set
			 */
			value: string
		}

		/**
		 * TCPSocketAction describes an action based on opening a socket
		 */
		export interface TCPSocketAction {
			/**
			 * Number or name of the port to access on the container. Number must be in the range 1 to
			 * 65535. Name must be an IANA_SVC_NAME.
			 */
			port: number | string

			/**
			 * Optional: Host name to connect to, defaults to the pod IP.
			 */
			host?: string
		}

		/**
		 * The node this Taint is attached to has the "effect" on any pod that does not tolerate the
		 * Taint.
		 */
		export interface Taint {
			/**
			 * Required. The effect of the taint on pods that do not tolerate the taint. Valid effects are
			 * NoSchedule, PreferNoSchedule and NoExecute.
			 */
			effect: string

			/**
			 * Required. The taint key to be applied to a node.
			 */
			key: string

			/**
			 * TimeAdded represents the time at which the taint was added. It is only written for
			 * NoExecute taints.
			 */
			timeAdded?: string

			/**
			 * Required. The taint value corresponding to the taint key.
			 */
			value?: string
		}

		/**
		 * The pod this Toleration is attached to tolerates any taint that matches the triple
		 * <key,value,effect> using the matching operator <operator>.
		 */
		export interface Toleration {
			/**
			 * Effect indicates the taint effect to match. Empty means match all taint effects. When
			 * specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
			 */
			effect?: string

			/**
			 * Key is the taint key that the toleration applies to. Empty means match all taint keys. If
			 * the key is empty, operator must be Exists; this combination means to match all values and
			 * all keys.
			 */
			key?: string

			/**
			 * Operator represents a key's relationship to the value. Valid operators are Exists and
			 * Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can
			 * tolerate all taints of a particular category.
			 */
			operator?: string

			/**
			 * TolerationSeconds represents the period of time the toleration (which must be of effect
			 * NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set,
			 * which means tolerate the taint forever (do not evict). Zero and negative values will be
			 * treated as 0 (evict immediately) by the system.
			 */
			tolerationSeconds?: number

			/**
			 * Value is the taint value the toleration matches to. If the operator is Exists, the value
			 * should be empty, otherwise just a regular string.
			 */
			value?: string
		}

		/**
		 * A topology selector requirement is a selector that matches given label. This is an alpha
		 * feature and may change in the future.
		 */
		export interface TopologySelectorLabelRequirement {
			/**
			 * The label key that the selector applies to.
			 */
			key: string

			/**
			 * An array of string values. One value must match the label to be selected. Each entry in
			 * Values is ORed.
			 */
			values: string[]
		}

		/**
		 * A topology selector term represents the result of label queries. A null or empty topology
		 * selector term matches no objects. The requirements of them are ANDed. It provides a subset of
		 * functionality as NodeSelectorTerm. This is an alpha feature and may change in the future.
		 */
		export interface TopologySelectorTerm {
			/**
			 * A list of topology selector requirements by labels.
			 */
			matchLabelExpressions?: core.v1.TopologySelectorLabelRequirement[]
		}

		/**
		 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
		 */
		export interface TopologySpreadConstraint {
			/**
			 * MaxSkew describes the degree to which pods may be unevenly distributed. It's the maximum
			 * permitted difference between the number of matching pods in any two topology domains of a
			 * given topology type. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
			 * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |       |
			 * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1; scheduling
			 * it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1). -
			 * if MaxSkew is 2, incoming pod can be scheduled onto any zone. It's a required field.
			 * Default value is 1 and 0 is not allowed.
			 */
			maxSkew: number

			/**
			 * TopologyKey is the key of node labels. Nodes that have a label with this key and identical
			 * values are considered to be in the same topology. We consider each <key, value> as a
			 * "bucket", and try to put balanced number of pods into each bucket. It's a required field.
			 */
			topologyKey: string

			/**
			 * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread
			 * constraint. - DoNotSchedule (default) tells the scheduler not to schedule it -
			 * ScheduleAnyway tells the scheduler to still schedule it It's considered as "Unsatisfiable"
			 * if and only if placing incoming pod on any topology violates "MaxSkew". For example, in a
			 * 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1:
			 * | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to
			 * DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as
			 * ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still
			 * be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
			 */
			whenUnsatisfiable: string

			/**
			 * LabelSelector is used to find matching pods. Pods that match this label selector are
			 * counted to determine the number of pods in their corresponding topology domain.
			 */
			labelSelector?: meta.v1.LabelSelector
		}

		/**
		 * TypedLocalObjectReference contains enough information to let you locate the typed referenced
		 * object inside the same namespace.
		 */
		export interface TypedLocalObjectReference {
			/**
			 * Kind is the type of resource being referenced
			 */
			kind: string

			/**
			 * Name is the name of resource being referenced
			 */
			name: string

			/**
			 * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the
			 * specified Kind must be in the core API group. For any other third-party types, APIGroup is
			 * required.
			 */
			apiGroup?: string
		}

		/**
		 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
		 */
		export interface Volume {
			/**
			 * Volume's name. Must be a DNS_LABEL and unique within the pod. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			 */
			name: string

			/**
			 * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host
			 * machine and then exposed to the pod. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
			 */
			awsElasticBlockStore?: core.v1.AWSElasticBlockStoreVolumeSource

			/**
			 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
			 */
			azureDisk?: core.v1.AzureDiskVolumeSource

			/**
			 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
			 */
			azureFile?: core.v1.AzureFileVolumeSource

			/**
			 * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
			 */
			cephfs?: core.v1.CephFSVolumeSource

			/**
			 * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info:
			 * https://examples.k8s.io/mysql-cinder-pd/README.md
			 */
			cinder?: core.v1.CinderVolumeSource

			/**
			 * ConfigMap represents a configMap that should populate this volume
			 */
			configMap?: core.v1.ConfigMapVolumeSource

			/**
			 * CSI (Container Storage Interface) represents storage that is handled by an external CSI
			 * driver (Alpha feature).
			 */
			csi?: core.v1.CSIVolumeSource

			/**
			 * DownwardAPI represents downward API about the pod that should populate this volume
			 */
			downwardAPI?: core.v1.DownwardAPIVolumeSource

			/**
			 * EmptyDir represents a temporary directory that shares a pod's lifetime. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#emptydir
			 */
			emptyDir?: core.v1.EmptyDirVolumeSource

			/**
			 * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and
			 * then exposed to the pod.
			 */
			fc?: core.v1.FCVolumeSource

			/**
			 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec
			 * based plugin.
			 */
			flexVolume?: core.v1.FlexVolumeSource

			/**
			 * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on
			 * the Flocker control service being running
			 */
			flocker?: core.v1.FlockerVolumeSource

			/**
			 * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host
			 * machine and then exposed to the pod. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
			 */
			gcePersistentDisk?: core.v1.GCEPersistentDiskVolumeSource

			/**
			 * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is
			 * deprecated. To provision a container with a git repo, mount an EmptyDir into an
			 * InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's
			 * container.
			 */
			gitRepo?: core.v1.GitRepoVolumeSource

			/**
			 * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info:
			 * https://examples.k8s.io/volumes/glusterfs/README.md
			 */
			glusterfs?: core.v1.GlusterfsVolumeSource

			/**
			 * HostPath represents a pre-existing file or directory on the host machine that is directly
			 * exposed to the container. This is generally used for system agents or other privileged
			 * things that are allowed to see the host machine. Most containers will NOT need this. More
			 * info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
			 */
			hostPath?: core.v1.HostPathVolumeSource

			/**
			 * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and
			 * then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
			 */
			iscsi?: core.v1.ISCSIVolumeSource

			/**
			 * NFS represents an NFS mount on the host that shares a pod's lifetime More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#nfs
			 */
			nfs?: core.v1.NFSVolumeSource

			/**
			 * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the
			 * same namespace. More info:
			 * https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
			 */
			persistentVolumeClaim?: core.v1.PersistentVolumeClaimVolumeSource

			/**
			 * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on
			 * kubelets host machine
			 */
			photonPersistentDisk?: core.v1.PhotonPersistentDiskVolumeSource

			/**
			 * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
			 */
			portworxVolume?: core.v1.PortworxVolumeSource

			/**
			 * Items for all in one resources secrets, configmaps, and downward API
			 */
			projected?: core.v1.ProjectedVolumeSource

			/**
			 * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
			 */
			quobyte?: core.v1.QuobyteVolumeSource

			/**
			 * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More
			 * info: https://examples.k8s.io/volumes/rbd/README.md
			 */
			rbd?: core.v1.RBDVolumeSource

			/**
			 * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
			 */
			scaleIO?: core.v1.ScaleIOVolumeSource

			/**
			 * Secret represents a secret that should populate this volume. More info:
			 * https://kubernetes.io/docs/concepts/storage/volumes#secret
			 */
			secret?: core.v1.SecretVolumeSource

			/**
			 * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
			 */
			storageos?: core.v1.StorageOSVolumeSource

			/**
			 * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
			 */
			vsphereVolume?: core.v1.VsphereVirtualDiskVolumeSource
		}

		/**
		 * volumeDevice describes a mapping of a raw block device within a container.
		 */
		export interface VolumeDevice {
			/**
			 * devicePath is the path inside of the container that the device will be mapped to.
			 */
			devicePath: string

			/**
			 * name must match the name of a persistentVolumeClaim in the pod
			 */
			name: string
		}

		/**
		 * VolumeMount describes a mounting of a Volume within a container.
		 */
		export interface VolumeMount {
			/**
			 * Path within the container at which the volume should be mounted.  Must not contain ':'.
			 */
			mountPath: string

			/**
			 * This must match the Name of a Volume.
			 */
			name: string

			/**
			 * mountPropagation determines how mounts are propagated from the host to container and the
			 * other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
			 */
			mountPropagation?: string

			/**
			 * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
			 */
			readOnly?: boolean

			/**
			 * Path within the volume from which the container's volume should be mounted. Defaults to ""
			 * (volume's root).
			 */
			subPath?: string

			/**
			 * Expanded path within the volume from which the container's volume should be mounted.
			 * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded
			 * using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath
			 * are mutually exclusive.
			 */
			subPathExpr?: string
		}

		/**
		 * VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed
		 * from.
		 */
		export interface VolumeNodeAffinity {
			/**
			 * Required specifies hard node constraints that must be met.
			 */
			required?: core.v1.NodeSelector
		}

		/**
		 * Projection that may be projected along with other supported volume types
		 */
		export interface VolumeProjection {
			/**
			 * information about the configMap data to project
			 */
			configMap?: core.v1.ConfigMapProjection

			/**
			 * information about the downwardAPI data to project
			 */
			downwardAPI?: core.v1.DownwardAPIProjection

			/**
			 * information about the secret data to project
			 */
			secret?: core.v1.SecretProjection

			/**
			 * information about the serviceAccountToken data to project
			 */
			serviceAccountToken?: core.v1.ServiceAccountTokenProjection
		}

		/**
		 * Represents a vSphere volume resource.
		 */
		export interface VsphereVirtualDiskVolumeSource {
			/**
			 * Path that identifies vSphere volume vmdk
			 */
			volumePath: string

			/**
			 * Filesystem type to mount. Must be a filesystem type supported by the host operating system.
			 * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
			 */
			fsType?: string

			/**
			 * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
			 */
			storagePolicyID?: string

			/**
			 * Storage Policy Based Management (SPBM) profile name.
			 */
			storagePolicyName?: string
		}

		/**
		 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find
		 * the most preferred node(s)
		 */
		export interface WeightedPodAffinityTerm {
			/**
			 * Required. A pod affinity term, associated with the corresponding weight.
			 */
			podAffinityTerm: core.v1.PodAffinityTerm

			/**
			 * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
			 */
			weight: number
		}

		/**
		 * WindowsSecurityContextOptions contain Windows-specific options and credentials.
		 */
		export interface WindowsSecurityContextOptions {
			/**
			 * GMSACredentialSpec is where the GMSA admission webhook
			 * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA
			 * credential spec named by the GMSACredentialSpecName field. This field is alpha-level and is
			 * only honored by servers that enable the WindowsGMSA feature flag.
			 */
			gmsaCredentialSpec?: string

			/**
			 * GMSACredentialSpecName is the name of the GMSA credential spec to use. This field is
			 * alpha-level and is only honored by servers that enable the WindowsGMSA feature flag.
			 */
			gmsaCredentialSpecName?: string

			/**
			 * The UserName in Windows to run the entrypoint of the container process. Defaults to the
			 * user specified in image metadata if unspecified. May also be set in PodSecurityContext. If
			 * set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext
			 * takes precedence. This field is beta-level and may be disabled with the
			 * WindowsRunAsUserName feature flag.
			 */
			runAsUserName?: string
		}
	}
}

export namespace discovery {
	export namespace v1beta1 {
		/**
		 * Endpoint represents a single logical "backend" implementing a service.
		 */
		export interface Endpoint {
			/**
			 * addresses of this endpoint. The contents of this field are interpreted according to the
			 * corresponding EndpointSlice addressType field. Consumers must handle different types of
			 * addresses in the context of their own capabilities. This must contain at least one address
			 * but no more than 100.
			 */
			addresses: string[]

			/**
			 * conditions contains information about the current status of the endpoint.
			 */
			conditions?: discovery.v1beta1.EndpointConditions

			/**
			 * hostname of this endpoint. This field may be used by consumers of endpoints to distinguish
			 * endpoints from each other (e.g. in DNS names). Multiple endpoints which use the same
			 * hostname should be considered fungible (e.g. multiple A values in DNS). Must pass DNS Label
			 * (RFC 1123) validation.
			 */
			hostname?: string

			/**
			 * targetRef is a reference to a Kubernetes object that represents this endpoint.
			 */
			targetRef?: core.v1.ObjectReference

			/**
			 * topology contains arbitrary topology information associated with the endpoint. These
			 * key/value pairs must conform with the label format.
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels Topology may
			 * include a maximum of 16 key/value pairs. This includes, but is not limited to the following
			 * well known keys: * kubernetes.io/hostname: the value indicates the hostname of the node
			 *   where the endpoint is located. This should match the corresponding
			 *   node label.
			 * * topology.kubernetes.io/zone: the value indicates the zone where the
			 *   endpoint is located. This should match the corresponding node label.
			 * * topology.kubernetes.io/region: the value indicates the region where the
			 *   endpoint is located. This should match the corresponding node label.
			 */
			topology?: { [key: string]: string }
		}

		/**
		 * EndpointConditions represents the current condition of an endpoint.
		 */
		export interface EndpointConditions {
			/**
			 * ready indicates that this endpoint is prepared to receive traffic, according to whatever
			 * system is managing the endpoint. A nil value indicates an unknown state. In most cases
			 * consumers should interpret this unknown state as ready.
			 */
			ready?: boolean
		}

		/**
		 * EndpointPort represents a Port used by an EndpointSlice
		 */
		export interface EndpointPort {
			/**
			 * The application protocol for this port. This field follows standard Kubernetes label
			 * syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and
			 * http://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed
			 * names. Default is empty string.
			 */
			appProtocol?: string

			/**
			 * The name of this port. All ports in an EndpointSlice must have a unique name. If the
			 * EndpointSlice is dervied from a Kubernetes service, this corresponds to the
			 * Service.ports[].name. Name must either be an empty string or pass DNS_LABEL validation: *
			 * must be no more than 63 characters long. * must consist of lower case alphanumeric
			 * characters or '-'. * must start and end with an alphanumeric character. Default is empty
			 * string.
			 */
			name?: string

			/**
			 * The port number of the endpoint. If this is not specified, ports are not restricted and
			 * must be interpreted in the context of the specific consumer.
			 */
			port?: number

			/**
			 * The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
			 */
			protocol?: string
		}

		/**
		 * EndpointSlice represents a subset of the endpoints that implement a service. For a given
		 * service there may be multiple EndpointSlice objects, selected by labels, which must be joined
		 * to produce the full set of endpoints.
		 */
		export interface EndpointSlice {
			/**
			 * addressType specifies the type of address carried by this EndpointSlice. All addresses in
			 * this slice must be the same type. This field is immutable after creation. The following
			 * address types are currently supported: * IPv4: Represents an IPv4 Address. * IPv6:
			 * Represents an IPv6 Address. * FQDN: Represents a Fully Qualified Domain Name.
			 */
			addressType: string

			/**
			 * endpoints is a list of unique endpoints in this slice. Each slice may include a maximum of
			 * 1000 endpoints.
			 */
			endpoints: discovery.v1beta1.Endpoint[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'discovery.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'EndpointSlice'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * ports specifies the list of network ports exposed by each endpoint in this slice. Each port
			 * must have a unique name. When ports is empty, it indicates that there are no defined ports.
			 * When a port is defined with a nil port value, it indicates "all ports". Each slice may
			 * include a maximum of 100 ports.
			 */
			ports?: discovery.v1beta1.EndpointPort[]
		}

		export function isEndpointSlice(o: any): o is EndpointSlice {
			return (
				o.apiVersion == 'discovery.k8s.io/v1beta1' && o.kind == 'EndpointSlice'
			)
		}

		/**
		 * EndpointSliceList represents a list of endpoint slices
		 */
		export interface EndpointSliceList {
			/**
			 * List of endpoint slices
			 */
			items: discovery.v1beta1.EndpointSlice[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'discovery.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'EndpointSliceList'

			/**
			 * Standard list metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isEndpointSliceList(o: any): o is EndpointSliceList {
			return (
				o.apiVersion == 'discovery.k8s.io/v1beta1' &&
				o.kind == 'EndpointSliceList'
			)
		}
	}
}

export namespace events {
	export namespace v1beta1 {
		/**
		 * Event is a report of an event somewhere in the cluster. It generally denotes some state
		 * change in the system.
		 */
		export interface Event {
			/**
			 * Required. Time when this Event was first observed.
			 */
			eventTime: string

			/**
			 * What action was taken/failed regarding to the regarding object.
			 */
			action?: string

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'events.k8s.io/v1beta1'

			/**
			 * Deprecated field assuring backward compatibility with core.v1 Event type
			 */
			deprecatedCount?: number

			/**
			 * Deprecated field assuring backward compatibility with core.v1 Event type
			 */
			deprecatedFirstTimestamp?: string

			/**
			 * Deprecated field assuring backward compatibility with core.v1 Event type
			 */
			deprecatedLastTimestamp?: string

			/**
			 * Deprecated field assuring backward compatibility with core.v1 Event type
			 */
			deprecatedSource?: core.v1.EventSource

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Event'

			metadata?: meta.v1.ObjectMeta

			/**
			 * Optional. A human-readable description of the status of this operation. Maximal length of
			 * the note is 1kB, but libraries should be prepared to handle values up to 64kB.
			 */
			note?: string

			/**
			 * Why the action was taken.
			 */
			reason?: string

			/**
			 * The object this Event is about. In most cases it's an Object reporting controller
			 * implements. E.g. ReplicaSetController implements ReplicaSets and this event is emitted
			 * because it acts on some changes in a ReplicaSet object.
			 */
			regarding?: core.v1.ObjectReference

			/**
			 * Optional secondary object for more complex actions. E.g. when regarding object triggers a
			 * creation or deletion of related object.
			 */
			related?: core.v1.ObjectReference

			/**
			 * Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
			 */
			reportingController?: string

			/**
			 * ID of the controller instance, e.g. `kubelet-xyzf`.
			 */
			reportingInstance?: string

			/**
			 * Data about the Event series this event represents or nil if it's a singleton Event.
			 */
			series?: events.v1beta1.EventSeries

			/**
			 * Type of this event (Normal, Warning), new types could be added in the future.
			 */
			type?: string
		}

		export function isEvent(o: any): o is Event {
			return o.apiVersion == 'events.k8s.io/v1beta1' && o.kind == 'Event'
		}

		/**
		 * EventList is a list of Event objects.
		 */
		export interface EventList {
			/**
			 * Items is a list of schema objects.
			 */
			items: events.v1beta1.Event[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'events.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'EventList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isEventList(o: any): o is EventList {
			return o.apiVersion == 'events.k8s.io/v1beta1' && o.kind == 'EventList'
		}

		/**
		 * EventSeries contain information on series of events, i.e. thing that was/is happening
		 * continuously for some time.
		 */
		export interface EventSeries {
			/**
			 * Number of occurrences in this series up to the last heartbeat time
			 */
			count: number

			/**
			 * Time when last Event from the series was seen before last heartbeat.
			 */
			lastObservedTime: string

			/**
			 * Information whether this series is ongoing or finished. Deprecated. Planned removal for
			 * 1.18
			 */
			state: string
		}
	}
}

export namespace extensions {
	export namespace v1beta1 {
		/**
		 * AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
		 */
		export interface AllowedCSIDriver {
			/**
			 * Name is the registered name of the CSI driver
			 */
			name: string
		}

		/**
		 * AllowedFlexVolume represents a single Flexvolume that is allowed to be used. Deprecated: use
		 * AllowedFlexVolume from policy API Group instead.
		 */
		export interface AllowedFlexVolume {
			/**
			 * driver is the name of the Flexvolume driver.
			 */
			driver: string
		}

		/**
		 * AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods
		 * to use. It requires the path prefix to be defined. Deprecated: use AllowedHostPath from
		 * policy API Group instead.
		 */
		export interface AllowedHostPath {
			/**
			 * pathPrefix is the path prefix that the host volume must match. It does not support `*`.
			 * Trailing slashes are trimmed when validating the path prefix with a host path.
			 *
			 * Examples: `/foo` would allow `/foo`, `/foo/` and `/foo/bar` `/foo` would not allow `/food`
			 * or `/etc/foo`
			 */
			pathPrefix?: string

			/**
			 * when set to true, will allow host volumes matching the pathPrefix only if all volume mounts
			 * are readOnly.
			 */
			readOnly?: boolean
		}

		/**
		 * DaemonSet represents the configuration of a daemon set.
		 *
		 * @deprecated extensions/v1beta1/DaemonSet is deprecated by apps/v1/DaemonSet and not supported
		 * by Kubernetes v1.16+ clusters.
		 */
		export interface DaemonSet {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'DaemonSet'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * The desired behavior of this daemon set. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: extensions.v1beta1.DaemonSetSpec
		}

		export function isDaemonSet(o: any): o is DaemonSet {
			return o.apiVersion == 'extensions/v1beta1' && o.kind == 'DaemonSet'
		}

		/**
		 * DaemonSetCondition describes the state of a DaemonSet at a certain point.
		 */
		export interface DaemonSetCondition {
			/**
			 * Type of DaemonSet condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * DaemonSetList is a collection of daemon sets.
		 */
		export interface DaemonSetList {
			/**
			 * A list of daemon sets.
			 */
			items: extensions.v1beta1.DaemonSet[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'DaemonSetList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isDaemonSetList(o: any): o is DaemonSetList {
			return o.apiVersion == 'extensions/v1beta1' && o.kind == 'DaemonSetList'
		}

		/**
		 * DaemonSetSpec is the specification of a daemon set.
		 */
		export interface DaemonSetSpec {
			/**
			 * An object that describes the pod that will be created. The DaemonSet will create exactly
			 * one copy of this pod on every node that matches the template's node selector (or on every
			 * node if no node selector is specified). More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
			 */
			template: core.v1.PodTemplateSpec

			/**
			 * The minimum number of seconds for which a newly created DaemonSet pod should be ready
			 * without any of its container crashing, for it to be considered available. Defaults to 0
			 * (pod will be considered available as soon as it is ready).
			 */
			minReadySeconds?: number

			/**
			 * The number of old history to retain to allow rollback. This is a pointer to distinguish
			 * between explicit zero and not specified. Defaults to 10.
			 */
			revisionHistoryLimit?: number

			/**
			 * A label query over pods that are managed by the daemon set. Must match in order to be
			 * controlled. If empty, defaulted to labels on Pod template. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
			 */
			selector?: meta.v1.LabelSelector

			/**
			 * DEPRECATED. A sequence number representing a specific generation of the template. Populated
			 * by the system. It can be set only during the creation.
			 */
			templateGeneration?: number

			/**
			 * An update strategy to replace existing DaemonSet pods with new pods.
			 */
			updateStrategy?: extensions.v1beta1.DaemonSetUpdateStrategy
		}

		/**
		 *
		 */
		export interface DaemonSetUpdateStrategy {
			/**
			 * Rolling update config params. Present only if type = "RollingUpdate".
			 */
			rollingUpdate?: extensions.v1beta1.RollingUpdateDaemonSet

			/**
			 * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is OnDelete.
			 */
			type?: string
		}

		/**
		 * Deployment enables declarative updates for Pods and ReplicaSets.
		 *
		 * @deprecated extensions/v1beta1/Deployment is deprecated by apps/v1/Deployment and not
		 * supported by Kubernetes v1.16+ clusters.
		 */
		export interface Deployment {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Deployment'

			/**
			 * Standard object metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of the Deployment.
			 */
			spec?: extensions.v1beta1.DeploymentSpec
		}

		export function isDeployment(o: any): o is Deployment {
			return o.apiVersion == 'extensions/v1beta1' && o.kind == 'Deployment'
		}

		/**
		 * DeploymentCondition describes the state of a deployment at a certain point.
		 */
		export interface DeploymentCondition {
			/**
			 * Type of deployment condition.
			 */
			type: string

			/**
			 * Last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * The last time this condition was updated.
			 */
			lastUpdateTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * DeploymentList is a list of Deployments.
		 */
		export interface DeploymentList {
			/**
			 * Items is the list of Deployments.
			 */
			items: extensions.v1beta1.Deployment[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'DeploymentList'

			/**
			 * Standard list metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isDeploymentList(o: any): o is DeploymentList {
			return o.apiVersion == 'extensions/v1beta1' && o.kind == 'DeploymentList'
		}

		/**
		 * DEPRECATED. DeploymentRollback stores the information required to rollback a deployment.
		 */
		export interface DeploymentRollback {
			/**
			 * Required: This must match the Name of a deployment.
			 */
			name: string

			/**
			 * The config of this deployment rollback.
			 */
			rollbackTo: extensions.v1beta1.RollbackConfig

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string

			/**
			 * The annotations to be updated to a deployment
			 */
			updatedAnnotations?: { [key: string]: string }
		}

		export function isDeploymentRollback(o: any): o is DeploymentRollback {
			return (
				o.apiVersion == 'extensions/v1beta1' && o.kind == 'DeploymentRollback'
			)
		}

		/**
		 * DeploymentSpec is the specification of the desired behavior of the Deployment.
		 */
		export interface DeploymentSpec {
			/**
			 * Template describes the pods that will be created.
			 */
			template: core.v1.PodTemplateSpec

			/**
			 * Minimum number of seconds for which a newly created pod should be ready without any of its
			 * container crashing, for it to be considered available. Defaults to 0 (pod will be
			 * considered available as soon as it is ready)
			 */
			minReadySeconds?: number

			/**
			 * Indicates that the deployment is paused and will not be processed by the deployment
			 * controller.
			 */
			paused?: boolean

			/**
			 * The maximum time in seconds for a deployment to make progress before it is considered to be
			 * failed. The deployment controller will continue to process failed deployments and a
			 * condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status.
			 * Note that progress will not be estimated during the time a deployment is paused. This is
			 * set to the max value of int32 (i.e. 2147483647) by default, which means "no deadline".
			 */
			progressDeadlineSeconds?: number

			/**
			 * Number of desired pods. This is a pointer to distinguish between explicit zero and not
			 * specified. Defaults to 1.
			 */
			replicas?: number

			/**
			 * The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish
			 * between explicit zero and not specified. This is set to the max value of int32 (i.e.
			 * 2147483647) by default, which means "retaining all old RelicaSets".
			 */
			revisionHistoryLimit?: number

			/**
			 * DEPRECATED. The config this deployment is rolling back to. Will be cleared after rollback
			 * is done.
			 */
			rollbackTo?: extensions.v1beta1.RollbackConfig

			/**
			 * Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the
			 * ones affected by this deployment.
			 */
			selector?: meta.v1.LabelSelector

			/**
			 * The deployment strategy to use to replace existing pods with new ones.
			 */
			strategy?: extensions.v1beta1.DeploymentStrategy
		}

		/**
		 * DeploymentStrategy describes how to replace existing pods with new ones.
		 */
		export interface DeploymentStrategy {
			/**
			 * Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
			 */
			rollingUpdate?: extensions.v1beta1.RollingUpdateDeployment

			/**
			 * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
			 */
			type?: string
		}

		/**
		 * FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
		 * Deprecated: use FSGroupStrategyOptions from policy API Group instead.
		 */
		export interface FSGroupStrategyOptions {
			/**
			 * ranges are the allowed ranges of fs groups.  If you would like to force a single fs group
			 * then supply a single range with the same start and end. Required for MustRunAs.
			 */
			ranges?: extensions.v1beta1.IDRange[]

			/**
			 * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
			 */
			rule?: string
		}

		/**
		 * HTTPIngressPath associates a path regex with a backend. Incoming urls matching the path are
		 * forwarded to the backend.
		 */
		export interface HTTPIngressPath {
			/**
			 * Backend defines the referenced service endpoint to which the traffic will be forwarded to.
			 */
			backend: extensions.v1beta1.IngressBackend

			/**
			 * Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the
			 * egrep/unix syntax, not the perl syntax) matched against the path of an incoming request.
			 * Currently it can contain characters disallowed from the conventional "path" part of a URL
			 * as defined by RFC 3986. Paths must begin with a '/'. If unspecified, the path defaults to a
			 * catch all sending traffic to the backend.
			 */
			path?: string
		}

		/**
		 * HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example:
		 * http://<host>/<path>?<searchpart> -> backend where where parts of the url correspond to RFC
		 * 3986, this resource will be used to match against everything after the last '/' and before
		 * the first '?' or '#'.
		 */
		export interface HTTPIngressRuleValue {
			/**
			 * A collection of paths that map requests to backends.
			 */
			paths: extensions.v1beta1.HTTPIngressPath[]
		}

		/**
		 * HostPortRange defines a range of host ports that will be enabled by a policy for pods to use.
		 * It requires both the start and end to be defined. Deprecated: use HostPortRange from policy
		 * API Group instead.
		 */
		export interface HostPortRange {
			/**
			 * max is the end of the range, inclusive.
			 */
			max: number

			/**
			 * min is the start of the range, inclusive.
			 */
			min: number
		}

		/**
		 * IDRange provides a min/max of an allowed range of IDs. Deprecated: use IDRange from policy
		 * API Group instead.
		 */
		export interface IDRange {
			/**
			 * max is the end of the range, inclusive.
			 */
			max: number

			/**
			 * min is the start of the range, inclusive.
			 */
			min: number
		}

		/**
		 * DEPRECATED 1.9 - This group version of IPBlock is deprecated by networking/v1/IPBlock.
		 * IPBlock describes a particular CIDR (Ex. "192.168.1.1/24") that is allowed to the pods
		 * matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should
		 * not be included within this rule.
		 */
		export interface IPBlock {
			/**
			 * CIDR is a string representing the IP Block Valid examples are "192.168.1.1/24"
			 */
			cidr: string

			/**
			 * Except is a slice of CIDRs that should not be included within an IP Block Valid examples
			 * are "192.168.1.1/24" Except values will be rejected if they are outside the CIDR range
			 */
			except?: string[]
		}

		/**
		 * Ingress is a collection of rules that allow inbound connections to reach the endpoints
		 * defined by a backend. An Ingress can be configured to give services externally-reachable
		 * urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.
		 *
		 * @deprecated extensions/v1beta1/Ingress is deprecated by networking/v1beta1/Ingress and not
		 * supported by Kubernetes v1.20+ clusters.
		 */
		export interface Ingress {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Ingress'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec is the desired state of the Ingress. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: extensions.v1beta1.IngressSpec
		}

		export function isIngress(o: any): o is Ingress {
			return o.apiVersion == 'extensions/v1beta1' && o.kind == 'Ingress'
		}

		/**
		 * IngressBackend describes all endpoints for a given service and port.
		 */
		export interface IngressBackend {
			/**
			 * Specifies the name of the referenced service.
			 */
			serviceName: string

			/**
			 * Specifies the port of the referenced service.
			 */
			servicePort: number | string
		}

		/**
		 * IngressList is a collection of Ingress.
		 */
		export interface IngressList {
			/**
			 * Items is the list of Ingress.
			 */
			items: extensions.v1beta1.Ingress[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'IngressList'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isIngressList(o: any): o is IngressList {
			return o.apiVersion == 'extensions/v1beta1' && o.kind == 'IngressList'
		}

		/**
		 * IngressRule represents the rules mapping the paths under a specified host to the related
		 * backend services. Incoming requests are first evaluated for a host match, then routed to the
		 * backend associated with the matching IngressRuleValue.
		 */
		export interface IngressRule {
			/**
			 * Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the
			 * following deviations from the "host" part of the URI as defined in the RFC: 1. IPs are not
			 * allowed. Currently an IngressRuleValue can only apply to the
			 * 	  IP in the Spec of the parent Ingress.
			 * 2. The `:` delimiter is not respected because ports are not allowed.
			 * 	  Currently the port of an Ingress is implicitly :80 for http and
			 * 	  :443 for https.
			 * Both these may change in the future. Incoming requests are matched against the host before
			 * the IngressRuleValue. If the host is unspecified, the Ingress routes all traffic based on
			 * the specified IngressRuleValue.
			 */
			host?: string

			http?: extensions.v1beta1.HTTPIngressRuleValue
		}

		/**
		 * IngressSpec describes the Ingress the user wishes to exist.
		 */
		export interface IngressSpec {
			/**
			 * A default backend capable of servicing requests that don't match any rule. At least one of
			 * 'backend' or 'rules' must be specified. This field is optional to allow the loadbalancer
			 * controller or defaulting logic to specify a global default.
			 */
			backend?: extensions.v1beta1.IngressBackend

			/**
			 * A list of host rules used to configure the Ingress. If unspecified, or no rule matches, all
			 * traffic is sent to the default backend.
			 */
			rules?: extensions.v1beta1.IngressRule[]

			/**
			 * TLS configuration. Currently the Ingress only supports a single TLS port, 443. If multiple
			 * members of this list specify different hosts, they will be multiplexed on the same port
			 * according to the hostname specified through the SNI TLS extension, if the ingress
			 * controller fulfilling the ingress supports SNI.
			 */
			tls?: extensions.v1beta1.IngressTLS[]
		}

		/**
		 * IngressTLS describes the transport layer security associated with an Ingress.
		 */
		export interface IngressTLS {
			/**
			 * Hosts are a list of hosts included in the TLS certificate. The values in this list must
			 * match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the
			 * loadbalancer controller fulfilling this Ingress, if left unspecified.
			 */
			hosts?: string[]

			/**
			 * SecretName is the name of the secret used to terminate SSL traffic on 443. Field is left
			 * optional to allow SSL routing based on SNI hostname alone. If the SNI host in a listener
			 * conflicts with the "Host" header field used by an IngressRule, the SNI host is used for
			 * termination and value of the Host header is used for routing.
			 */
			secretName?: string
		}

		/**
		 * NetworkPolicy describes what network traffic is allowed for a set of Pods
		 *
		 * @deprecated extensions/v1beta1/NetworkPolicy is deprecated by networking/v1/NetworkPolicy and
		 * not supported by Kubernetes v1.16+ clusters.
		 */
		export interface NetworkPolicy {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'NetworkPolicy'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior for this NetworkPolicy.
			 */
			spec?: extensions.v1beta1.NetworkPolicySpec
		}

		export function isNetworkPolicy(o: any): o is NetworkPolicy {
			return o.apiVersion == 'extensions/v1beta1' && o.kind == 'NetworkPolicy'
		}

		/**
		 * DEPRECATED 1.9 - This group version of NetworkPolicyEgressRule is deprecated by
		 * networking/v1/NetworkPolicyEgressRule. NetworkPolicyEgressRule describes a particular set of
		 * traffic that is allowed out of pods matched by a NetworkPolicySpec's podSelector. The traffic
		 * must match both ports and to. This type is beta-level in 1.8
		 */
		export interface NetworkPolicyEgressRule {
			/**
			 * List of destination ports for outgoing traffic. Each item in this list is combined using a
			 * logical OR. If this field is empty or missing, this rule matches all ports (traffic not
			 * restricted by port). If this field is present and contains at least one item, then this
			 * rule allows traffic only if the traffic matches at least one port in the list.
			 */
			ports?: extensions.v1beta1.NetworkPolicyPort[]

			/**
			 * List of destinations for outgoing traffic of pods selected for this rule. Items in this
			 * list are combined using a logical OR operation. If this field is empty or missing, this
			 * rule matches all destinations (traffic not restricted by destination). If this field is
			 * present and contains at least one item, this rule allows traffic only if the traffic
			 * matches at least one item in the to list.
			 */
			to?: extensions.v1beta1.NetworkPolicyPeer[]
		}

		/**
		 * DEPRECATED 1.9 - This group version of NetworkPolicyIngressRule is deprecated by
		 * networking/v1/NetworkPolicyIngressRule. This NetworkPolicyIngressRule matches traffic if and
		 * only if the traffic matches both ports AND from.
		 */
		export interface NetworkPolicyIngressRule {
			/**
			 * List of sources which should be able to access the pods selected for this rule. Items in
			 * this list are combined using a logical OR operation. If this field is empty or missing,
			 * this rule matches all sources (traffic not restricted by source). If this field is present
			 * and contains at least one item, this rule allows traffic only if the traffic matches at
			 * least one item in the from list.
			 */
			from?: extensions.v1beta1.NetworkPolicyPeer[]

			/**
			 * List of ports which should be made accessible on the pods selected for this rule. Each item
			 * in this list is combined using a logical OR. If this field is empty or missing, this rule
			 * matches all ports (traffic not restricted by port). If this field is present and contains
			 * at least one item, then this rule allows traffic only if the traffic matches at least one
			 * port in the list.
			 */
			ports?: extensions.v1beta1.NetworkPolicyPort[]
		}

		/**
		 * Network Policy List is a list of NetworkPolicy objects.
		 *
		 * @deprecated extensions/v1beta1/NetworkPolicyList is deprecated by
		 * networking/v1/NetworkPolicyList and not supported by Kubernetes v1.16+ clusters.
		 */
		export interface NetworkPolicyList {
			/**
			 * Items is a list of schema objects.
			 */
			items: extensions.v1beta1.NetworkPolicy[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'NetworkPolicyList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isNetworkPolicyList(o: any): o is NetworkPolicyList {
			return (
				o.apiVersion == 'extensions/v1beta1' && o.kind == 'NetworkPolicyList'
			)
		}

		/**
		 * DEPRECATED 1.9 - This group version of NetworkPolicyPeer is deprecated by
		 * networking/v1/NetworkPolicyPeer.
		 */
		export interface NetworkPolicyPeer {
			/**
			 * IPBlock defines policy on a particular IPBlock. If this field is set then neither of the
			 * other fields can be.
			 */
			ipBlock?: extensions.v1beta1.IPBlock

			/**
			 * Selects Namespaces using cluster-scoped labels. This field follows standard label selector
			 * semantics; if present but empty, it selects all namespaces.
			 *
			 * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods matching
			 * PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it selects all Pods
			 * in the Namespaces selected by NamespaceSelector.
			 */
			namespaceSelector?: meta.v1.LabelSelector

			/**
			 * This is a label selector which selects Pods. This field follows standard label selector
			 * semantics; if present but empty, it selects all pods.
			 *
			 * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
			 * matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it selects
			 * the Pods matching PodSelector in the policy's own Namespace.
			 */
			podSelector?: meta.v1.LabelSelector
		}

		/**
		 * DEPRECATED 1.9 - This group version of NetworkPolicyPort is deprecated by
		 * networking/v1/NetworkPolicyPort.
		 */
		export interface NetworkPolicyPort {
			/**
			 * If specified, the port on the given protocol.  This can either be a numerical or named port
			 * on a pod.  If this field is not provided, this matches all port names and numbers. If
			 * present, only traffic on the specified protocol AND port will be matched.
			 */
			port?: number | string

			/**
			 * Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified,
			 * this field defaults to TCP.
			 */
			protocol?: string
		}

		/**
		 * DEPRECATED 1.9 - This group version of NetworkPolicySpec is deprecated by
		 * networking/v1/NetworkPolicySpec.
		 */
		export interface NetworkPolicySpec {
			/**
			 * Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules is
			 * applied to any pods selected by this field. Multiple network policies can select the same
			 * set of pods.  In this case, the ingress rules for each are combined additively. This field
			 * is NOT optional and follows standard label selector semantics. An empty podSelector matches
			 * all pods in this namespace.
			 */
			podSelector: meta.v1.LabelSelector

			/**
			 * List of egress rules to be applied to the selected pods. Outgoing traffic is allowed if
			 * there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
			 * traffic), OR if the traffic matches at least one egress rule across all of the
			 * NetworkPolicy objects whose podSelector matches the pod. If this field is empty then this
			 * NetworkPolicy limits all outgoing traffic (and serves solely to ensure that the pods it
			 * selects are isolated by default). This field is beta-level in 1.8
			 */
			egress?: extensions.v1beta1.NetworkPolicyEgressRule[]

			/**
			 * List of ingress rules to be applied to the selected pods. Traffic is allowed to a pod if
			 * there are no NetworkPolicies selecting the pod OR if the traffic source is the pod's local
			 * node, OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
			 * objects whose podSelector matches the pod. If this field is empty then this NetworkPolicy
			 * does not allow any traffic (and serves solely to ensure that the pods it selects are
			 * isolated by default).
			 */
			ingress?: extensions.v1beta1.NetworkPolicyIngressRule[]

			/**
			 * List of rule types that the NetworkPolicy relates to. Valid options are "Ingress",
			 * "Egress", or "Ingress,Egress". If this field is not specified, it will default based on the
			 * existence of Ingress or Egress rules; policies that contain an Egress section are assumed
			 * to affect Egress, and all policies (whether or not they contain an Ingress section) are
			 * assumed to affect Ingress. If you want to write an egress-only policy, you must explicitly
			 * specify policyTypes [ "Egress" ]. Likewise, if you want to write a policy that specifies
			 * that no egress is allowed, you must specify a policyTypes value that include "Egress"
			 * (since such a policy would not include an Egress section and would otherwise default to
			 * just [ "Ingress" ]). This field is beta-level in 1.8
			 */
			policyTypes?: string[]
		}

		/**
		 * PodSecurityPolicy governs the ability to make requests that affect the Security Context that
		 * will be applied to a pod and container.
		 *
		 * @deprecated extensions/v1beta1/PodSecurityPolicy is deprecated by
		 * policy/v1beta1/PodSecurityPolicy and not supported by Kubernetes v1.16+ clusters.
		 */
		export interface PodSecurityPolicy {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PodSecurityPolicy'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * spec defines the policy enforced.
			 */
			spec?: extensions.v1beta1.PodSecurityPolicySpec
		}

		export function isPodSecurityPolicy(o: any): o is PodSecurityPolicy {
			return (
				o.apiVersion == 'extensions/v1beta1' && o.kind == 'PodSecurityPolicy'
			)
		}

		/**
		 * PodSecurityPolicyList is a list of PodSecurityPolicy objects.
		 *
		 * @deprecated extensions/v1beta1/PodSecurityPolicyList is deprecated by
		 * policy/v1beta1/PodSecurityPolicyList and not supported by Kubernetes v1.16+ clusters.
		 */
		export interface PodSecurityPolicyList {
			/**
			 * items is a list of schema objects.
			 */
			items: extensions.v1beta1.PodSecurityPolicy[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PodSecurityPolicyList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isPodSecurityPolicyList(
			o: any
		): o is PodSecurityPolicyList {
			return (
				o.apiVersion == 'extensions/v1beta1' &&
				o.kind == 'PodSecurityPolicyList'
			)
		}

		/**
		 * PodSecurityPolicySpec defines the policy enforced. Deprecated: use PodSecurityPolicySpec from
		 * policy API Group instead.
		 */
		export interface PodSecurityPolicySpec {
			/**
			 * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
			 */
			fsGroup: extensions.v1beta1.FSGroupStrategyOptions

			/**
			 * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
			 */
			runAsUser: extensions.v1beta1.RunAsUserStrategyOptions

			/**
			 * seLinux is the strategy that will dictate the allowable labels that may be set.
			 */
			seLinux: extensions.v1beta1.SELinuxStrategyOptions

			/**
			 * supplementalGroups is the strategy that will dictate what supplemental groups are used by
			 * the SecurityContext.
			 */
			supplementalGroups: extensions.v1beta1.SupplementalGroupsStrategyOptions

			/**
			 * allowPrivilegeEscalation determines if a pod can request to allow privilege escalation. If
			 * unspecified, defaults to true.
			 */
			allowPrivilegeEscalation?: boolean

			/**
			 * AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be
			 * embedded within a pod spec. An empty value indicates that any CSI driver can be used for
			 * inline ephemeral volumes.
			 */
			allowedCSIDrivers?: extensions.v1beta1.AllowedCSIDriver[]

			/**
			 * allowedCapabilities is a list of capabilities that can be requested to add to the
			 * container. Capabilities in this field may be added at the pod author's discretion. You must
			 * not list a capability in both allowedCapabilities and requiredDropCapabilities.
			 */
			allowedCapabilities?: string[]

			/**
			 * allowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that all
			 * Flexvolumes may be used.  This parameter is effective only when the usage of the
			 * Flexvolumes is allowed in the "volumes" field.
			 */
			allowedFlexVolumes?: extensions.v1beta1.AllowedFlexVolume[]

			/**
			 * allowedHostPaths is a white list of allowed host paths. Empty indicates that all host paths
			 * may be used.
			 */
			allowedHostPaths?: extensions.v1beta1.AllowedHostPath[]

			/**
			 * AllowedProcMountTypes is a whitelist of allowed ProcMountTypes. Empty or nil indicates that
			 * only the DefaultProcMountType may be used. This requires the ProcMountType feature flag to
			 * be enabled.
			 */
			allowedProcMountTypes?: string[]

			/**
			 * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none. Each
			 * entry is either a plain sysctl name or ends in "*" in which case it is considered as a
			 * prefix of allowed sysctls. Single * means all unsafe sysctls are allowed. Kubelet has to
			 * whitelist all allowed unsafe sysctls explicitly to avoid rejection.
			 *
			 * Examples: e.g. "foo/*" allows "foo/bar", "foo/baz", etc. e.g. "foo.*" allows "foo.bar",
			 * "foo.baz", etc.
			 */
			allowedUnsafeSysctls?: string[]

			/**
			 * defaultAddCapabilities is the default set of capabilities that will be added to the
			 * container unless the pod spec specifically drops the capability.  You may not list a
			 * capability in both defaultAddCapabilities and requiredDropCapabilities. Capabilities added
			 * here are implicitly allowed, and need not be included in the allowedCapabilities list.
			 */
			defaultAddCapabilities?: string[]

			/**
			 * defaultAllowPrivilegeEscalation controls the default setting for whether a process can gain
			 * more privileges than its parent process.
			 */
			defaultAllowPrivilegeEscalation?: boolean

			/**
			 * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry is
			 * either a plain sysctl name or ends in "*" in which case it is considered as a prefix of
			 * forbidden sysctls. Single * means all sysctls are forbidden.
			 *
			 * Examples: e.g. "foo/*" forbids "foo/bar", "foo/baz", etc. e.g. "foo.*" forbids "foo.bar",
			 * "foo.baz", etc.
			 */
			forbiddenSysctls?: string[]

			/**
			 * hostIPC determines if the policy allows the use of HostIPC in the pod spec.
			 */
			hostIPC?: boolean

			/**
			 * hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
			 */
			hostNetwork?: boolean

			/**
			 * hostPID determines if the policy allows the use of HostPID in the pod spec.
			 */
			hostPID?: boolean

			/**
			 * hostPorts determines which host port ranges are allowed to be exposed.
			 */
			hostPorts?: extensions.v1beta1.HostPortRange[]

			/**
			 * privileged determines if a pod can request to be run as privileged.
			 */
			privileged?: boolean

			/**
			 * readOnlyRootFilesystem when set to true will force containers to run with a read only root
			 * file system.  If the container specifically requests to run with a non-read only root file
			 * system the PSP should deny the pod. If set to false the container may run with a read only
			 * root file system if it wishes but it will not be forced to.
			 */
			readOnlyRootFilesystem?: boolean

			/**
			 * requiredDropCapabilities are the capabilities that will be dropped from the container.
			 * These are required to be dropped and cannot be added.
			 */
			requiredDropCapabilities?: string[]

			/**
			 * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be
			 * set. If this field is omitted, the pod's RunAsGroup can take any value. This field requires
			 * the RunAsGroup feature gate to be enabled.
			 */
			runAsGroup?: extensions.v1beta1.RunAsGroupStrategyOptions

			/**
			 * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod. If
			 * this field is omitted, the pod's runtimeClassName field is unrestricted. Enforcement of
			 * this field depends on the RuntimeClass feature gate being enabled.
			 */
			runtimeClass?: extensions.v1beta1.RuntimeClassStrategyOptions

			/**
			 * volumes is a white list of allowed volume plugins. Empty indicates that no volumes may be
			 * used. To allow all volumes you may use '*'.
			 */
			volumes?: string[]
		}

		/**
		 * ReplicaSet ensures that a specified number of pod replicas are running at any given time.
		 *
		 * @deprecated extensions/v1beta1/ReplicaSet is deprecated by apps/v1/ReplicaSet and not
		 * supported by Kubernetes v1.16+ clusters.
		 */
		export interface ReplicaSet {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ReplicaSet'

			/**
			 * If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s)
			 * that the ReplicaSet manages. Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec defines the specification of the desired behavior of the ReplicaSet. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: extensions.v1beta1.ReplicaSetSpec
		}

		export function isReplicaSet(o: any): o is ReplicaSet {
			return o.apiVersion == 'extensions/v1beta1' && o.kind == 'ReplicaSet'
		}

		/**
		 * ReplicaSetCondition describes the state of a replica set at a certain point.
		 */
		export interface ReplicaSetCondition {
			/**
			 * Type of replica set condition.
			 */
			type: string

			/**
			 * The last time the condition transitioned from one status to another.
			 */
			lastTransitionTime?: string

			/**
			 * A human readable message indicating details about the transition.
			 */
			message?: string

			/**
			 * The reason for the condition's last transition.
			 */
			reason?: string
		}

		/**
		 * ReplicaSetList is a collection of ReplicaSets.
		 */
		export interface ReplicaSetList {
			/**
			 * List of ReplicaSets. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
			 */
			items: extensions.v1beta1.ReplicaSet[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'extensions/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ReplicaSetList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isReplicaSetList(o: any): o is ReplicaSetList {
			return o.apiVersion == 'extensions/v1beta1' && o.kind == 'ReplicaSetList'
		}

		/**
		 * ReplicaSetSpec is the specification of a ReplicaSet.
		 */
		export interface ReplicaSetSpec {
			/**
			 * Minimum number of seconds for which a newly created pod should be ready without any of its
			 * container crashing, for it to be considered available. Defaults to 0 (pod will be
			 * considered available as soon as it is ready)
			 */
			minReadySeconds?: number

			/**
			 * Replicas is the number of desired replicas. This is a pointer to distinguish between
			 * explicit zero and unspecified. Defaults to 1. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
			 */
			replicas?: number

			/**
			 * Selector is a label query over pods that should match the replica count. If the selector is
			 * empty, it is defaulted to the labels present on the pod template. Label keys and values
			 * that must match in order to be controlled by this replica set. More info:
			 * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
			 */
			selector?: meta.v1.LabelSelector

			/**
			 * Template is the object that describes the pod that will be created if insufficient replicas
			 * are detected. More info:
			 * https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
			 */
			template?: core.v1.PodTemplateSpec
		}

		/**
		 * DEPRECATED.
		 */
		export interface RollbackConfig {
			/**
			 * The revision to rollback to. If set to 0, rollback to the last revision.
			 */
			revision?: number
		}

		/**
		 * Spec to control the desired behavior of daemon set rolling update.
		 */
		export interface RollingUpdateDaemonSet {
			/**
			 * The maximum number of DaemonSet pods that can be unavailable during the update. Value can
			 * be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the
			 * start of the update (ex: 10%). Absolute number is calculated from percentage by rounding
			 * up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at most 30% of
			 * the total number of nodes that should be running the daemon pod (i.e.
			 * status.desiredNumberScheduled) can have their pods stopped for an update at any given time.
			 * The update starts by stopping at most 30% of those DaemonSet pods and then brings up new
			 * DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other
			 * DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are
			 * available at all times during the update.
			 */
			maxUnavailable?: number | string
		}

		/**
		 * Spec to control the desired behavior of rolling update.
		 */
		export interface RollingUpdateDeployment {
			/**
			 * The maximum number of pods that can be scheduled above the desired number of pods. Value
			 * can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not
			 * be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up.
			 * By default, a value of 1 is used. Example: when this is set to 30%, the new RC can be
			 * scaled up immediately when the rolling update starts, such that the total number of old and
			 * new pods do not exceed 130% of desired pods. Once old pods have been killed, new RC can be
			 * scaled up further, ensuring that total number of pods running at any time during the update
			 * is at most 130% of desired pods.
			 */
			maxSurge?: number | string

			/**
			 * The maximum number of pods that can be unavailable during the update. Value can be an
			 * absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is
			 * calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. By
			 * default, a fixed value of 1 is used. Example: when this is set to 30%, the old RC can be
			 * scaled down to 70% of desired pods immediately when the rolling update starts. Once new
			 * pods are ready, old RC can be scaled down further, followed by scaling up the new RC,
			 * ensuring that the total number of pods available at all times during the update is at least
			 * 70% of desired pods.
			 */
			maxUnavailable?: number | string
		}

		/**
		 * RunAsGroupStrategyOptions defines the strategy type and any options used to create the
		 * strategy. Deprecated: use RunAsGroupStrategyOptions from policy API Group instead.
		 */
		export interface RunAsGroupStrategyOptions {
			/**
			 * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
			 */
			rule: string

			/**
			 * ranges are the allowed ranges of gids that may be used. If you would like to force a single
			 * gid then supply a single range with the same start and end. Required for MustRunAs.
			 */
			ranges?: extensions.v1beta1.IDRange[]
		}

		/**
		 * RunAsUserStrategyOptions defines the strategy type and any options used to create the
		 * strategy. Deprecated: use RunAsUserStrategyOptions from policy API Group instead.
		 */
		export interface RunAsUserStrategyOptions {
			/**
			 * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
			 */
			rule: string

			/**
			 * ranges are the allowed ranges of uids that may be used. If you would like to force a single
			 * uid then supply a single range with the same start and end. Required for MustRunAs.
			 */
			ranges?: extensions.v1beta1.IDRange[]
		}

		/**
		 * RuntimeClassStrategyOptions define the strategy that will dictate the allowable
		 * RuntimeClasses for a pod.
		 */
		export interface RuntimeClassStrategyOptions {
			/**
			 * allowedRuntimeClassNames is a whitelist of RuntimeClass names that may be specified on a
			 * pod. A value of "*" means that any RuntimeClass name is allowed, and must be the only item
			 * in the list. An empty list requires the RuntimeClassName field to be unset.
			 */
			allowedRuntimeClassNames: string[]

			/**
			 * defaultRuntimeClassName is the default RuntimeClassName to set on the pod. The default MUST
			 * be allowed by the allowedRuntimeClassNames list. A value of nil does not mutate the Pod.
			 */
			defaultRuntimeClassName?: string
		}

		/**
		 * SELinuxStrategyOptions defines the strategy type and any options used to create the strategy.
		 * Deprecated: use SELinuxStrategyOptions from policy API Group instead.
		 */
		export interface SELinuxStrategyOptions {
			/**
			 * rule is the strategy that will dictate the allowable labels that may be set.
			 */
			rule: string

			/**
			 * seLinuxOptions required to run as; required for MustRunAs More info:
			 * https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
			 */
			seLinuxOptions?: core.v1.SELinuxOptions
		}

		/**
		 * represents a scaling request for a resource.
		 */
		export interface Scale {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string

			/**
			 * Standard object metadata; More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * defines the behavior of the scale. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
			 */
			spec?: extensions.v1beta1.ScaleSpec
		}

		export function isScale(o: any): o is Scale {
			return o.apiVersion == 'extensions/v1beta1' && o.kind == 'Scale'
		}

		/**
		 * describes the attributes of a scale subresource
		 */
		export interface ScaleSpec {
			/**
			 * desired number of instances for the scaled object.
			 */
			replicas?: number
		}

		/**
		 * SupplementalGroupsStrategyOptions defines the strategy type and options used to create the
		 * strategy. Deprecated: use SupplementalGroupsStrategyOptions from policy API Group instead.
		 */
		export interface SupplementalGroupsStrategyOptions {
			/**
			 * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
			 * supplemental group then supply a single range with the same start and end. Required for
			 * MustRunAs.
			 */
			ranges?: extensions.v1beta1.IDRange[]

			/**
			 * rule is the strategy that will dictate what supplemental groups is used in the
			 * SecurityContext.
			 */
			rule?: string
		}
	}
}

export namespace flowcontrol {
	export namespace v1alpha1 {
		/**
		 * FlowDistinguisherMethod specifies the method of a flow distinguisher.
		 */
		export interface FlowDistinguisherMethod {
			/**
			 * `type` is the type of flow distinguisher method The supported types are "ByUser" and
			 * "ByNamespace". Required.
			 */
			type: string
		}

		/**
		 * FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of
		 * inbound API requests with similar attributes and is identified by a pair of strings: the name
		 * of the FlowSchema and a "flow distinguisher".
		 */
		export interface FlowSchema {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'flowcontrol.apiserver.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'FlowSchema'

			/**
			 * `metadata` is the standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * `spec` is the specification of the desired behavior of a FlowSchema. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: flowcontrol.v1alpha1.FlowSchemaSpec
		}

		export function isFlowSchema(o: any): o is FlowSchema {
			return (
				o.apiVersion == 'flowcontrol.apiserver.k8s.io/v1alpha1' &&
				o.kind == 'FlowSchema'
			)
		}

		/**
		 * FlowSchemaCondition describes conditions for a FlowSchema.
		 */
		export interface FlowSchemaCondition {
			/**
			 * `lastTransitionTime` is the last time the condition transitioned from one status to
			 * another.
			 */
			lastTransitionTime?: string

			/**
			 * `message` is a human-readable message indicating details about last transition.
			 */
			message?: string

			/**
			 * `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
			 */
			reason?: string

			/**
			 * `type` is the type of the condition. Required.
			 */
			type?: string
		}

		/**
		 * FlowSchemaList is a list of FlowSchema objects.
		 */
		export interface FlowSchemaList {
			/**
			 * `items` is a list of FlowSchemas.
			 */
			items: flowcontrol.v1alpha1.FlowSchema[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'flowcontrol.apiserver.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'FlowSchemaList'

			/**
			 * `metadata` is the standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isFlowSchemaList(o: any): o is FlowSchemaList {
			return (
				o.apiVersion == 'flowcontrol.apiserver.k8s.io/v1alpha1' &&
				o.kind == 'FlowSchemaList'
			)
		}

		/**
		 * FlowSchemaSpec describes how the FlowSchema's specification looks like.
		 */
		export interface FlowSchemaSpec {
			/**
			 * `priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the cluster.
			 * If the reference cannot be resolved, the FlowSchema will be ignored and marked as invalid
			 * in its status. Required.
			 */
			priorityLevelConfiguration: flowcontrol.v1alpha1.PriorityLevelConfigurationReference

			/**
			 * `distinguisherMethod` defines how to compute the flow distinguisher for requests that match
			 * this schema. `nil` specifies that the distinguisher is disabled and thus will always be the
			 * empty string.
			 */
			distinguisherMethod?: flowcontrol.v1alpha1.FlowDistinguisherMethod

			/**
			 * `matchingPrecedence` is used to choose among the FlowSchemas that match a given request.
			 * The chosen FlowSchema is among those with the numerically lowest (which we take to be
			 * logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be non-negative.
			 * Note that if the precedence is not specified or zero, it will be set to 1000 as default.
			 */
			matchingPrecedence?: number

			/**
			 * `rules` describes which requests will match this flow schema. This FlowSchema matches a
			 * request if and only if at least one member of rules matches the request. if it is an empty
			 * slice, there will be no requests matching the FlowSchema.
			 */
			rules?: flowcontrol.v1alpha1.PolicyRulesWithSubjects[]
		}

		/**
		 * GroupSubject holds detailed information for group-kind subject.
		 */
		export interface GroupSubject {
			/**
			 * name is the user group that matches, or "*" to match all user groups. See
			 * https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go for
			 * some well-known group names. Required.
			 */
			name: string
		}

		/**
		 * LimitResponse defines how to handle requests that can not be executed right now.
		 */
		export interface LimitResponse {
			/**
			 * `type` is "Queue" or "Reject". "Queue" means that requests that can not be executed upon
			 * arrival are held in a queue until they can be executed or a queuing limit is reached.
			 * "Reject" means that requests that can not be executed upon arrival are rejected. Required.
			 */
			type: string

			/**
			 * `queuing` holds the configuration parameters for queuing. This field may be non-empty only
			 * if `type` is `"Queue"`.
			 */
			queuing?: flowcontrol.v1alpha1.QueuingConfiguration
		}

		/**
		 * LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to
		 * limits. It addresses two issues:
		 *  * How are requests for this priority level limited?
		 *  * What should be done with requests that exceed the limit?
		 */
		export interface LimitedPriorityLevelConfiguration {
			/**
			 * `assuredConcurrencyShares` (ACS) configures the execution limit, which is a limit on the
			 * number of requests of this priority level that may be exeucting at a given time.  ACS must
			 * be a positive number. The server's concurrency limit (SCL) is divided among the
			 * concurrency-controlled priority levels in proportion to their assured concurrency shares.
			 * This produces the assured concurrency value (ACV) --- the number of requests that may be
			 * executing at a time --- for each such priority level:
			 *
			 *             ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )
			 *
			 * bigger numbers of ACS mean more reserved concurrent requests (at the expense of every other
			 * PL). This field has a default value of 30.
			 */
			assuredConcurrencyShares?: number

			/**
			 * `limitResponse` indicates what to do with requests that can not be executed right now
			 */
			limitResponse?: flowcontrol.v1alpha1.LimitResponse
		}

		/**
		 * NonResourcePolicyRule is a predicate that matches non-resource requests according to their
		 * verb and the target non-resource URL. A NonResourcePolicyRule matches a request if and only
		 * if both (a) at least one member of verbs matches the request and (b) at least one member of
		 * nonResourceURLs matches the request.
		 */
		export interface NonResourcePolicyRule {
			/**
			 * `nonResourceURLs` is a set of url prefixes that a user should have access to and may not be
			 * empty. For example:
			 *   - "/healthz" is legal
			 *   - "/hea*" is illegal
			 *   - "/hea" is legal but matches nothing
			 *   - "/hea/*" also matches nothing
			 *   - "/healthz/*" matches all per-component health checks.
			 * "*" matches all non-resource urls. if it is present, it must be the only entry. Required.
			 */
			nonResourceURLs: string[]

			/**
			 * `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs. If it is
			 * present, it must be the only entry. Required.
			 */
			verbs: string[]
		}

		/**
		 * PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver. The test
		 * considers the subject making the request, the verb being requested, and the resource to be
		 * acted upon. This PolicyRulesWithSubjects matches a request if and only if both (a) at least
		 * one member of subjects matches the request and (b) at least one member of resourceRules or
		 * nonResourceRules matches the request.
		 */
		export interface PolicyRulesWithSubjects {
			/**
			 * subjects is the list of normal user, serviceaccount, or group that this rule cares about.
			 * There must be at least one member in this slice. A slice that includes both the
			 * system:authenticated and system:unauthenticated user groups matches every request.
			 * Required.
			 */
			subjects: flowcontrol.v1alpha1.Subject[]

			/**
			 * `nonResourceRules` is a list of NonResourcePolicyRules that identify matching requests
			 * according to their verb and the target non-resource URL.
			 */
			nonResourceRules?: flowcontrol.v1alpha1.NonResourcePolicyRule[]

			/**
			 * `resourceRules` is a slice of ResourcePolicyRules that identify matching requests according
			 * to their verb and the target resource. At least one of `resourceRules` and
			 * `nonResourceRules` has to be non-empty.
			 */
			resourceRules?: flowcontrol.v1alpha1.ResourcePolicyRule[]
		}

		/**
		 * PriorityLevelConfiguration represents the configuration of a priority level.
		 */
		export interface PriorityLevelConfiguration {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'flowcontrol.apiserver.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PriorityLevelConfiguration'

			/**
			 * `metadata` is the standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * `spec` is the specification of the desired behavior of a "request-priority". More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: flowcontrol.v1alpha1.PriorityLevelConfigurationSpec
		}

		export function isPriorityLevelConfiguration(
			o: any
		): o is PriorityLevelConfiguration {
			return (
				o.apiVersion == 'flowcontrol.apiserver.k8s.io/v1alpha1' &&
				o.kind == 'PriorityLevelConfiguration'
			)
		}

		/**
		 * PriorityLevelConfigurationCondition defines the condition of priority level.
		 */
		export interface PriorityLevelConfigurationCondition {
			/**
			 * `lastTransitionTime` is the last time the condition transitioned from one status to
			 * another.
			 */
			lastTransitionTime?: string

			/**
			 * `message` is a human-readable message indicating details about last transition.
			 */
			message?: string

			/**
			 * `reason` is a unique, one-word, CamelCase reason for the condition's last transition.
			 */
			reason?: string

			/**
			 * `type` is the type of the condition. Required.
			 */
			type?: string
		}

		/**
		 * PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects.
		 */
		export interface PriorityLevelConfigurationList {
			/**
			 * `items` is a list of request-priorities.
			 */
			items: flowcontrol.v1alpha1.PriorityLevelConfiguration[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'flowcontrol.apiserver.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PriorityLevelConfigurationList'

			/**
			 * `metadata` is the standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isPriorityLevelConfigurationList(
			o: any
		): o is PriorityLevelConfigurationList {
			return (
				o.apiVersion == 'flowcontrol.apiserver.k8s.io/v1alpha1' &&
				o.kind == 'PriorityLevelConfigurationList'
			)
		}

		/**
		 * PriorityLevelConfigurationReference contains information that points to the
		 * "request-priority" being used.
		 */
		export interface PriorityLevelConfigurationReference {
			/**
			 * `name` is the name of the priority level configuration being referenced Required.
			 */
			name: string
		}

		/**
		 * PriorityLevelConfigurationSpec specifies the configuration of a priority level.
		 */
		export interface PriorityLevelConfigurationSpec {
			/**
			 * `type` indicates whether this priority level is subject to limitation on request execution.
			 * A value of `"Exempt"` means that requests of this priority level are not subject to a limit
			 * (and thus are never queued) and do not detract from the capacity made available to other
			 * priority levels.  A value of `"Limited"` means that (a) requests of this priority level
			 * _are_ subject to limits and (b) some of the server's limited capacity is made available
			 * exclusively to this priority level. Required.
			 */
			type: string

			/**
			 * `limited` specifies how requests are handled for a Limited priority level. This field must
			 * be non-empty if and only if `type` is `"Limited"`.
			 */
			limited?: flowcontrol.v1alpha1.LimitedPriorityLevelConfiguration
		}

		/**
		 * QueuingConfiguration holds the configuration parameters for queuing
		 */
		export interface QueuingConfiguration {
			/**
			 * `handSize` is a small positive number that configures the shuffle sharding of requests into
			 * queues.  When enqueuing a request at this priority level the request's flow identifier (a
			 * string pair) is hashed and the hash value is used to shuffle the list of queues and deal a
			 * hand of the size specified here.  The request is put into one of the shortest queues in
			 * that hand. `handSize` must be no larger than `queues`, and should be significantly smaller
			 * (so that a few heavy flows do not saturate most of the queues).  See the user-facing
			 * documentation for more extensive guidance on setting this field.  This field has a default
			 * value of 8.
			 */
			handSize?: number

			/**
			 * `queueLengthLimit` is the maximum number of requests allowed to be waiting in a given queue
			 * of this priority level at a time; excess requests are rejected.  This value must be
			 * positive.  If not specified, it will be defaulted to 50.
			 */
			queueLengthLimit?: number

			/**
			 * `queues` is the number of queues for this priority level. The queues exist independently at
			 * each apiserver. The value must be positive.  Setting it to 1 effectively precludes
			 * shufflesharding and thus makes the distinguisher method of associated flow schemas
			 * irrelevant.  This field has a default value of 64.
			 */
			queues?: number
		}

		/**
		 * ResourcePolicyRule is a predicate that matches some resource requests, testing the request's
		 * verb and the target resource. A ResourcePolicyRule matches a resource request if and only if:
		 * (a) at least one member of verbs matches the request, (b) at least one member of apiGroups
		 * matches the request, (c) at least one member of resources matches the request, and (d) least
		 * one member of namespaces matches the request.
		 */
		export interface ResourcePolicyRule {
			/**
			 * `apiGroups` is a list of matching API groups and may not be empty. "*" matches all API
			 * groups and, if present, must be the only entry. Required.
			 */
			apiGroups: string[]

			/**
			 * `resources` is a list of matching resources (i.e., lowercase and plural) with, if desired,
			 * subresource.  For example, [ "services", "nodes/status" ].  This list may not be empty. "*"
			 * matches all resources and, if present, must be the only entry. Required.
			 */
			resources: string[]

			/**
			 * `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs and, if
			 * present, must be the only entry. Required.
			 */
			verbs: string[]

			/**
			 * `clusterScope` indicates whether to match requests that do not specify a namespace (which
			 * happens either because the resource is not namespaced or the request targets all
			 * namespaces). If this field is omitted or false then the `namespaces` field must contain a
			 * non-empty list.
			 */
			clusterScope?: boolean

			/**
			 * `namespaces` is a list of target namespaces that restricts matches.  A request that
			 * specifies a target namespace matches only if either (a) this list contains that target
			 * namespace or (b) this list contains "*".  Note that "*" matches any specified namespace but
			 * does not match a request that _does not specify_ a namespace (see the `clusterScope` field
			 * for that). This list may be empty, but only if `clusterScope` is true.
			 */
			namespaces?: string[]
		}

		/**
		 * ServiceAccountSubject holds detailed information for service-account-kind subject.
		 */
		export interface ServiceAccountSubject {
			/**
			 * `name` is the name of matching ServiceAccount objects, or "*" to match regardless of name.
			 * Required.
			 */
			name: string

			/**
			 * `namespace` is the namespace of matching ServiceAccount objects. Required.
			 */
			namespace: string
		}

		/**
		 * Subject matches the originator of a request, as identified by the request authentication
		 * system. There are three ways of matching an originator; by user, group, or service account.
		 */
		export interface Subject {
			/**
			 * Required
			 */
			kind: string

			group?: flowcontrol.v1alpha1.GroupSubject

			serviceAccount?: flowcontrol.v1alpha1.ServiceAccountSubject

			user?: flowcontrol.v1alpha1.UserSubject
		}

		/**
		 * UserSubject holds detailed information for user-kind subject.
		 */
		export interface UserSubject {
			/**
			 * `name` is the username that matches, or "*" to match all usernames. Required.
			 */
			name: string
		}
	}
}

export namespace meta {
	export namespace v1 {
		/**
		 * APIGroup contains the name, the supported versions, and the preferred version of a group.
		 */
		export interface APIGroup {
			/**
			 * name is the name of the group.
			 */
			name: string

			/**
			 * versions are the versions supported in this group.
			 */
			versions: meta.v1.GroupVersionForDiscovery[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string

			/**
			 * preferredVersion is the version preferred by the API server, which probably is the storage
			 * version.
			 */
			preferredVersion?: meta.v1.GroupVersionForDiscovery

			/**
			 * a map of client CIDR to server address that is serving this group. This is to help clients
			 * reach servers in the most network-efficient way possible. Clients can use the appropriate
			 * server address as per the CIDR that they match. In case of multiple matches, clients should
			 * use the longest matching CIDR. The server returns only those CIDRs that it thinks that the
			 * client can match. For example: the master will return an internal IP CIDR only, if the
			 * client reaches the server using an internal IP. Server looks at X-Forwarded-For header or
			 * X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
			 */
			serverAddressByClientCIDRs?: meta.v1.ServerAddressByClientCIDR[]
		}

		export function isAPIGroup(o: any): o is APIGroup {
			return o.apiVersion == 'v1' && o.kind == 'APIGroup'
		}

		/**
		 * APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis.
		 */
		export interface APIGroupList {
			/**
			 * groups is a list of APIGroup.
			 */
			groups: meta.v1.APIGroup[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string
		}

		export function isAPIGroupList(o: any): o is APIGroupList {
			return o.apiVersion == 'v1' && o.kind == 'APIGroupList'
		}

		/**
		 * APIResource specifies the name of a resource and whether it is namespaced.
		 */
		export interface APIResource {
			/**
			 * kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
			 */
			kind: string

			/**
			 * name is the plural name of the resource.
			 */
			name: string

			/**
			 * namespaced indicates if a resource is namespaced or not.
			 */
			namespaced: boolean

			/**
			 * singularName is the singular name of the resource.  This allows clients to handle plural
			 * and singular opaquely. The singularName is more correct for reporting status on a single
			 * item and both singular and plural are allowed from the kubectl CLI interface.
			 */
			singularName: string

			/**
			 * verbs is a list of supported kube verbs (this includes get, list, watch, create, update,
			 * patch, delete, deletecollection, and proxy)
			 */
			verbs: string[]

			/**
			 * categories is a list of the grouped resources this resource belongs to (e.g. 'all')
			 */
			categories?: string[]

			/**
			 * group is the preferred group of the resource.  Empty implies the group of the containing
			 * resource list. For subresources, this may have a different value, for example: Scale".
			 */
			group?: string

			/**
			 * shortNames is a list of suggested short names of the resource.
			 */
			shortNames?: string[]

			/**
			 * The hash value of the storage version, the version this resource is converted to when
			 * written to the data store. Value must be treated as opaque by clients. Only equality
			 * comparison on the value is valid. This is an alpha feature and may change or be removed in
			 * the future. The field is populated by the apiserver only if the StorageVersionHash feature
			 * gate is enabled. This field will remain optional even if it graduates.
			 */
			storageVersionHash?: string

			/**
			 * version is the preferred version of the resource.  Empty implies the version of the
			 * containing resource list For subresources, this may have a different value, for example: v1
			 * (while inside a v1beta1 version of the core resource's group)".
			 */
			version?: string
		}

		/**
		 * APIResourceList is a list of APIResource, it is used to expose the name of the resources
		 * supported in a specific group and version, and if the resource is namespaced.
		 */
		export interface APIResourceList {
			/**
			 * groupVersion is the group and version this APIResourceList is for.
			 */
			groupVersion: string

			/**
			 * resources contains the name of the resources and if they are namespaced.
			 */
			resources: meta.v1.APIResource[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string
		}

		export function isAPIResourceList(o: any): o is APIResourceList {
			return o.apiVersion == 'v1' && o.kind == 'APIResourceList'
		}

		/**
		 * APIVersions lists the versions that are available, to allow clients to discover the API at
		 * /api, which is the root path of the legacy v1 API.
		 */
		export interface APIVersions {
			/**
			 * a map of client CIDR to server address that is serving this group. This is to help clients
			 * reach servers in the most network-efficient way possible. Clients can use the appropriate
			 * server address as per the CIDR that they match. In case of multiple matches, clients should
			 * use the longest matching CIDR. The server returns only those CIDRs that it thinks that the
			 * client can match. For example: the master will return an internal IP CIDR only, if the
			 * client reaches the server using an internal IP. Server looks at X-Forwarded-For header or
			 * X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
			 */
			serverAddressByClientCIDRs: meta.v1.ServerAddressByClientCIDR[]

			/**
			 * versions are the api versions that are available.
			 */
			versions: string[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string
		}

		export function isAPIVersions(o: any): o is APIVersions {
			return o.apiVersion == 'v1' && o.kind == 'APIVersions'
		}

		/**
		 * DeleteOptions may be provided when deleting an API object.
		 */
		export interface DeleteOptions {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * When present, indicates that modifications should not be persisted. An invalid or
			 * unrecognized dryRun directive will result in an error response and no further processing of
			 * the request. Valid values are: - All: all dry run stages will be processed
			 */
			dryRun?: string[]

			/**
			 * The duration in seconds before the object should be deleted. Value must be non-negative
			 * integer. The value zero indicates delete immediately. If this value is nil, the default
			 * grace period for the specified type will be used. Defaults to a per object value if not
			 * specified. zero means delete immediately.
			 */
			gracePeriodSeconds?: number

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string

			/**
			 * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should
			 * the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added
			 * to/removed from the object's finalizers list. Either this field or PropagationPolicy may be
			 * set, but not both.
			 */
			orphanDependents?: boolean

			/**
			 * Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status
			 * will be returned.
			 */
			preconditions?: meta.v1.Preconditions

			/**
			 * Whether and how garbage collection will be performed. Either this field or OrphanDependents
			 * may be set, but not both. The default policy is decided by the existing finalizer set in
			 * the metadata.finalizers and the resource-specific default policy. Acceptable values are:
			 * 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the
			 * dependents in the background; 'Foreground' - a cascading policy that deletes all dependents
			 * in the foreground.
			 */
			propagationPolicy?: string
		}

		export function isDeleteOptions(o: any): o is DeleteOptions {
			return o.apiVersion == 'v1' && o.kind == 'DeleteOptions'
		}

		/**
		 * GroupVersion contains the "group/version" and "version" string of a version. It is made a
		 * struct to keep extensibility.
		 */
		export interface GroupVersionForDiscovery {
			/**
			 * groupVersion specifies the API group and version in the form "group/version"
			 */
			groupVersion: string

			/**
			 * version specifies the version in the form of "version". This is to save the clients the
			 * trouble of splitting the GroupVersion.
			 */
			version: string
		}

		/**
		 * A label selector is a label query over a set of resources. The result of matchLabels and
		 * matchExpressions are ANDed. An empty label selector matches all objects. A null label
		 * selector matches no objects.
		 */
		export interface LabelSelector {
			/**
			 * matchExpressions is a list of label selector requirements. The requirements are ANDed.
			 */
			matchExpressions?: meta.v1.LabelSelectorRequirement[]

			/**
			 * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is
			 * equivalent to an element of matchExpressions, whose key field is "key", the operator is
			 * "In", and the values array contains only "value". The requirements are ANDed.
			 */
			matchLabels?: { [key: string]: string }
		}

		/**
		 * A label selector requirement is a selector that contains values, a key, and an operator that
		 * relates the key and values.
		 */
		export interface LabelSelectorRequirement {
			/**
			 * key is the label key that the selector applies to.
			 */
			key: string

			/**
			 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn,
			 * Exists and DoesNotExist.
			 */
			operator: string

			/**
			 * values is an array of string values. If the operator is In or NotIn, the values array must
			 * be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty.
			 * This array is replaced during a strategic merge patch.
			 */
			values?: string[]
		}

		/**
		 * ListMeta describes metadata that synthetic resources must have, including lists and various
		 * status objects. A resource may have only one of {ObjectMeta, ListMeta}.
		 */
		export interface ListMeta {
			/**
			 * continue may be set if the user set a limit on the number of items returned, and indicates
			 * that the server has more data available. The value is opaque and may be used to issue
			 * another request to the endpoint that served this list to retrieve the next set of available
			 * objects. Continuing a consistent list may not be possible if the server configuration has
			 * changed or more than a few minutes have passed. The resourceVersion field returned when
			 * using this continue value will be identical to the value in the first response, unless you
			 * have received this token from an error message.
			 */
			continue?: string

			/**
			 * remainingItemCount is the number of subsequent items in the list which are not included in
			 * this list response. If the list request contained label or field selectors, then the number
			 * of remaining items is unknown and the field will be left unset and omitted during
			 * serialization. If the list is complete (either because it is not chunking or because this
			 * is the last chunk), then there are no more remaining items and this field will be left
			 * unset and omitted during serialization. Servers older than v1.15 do not set this field. The
			 * intended use of the remainingItemCount is *estimating* the size of a collection. Clients
			 * should not rely on the remainingItemCount to be set or to be exact.
			 */
			remainingItemCount?: number

			/**
			 * String that identifies the server's internal version of this object that can be used by
			 * clients to determine when objects have changed. Value must be treated as opaque by clients
			 * and passed unmodified back to the server. Populated by the system. Read-only. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
			 */
			resourceVersion?: string

			/**
			 * selfLink is a URL representing this object. Populated by the system. Read-only.
			 *
			 * DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is
			 * planned to be removed in 1.21 release.
			 */
			selfLink?: string
		}

		/**
		 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that
		 * the fieldset applies to.
		 */
		export interface ManagedFieldsEntry {
			/**
			 * APIVersion defines the version of this resource that this field set applies to. The format
			 * is "group/version" just like the top-level APIVersion field. It is necessary to track the
			 * version of a field set because it cannot be automatically converted.
			 */
			apiVersion?: string

			/**
			 * FieldsType is the discriminator for the different fields format and version. There is
			 * currently only one possible value: "FieldsV1"
			 */
			fieldsType?: string

			/**
			 * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
			 */
			fieldsV1?: object

			/**
			 * Manager is an identifier of the workflow managing these fields.
			 */
			manager?: string

			/**
			 * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The
			 * only valid values for this field are 'Apply' and 'Update'.
			 */
			operation?: string

			/**
			 * Time is timestamp of when these fields were set. It should always be empty if Operation is
			 * 'Apply'
			 */
			time?: string
		}

		export function isManagedFieldsEntry(o: any): o is ManagedFieldsEntry {
			return o.apiVersion == 'meta/v1' && o.kind == 'ManagedFieldsEntry'
		}

		/**
		 * ObjectMeta is metadata that all persisted resources must have, which includes all objects
		 * users must create.
		 */
		export interface ObjectMeta {
			/**
			 * Annotations is an unstructured key value map stored with a resource that may be set by
			 * external tools to store and retrieve arbitrary metadata. They are not queryable and should
			 * be preserved when modifying objects. More info:
			 * http://kubernetes.io/docs/user-guide/annotations
			 */
			annotations?: { [key: string]: string }

			/**
			 * The name of the cluster which the object belongs to. This is used to distinguish resources
			 * with same name and namespace in different clusters. This field is not set anywhere right
			 * now and apiserver is going to ignore it if set in create or update request.
			 */
			clusterName?: string

			/**
			 * CreationTimestamp is a timestamp representing the server time when this object was created.
			 * It is not guaranteed to be set in happens-before order across separate operations. Clients
			 * may not set this value. It is represented in RFC3339 form and is in UTC.
			 *
			 * Populated by the system. Read-only. Null for lists. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			creationTimestamp?: string

			/**
			 * Number of seconds allowed for this object to gracefully terminate before it will be removed
			 * from the system. Only set when deletionTimestamp is also set. May only be shortened.
			 * Read-only.
			 */
			deletionGracePeriodSeconds?: number

			/**
			 * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
			 * field is set by the server when a graceful deletion is requested by the user, and is not
			 * directly settable by a client. The resource is expected to be deleted (no longer visible
			 * from resource lists, and not reachable by name) after the time in this field, once the
			 * finalizers list is empty. As long as the finalizers list contains items, deletion is
			 * blocked. Once the deletionTimestamp is set, this value may not be unset or be set further
			 * into the future, although it may be shortened or the resource may be deleted prior to this
			 * time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will
			 * react by sending a graceful termination signal to the containers in the pod. After that 30
			 * seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and
			 * after cleanup, remove the pod from the API. In the presence of network partitions, this
			 * object may still exist after this timestamp, until an administrator or automated process
			 * can determine the resource is fully terminated. If not set, graceful deletion of the object
			 * has not been requested.
			 *
			 * Populated by the system when a graceful deletion is requested. Read-only. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			deletionTimestamp?: string

			/**
			 * Must be empty before the object is deleted from the registry. Each entry is an identifier
			 * for the responsible component that will remove the entry from the list. If the
			 * deletionTimestamp of the object is non-nil, entries in this list can only be removed.
			 * Finalizers may be processed and removed in any order.  Order is NOT enforced because it
			 * introduces significant risk of stuck finalizers. finalizers is a shared field, any actor
			 * with permission can reorder it. If the finalizer list is processed in order, then this can
			 * lead to a situation in which the component responsible for the first finalizer in the list
			 * is waiting for a signal (field value, external system, or other) produced by a component
			 * responsible for a finalizer later in the list, resulting in a deadlock. Without enforced
			 * ordering finalizers are free to order amongst themselves and are not vulnerable to ordering
			 * changes in the list.
			 */
			finalizers?: string[]

			/**
			 * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF
			 * the Name field has not been provided. If this field is used, the name returned to the
			 * client will be different than the name passed. This value will also be combined with a
			 * unique suffix. The provided value has the same validation rules as the Name field, and may
			 * be truncated by the length of the suffix required to make the value unique on the server.
			 *
			 * If this field is specified and the generated name exists, the server will NOT return a 409
			 * - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a
			 * unique name could not be found in the time allotted, and the client should retry
			 * (optionally after the time indicated in the Retry-After header).
			 *
			 * Applied only if Name is not specified. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
			 */
			generateName?: string

			/**
			 * A sequence number representing a specific generation of the desired state. Populated by the
			 * system. Read-only.
			 */
			generation?: number

			/**
			 * Map of string keys and values that can be used to organize and categorize (scope and
			 * select) objects. May match selectors of replication controllers and services. More info:
			 * http://kubernetes.io/docs/user-guide/labels
			 */
			labels?: { [key: string]: string }

			/**
			 * ManagedFields maps workflow-id and version to the set of fields that are managed by that
			 * workflow. This is mostly for internal housekeeping, and users typically shouldn't need to
			 * set or understand this field. A workflow can be the user's name, a controller's name, or
			 * the name of a specific apply path like "ci-cd". The set of fields is always in the version
			 * that the workflow used when modifying the object.
			 */
			managedFields?: meta.v1.ManagedFieldsEntry[]

			/**
			 * Name must be unique within a namespace. Is required when creating resources, although some
			 * resources may allow a client to request the generation of an appropriate name
			 * automatically. Name is primarily intended for creation idempotence and configuration
			 * definition. Cannot be updated. More info:
			 * http://kubernetes.io/docs/user-guide/identifiers#names
			 */
			name?: string

			/**
			 * Namespace defines the space within each name must be unique. An empty namespace is
			 * equivalent to the "default" namespace, but "default" is the canonical representation. Not
			 * all objects are required to be scoped to a namespace - the value of this field for those
			 * objects will be empty.
			 *
			 * Must be a DNS_LABEL. Cannot be updated. More info:
			 * http://kubernetes.io/docs/user-guide/namespaces
			 */
			namespace?: string | core.v1.Namespace

			/**
			 * List of objects depended by this object. If ALL objects in the list have been deleted, this
			 * object will be garbage collected. If this object is managed by a controller, then an entry
			 * in this list will point to this controller, with the controller field set to true. There
			 * cannot be more than one managing controller.
			 */
			ownerReferences?: meta.v1.OwnerReference[]

			/**
			 * An opaque value that represents the internal version of this object that can be used by
			 * clients to determine when objects have changed. May be used for optimistic concurrency,
			 * change detection, and the watch operation on a resource or set of resources. Clients must
			 * treat these values as opaque and passed unmodified back to the server. They may only be
			 * valid for a particular resource or set of resources.
			 *
			 * Populated by the system. Read-only. Value must be treated as opaque by clients and . More
			 * info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
			 */
			resourceVersion?: string

			/**
			 * SelfLink is a URL representing this object. Populated by the system. Read-only.
			 *
			 * DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is
			 * planned to be removed in 1.21 release.
			 */
			selfLink?: string

			/**
			 * UID is the unique in time and space value for this object. It is typically generated by the
			 * server on successful creation of a resource and is not allowed to change on PUT operations.
			 *
			 * Populated by the system. Read-only. More info:
			 * http://kubernetes.io/docs/user-guide/identifiers#uids
			 */
			uid?: string
		}

		/**
		 * OwnerReference contains enough information to let you identify an owning object. An owning
		 * object must be in the same namespace as the dependent, or be cluster-scoped, so there is no
		 * namespace field.
		 */
		export interface OwnerReference {
			/**
			 * API version of the referent.
			 */
			apiVersion: string

			/**
			 * Kind of the referent. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind: string

			/**
			 * Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
			 */
			name: string

			/**
			 * UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
			 */
			uid: string

			/**
			 * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be
			 * deleted from the key-value store until this reference is removed. Defaults to false. To set
			 * this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable
			 * Entity) will be returned.
			 */
			blockOwnerDeletion?: boolean

			/**
			 * If true, this reference points to the managing controller.
			 */
			controller?: boolean
		}

		export function isOwnerReference(o: any): o is OwnerReference {
			return o.apiVersion == 'meta/v1' && o.kind == 'OwnerReference'
		}

		/**
		 * Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
		 */
		export interface Preconditions {
			/**
			 * Specifies the target ResourceVersion
			 */
			resourceVersion?: string

			/**
			 * Specifies the target UID.
			 */
			uid?: string
		}

		/**
		 * ServerAddressByClientCIDR helps the client to determine the server address that they should
		 * use, depending on the clientCIDR that they match.
		 */
		export interface ServerAddressByClientCIDR {
			/**
			 * The CIDR with which clients can match their IP to figure out the server address that they
			 * should use.
			 */
			clientCIDR: string

			/**
			 * Address of this server, suitable for a client that matches the above CIDR. This can be a
			 * hostname, hostname:port, IP or IP:port.
			 */
			serverAddress: string
		}

		/**
		 * Status is a return value for calls that don't return other objects.
		 */
		export interface Status {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'v1'

			/**
			 * Suggested HTTP return code for this status, 0 if not set.
			 */
			code?: number

			/**
			 * Extended data associated with the reason.  Each reason may define its own extended details.
			 * This field is optional and the data returned is not guaranteed to conform to any schema
			 * except that defined by the reason type.
			 */
			details?: meta.v1.StatusDetails

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Status'

			/**
			 * A human-readable description of the status of this operation.
			 */
			message?: string

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			metadata?: meta.v1.ListMeta

			/**
			 * A machine-readable description of why this operation is in the "Failure" status. If this
			 * value is empty there is no information available. A Reason clarifies an HTTP status code
			 * but does not override it.
			 */
			reason?: string
		}

		export function isStatus(o: any): o is Status {
			return o.apiVersion == 'v1' && o.kind == 'Status'
		}

		/**
		 * StatusCause provides more information about an api.Status failure, including cases when
		 * multiple errors are encountered.
		 */
		export interface StatusCause {
			/**
			 * The field of the resource that has caused this error, as named by its JSON serialization.
			 * May include dot and postfix notation for nested attributes. Arrays are zero-indexed.
			 * Fields may appear more than once in an array of causes due to fields having multiple
			 * errors. Optional.
			 *
			 * Examples:
			 *   "name" - the field "name" on the current resource
			 *   "items[0].name" - the field "name" on the first array entry in "items"
			 */
			field?: string

			/**
			 * A human-readable description of the cause of the error.  This field may be presented as-is
			 * to a reader.
			 */
			message?: string

			/**
			 * A machine-readable description of the cause of the error. If this value is empty there is
			 * no information available.
			 */
			reason?: string
		}

		/**
		 * StatusDetails is a set of additional properties that MAY be set by the server to provide
		 * additional information about a response. The Reason field of a Status object defines what
		 * attributes will be set. Clients must ignore fields that do not match the defined type of each
		 * attribute, and should assume that any attribute may be empty, invalid, or under defined.
		 */
		export interface StatusDetails {
			/**
			 * The Causes array includes more details associated with the StatusReason failure. Not all
			 * StatusReasons may provide detailed causes.
			 */
			causes?: meta.v1.StatusCause[]

			/**
			 * The group attribute of the resource associated with the status StatusReason.
			 */
			group?: string

			/**
			 * The kind attribute of the resource associated with the status StatusReason. On some
			 * operations may differ from the requested resource Kind. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string

			/**
			 * The name attribute of the resource associated with the status StatusReason (when there is a
			 * single name which can be described).
			 */
			name?: string

			/**
			 * If specified, the time in seconds before the operation should be retried. Some errors may
			 * indicate the client must take an alternate action - for those errors this field may
			 * indicate how long to wait before taking the alternate action.
			 */
			retryAfterSeconds?: number

			/**
			 * UID of the resource. (when there is a single resource which can be described). More info:
			 * http://kubernetes.io/docs/user-guide/identifiers#uids
			 */
			uid?: string
		}

		/**
		 * Event represents a single event to a watched resource.
		 */
		export interface WatchEvent {
			/**
			 * Object is:
			 *  * If Type is Added or Modified: the new state of the object.
			 *  * If Type is Deleted: the state of the object immediately before deletion.
			 *  * If Type is Error: *Status is recommended; other types may make sense
			 *    depending on context.
			 */
			object: object

			type: string
		}
	}
}

export namespace networking {
	export namespace v1 {
		/**
		 * IPBlock describes a particular CIDR (Ex. "192.168.1.1/24") that is allowed to the pods
		 * matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should
		 * not be included within this rule.
		 */
		export interface IPBlock {
			/**
			 * CIDR is a string representing the IP Block Valid examples are "192.168.1.1/24"
			 */
			cidr: string

			/**
			 * Except is a slice of CIDRs that should not be included within an IP Block Valid examples
			 * are "192.168.1.1/24" Except values will be rejected if they are outside the CIDR range
			 */
			except?: string[]
		}

		/**
		 * NetworkPolicy describes what network traffic is allowed for a set of Pods
		 */
		export interface NetworkPolicy {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'networking.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'NetworkPolicy'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior for this NetworkPolicy.
			 */
			spec?: networking.v1.NetworkPolicySpec
		}

		export function isNetworkPolicy(o: any): o is NetworkPolicy {
			return o.apiVersion == 'networking.k8s.io/v1' && o.kind == 'NetworkPolicy'
		}

		/**
		 * NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
		 * matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to. This
		 * type is beta-level in 1.8
		 */
		export interface NetworkPolicyEgressRule {
			/**
			 * List of destination ports for outgoing traffic. Each item in this list is combined using a
			 * logical OR. If this field is empty or missing, this rule matches all ports (traffic not
			 * restricted by port). If this field is present and contains at least one item, then this
			 * rule allows traffic only if the traffic matches at least one port in the list.
			 */
			ports?: networking.v1.NetworkPolicyPort[]

			/**
			 * List of destinations for outgoing traffic of pods selected for this rule. Items in this
			 * list are combined using a logical OR operation. If this field is empty or missing, this
			 * rule matches all destinations (traffic not restricted by destination). If this field is
			 * present and contains at least one item, this rule allows traffic only if the traffic
			 * matches at least one item in the to list.
			 */
			to?: networking.v1.NetworkPolicyPeer[]
		}

		/**
		 * NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods
		 * matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
		 */
		export interface NetworkPolicyIngressRule {
			/**
			 * List of sources which should be able to access the pods selected for this rule. Items in
			 * this list are combined using a logical OR operation. If this field is empty or missing,
			 * this rule matches all sources (traffic not restricted by source). If this field is present
			 * and contains at least one item, this rule allows traffic only if the traffic matches at
			 * least one item in the from list.
			 */
			from?: networking.v1.NetworkPolicyPeer[]

			/**
			 * List of ports which should be made accessible on the pods selected for this rule. Each item
			 * in this list is combined using a logical OR. If this field is empty or missing, this rule
			 * matches all ports (traffic not restricted by port). If this field is present and contains
			 * at least one item, then this rule allows traffic only if the traffic matches at least one
			 * port in the list.
			 */
			ports?: networking.v1.NetworkPolicyPort[]
		}

		/**
		 * NetworkPolicyList is a list of NetworkPolicy objects.
		 */
		export interface NetworkPolicyList {
			/**
			 * Items is a list of schema objects.
			 */
			items: networking.v1.NetworkPolicy[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'networking.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'NetworkPolicyList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isNetworkPolicyList(o: any): o is NetworkPolicyList {
			return (
				o.apiVersion == 'networking.k8s.io/v1' && o.kind == 'NetworkPolicyList'
			)
		}

		/**
		 * NetworkPolicyPeer describes a peer to allow traffic from. Only certain combinations of fields
		 * are allowed
		 */
		export interface NetworkPolicyPeer {
			/**
			 * IPBlock defines policy on a particular IPBlock. If this field is set then neither of the
			 * other fields can be.
			 */
			ipBlock?: networking.v1.IPBlock

			/**
			 * Selects Namespaces using cluster-scoped labels. This field follows standard label selector
			 * semantics; if present but empty, it selects all namespaces.
			 *
			 * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods matching
			 * PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it selects all Pods
			 * in the Namespaces selected by NamespaceSelector.
			 */
			namespaceSelector?: meta.v1.LabelSelector

			/**
			 * This is a label selector which selects Pods. This field follows standard label selector
			 * semantics; if present but empty, it selects all pods.
			 *
			 * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects the Pods
			 * matching PodSelector in the Namespaces selected by NamespaceSelector. Otherwise it selects
			 * the Pods matching PodSelector in the policy's own Namespace.
			 */
			podSelector?: meta.v1.LabelSelector
		}

		/**
		 * NetworkPolicyPort describes a port to allow traffic on
		 */
		export interface NetworkPolicyPort {
			/**
			 * The port on the given protocol. This can either be a numerical or named port on a pod. If
			 * this field is not provided, this matches all port names and numbers.
			 */
			port?: number | string

			/**
			 * The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field
			 * defaults to TCP.
			 */
			protocol?: string
		}

		/**
		 * NetworkPolicySpec provides the specification of a NetworkPolicy
		 */
		export interface NetworkPolicySpec {
			/**
			 * Selects the pods to which this NetworkPolicy object applies. The array of ingress rules is
			 * applied to any pods selected by this field. Multiple network policies can select the same
			 * set of pods. In this case, the ingress rules for each are combined additively. This field
			 * is NOT optional and follows standard label selector semantics. An empty podSelector matches
			 * all pods in this namespace.
			 */
			podSelector: meta.v1.LabelSelector

			/**
			 * List of egress rules to be applied to the selected pods. Outgoing traffic is allowed if
			 * there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
			 * traffic), OR if the traffic matches at least one egress rule across all of the
			 * NetworkPolicy objects whose podSelector matches the pod. If this field is empty then this
			 * NetworkPolicy limits all outgoing traffic (and serves solely to ensure that the pods it
			 * selects are isolated by default). This field is beta-level in 1.8
			 */
			egress?: networking.v1.NetworkPolicyEgressRule[]

			/**
			 * List of ingress rules to be applied to the selected pods. Traffic is allowed to a pod if
			 * there are no NetworkPolicies selecting the pod (and cluster policy otherwise allows the
			 * traffic), OR if the traffic source is the pod's local node, OR if the traffic matches at
			 * least one ingress rule across all of the NetworkPolicy objects whose podSelector matches
			 * the pod. If this field is empty then this NetworkPolicy does not allow any traffic (and
			 * serves solely to ensure that the pods it selects are isolated by default)
			 */
			ingress?: networking.v1.NetworkPolicyIngressRule[]

			/**
			 * List of rule types that the NetworkPolicy relates to. Valid options are "Ingress",
			 * "Egress", or "Ingress,Egress". If this field is not specified, it will default based on the
			 * existence of Ingress or Egress rules; policies that contain an Egress section are assumed
			 * to affect Egress, and all policies (whether or not they contain an Ingress section) are
			 * assumed to affect Ingress. If you want to write an egress-only policy, you must explicitly
			 * specify policyTypes [ "Egress" ]. Likewise, if you want to write a policy that specifies
			 * that no egress is allowed, you must specify a policyTypes value that include "Egress"
			 * (since such a policy would not include an Egress section and would otherwise default to
			 * just [ "Ingress" ]). This field is beta-level in 1.8
			 */
			policyTypes?: string[]
		}
	}
	export namespace v1beta1 {
		/**
		 * HTTPIngressPath associates a path regex with a backend. Incoming urls matching the path are
		 * forwarded to the backend.
		 */
		export interface HTTPIngressPath {
			/**
			 * Backend defines the referenced service endpoint to which the traffic will be forwarded to.
			 */
			backend: networking.v1beta1.IngressBackend

			/**
			 * Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the
			 * egrep/unix syntax, not the perl syntax) matched against the path of an incoming request.
			 * Currently it can contain characters disallowed from the conventional "path" part of a URL
			 * as defined by RFC 3986. Paths must begin with a '/'. If unspecified, the path defaults to a
			 * catch all sending traffic to the backend.
			 */
			path?: string
		}

		/**
		 * HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example:
		 * http://<host>/<path>?<searchpart> -> backend where where parts of the url correspond to RFC
		 * 3986, this resource will be used to match against everything after the last '/' and before
		 * the first '?' or '#'.
		 */
		export interface HTTPIngressRuleValue {
			/**
			 * A collection of paths that map requests to backends.
			 */
			paths: networking.v1beta1.HTTPIngressPath[]
		}

		/**
		 * Ingress is a collection of rules that allow inbound connections to reach the endpoints
		 * defined by a backend. An Ingress can be configured to give services externally-reachable
		 * urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.
		 */
		export interface Ingress {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'networking.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Ingress'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Spec is the desired state of the Ingress. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec?: networking.v1beta1.IngressSpec
		}

		export function isIngress(o: any): o is Ingress {
			return o.apiVersion == 'networking.k8s.io/v1beta1' && o.kind == 'Ingress'
		}

		/**
		 * IngressBackend describes all endpoints for a given service and port.
		 */
		export interface IngressBackend {
			/**
			 * Specifies the name of the referenced service.
			 */
			serviceName: string

			/**
			 * Specifies the port of the referenced service.
			 */
			servicePort: number | string
		}

		/**
		 * IngressList is a collection of Ingress.
		 */
		export interface IngressList {
			/**
			 * Items is the list of Ingress.
			 */
			items: networking.v1beta1.Ingress[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'networking.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'IngressList'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isIngressList(o: any): o is IngressList {
			return (
				o.apiVersion == 'networking.k8s.io/v1beta1' && o.kind == 'IngressList'
			)
		}

		/**
		 * IngressRule represents the rules mapping the paths under a specified host to the related
		 * backend services. Incoming requests are first evaluated for a host match, then routed to the
		 * backend associated with the matching IngressRuleValue.
		 */
		export interface IngressRule {
			/**
			 * Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the
			 * following deviations from the "host" part of the URI as defined in the RFC: 1. IPs are not
			 * allowed. Currently an IngressRuleValue can only apply to the
			 * 	  IP in the Spec of the parent Ingress.
			 * 2. The `:` delimiter is not respected because ports are not allowed.
			 * 	  Currently the port of an Ingress is implicitly :80 for http and
			 * 	  :443 for https.
			 * Both these may change in the future. Incoming requests are matched against the host before
			 * the IngressRuleValue. If the host is unspecified, the Ingress routes all traffic based on
			 * the specified IngressRuleValue.
			 */
			host?: string

			http?: networking.v1beta1.HTTPIngressRuleValue
		}

		/**
		 * IngressSpec describes the Ingress the user wishes to exist.
		 */
		export interface IngressSpec {
			/**
			 * A default backend capable of servicing requests that don't match any rule. At least one of
			 * 'backend' or 'rules' must be specified. This field is optional to allow the loadbalancer
			 * controller or defaulting logic to specify a global default.
			 */
			backend?: networking.v1beta1.IngressBackend

			/**
			 * A list of host rules used to configure the Ingress. If unspecified, or no rule matches, all
			 * traffic is sent to the default backend.
			 */
			rules?: networking.v1beta1.IngressRule[]

			/**
			 * TLS configuration. Currently the Ingress only supports a single TLS port, 443. If multiple
			 * members of this list specify different hosts, they will be multiplexed on the same port
			 * according to the hostname specified through the SNI TLS extension, if the ingress
			 * controller fulfilling the ingress supports SNI.
			 */
			tls?: networking.v1beta1.IngressTLS[]
		}

		/**
		 * IngressTLS describes the transport layer security associated with an Ingress.
		 */
		export interface IngressTLS {
			/**
			 * Hosts are a list of hosts included in the TLS certificate. The values in this list must
			 * match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the
			 * loadbalancer controller fulfilling this Ingress, if left unspecified.
			 */
			hosts?: string[]

			/**
			 * SecretName is the name of the secret used to terminate SSL traffic on 443. Field is left
			 * optional to allow SSL routing based on SNI hostname alone. If the SNI host in a listener
			 * conflicts with the "Host" header field used by an IngressRule, the SNI host is used for
			 * termination and value of the Host header is used for routing.
			 */
			secretName?: string
		}
	}
}

export namespace node {
	export namespace v1alpha1 {
		/**
		 * Overhead structure represents the resource overhead associated with running a pod.
		 */
		export interface Overhead {
			/**
			 * PodFixed represents the fixed resource overhead associated with running a pod.
			 */
			podFixed?: object
		}

		/**
		 * RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass
		 * is used to determine which container runtime is used to run all containers in a pod.
		 * RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and
		 * referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName
		 * reference before running the pod.  For more details, see
		 * https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
		 */
		export interface RuntimeClass {
			/**
			 * Specification of the RuntimeClass More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
			 */
			spec: node.v1alpha1.RuntimeClassSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'node.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RuntimeClass'

			/**
			 * More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isRuntimeClass(o: any): o is RuntimeClass {
			return o.apiVersion == 'node.k8s.io/v1alpha1' && o.kind == 'RuntimeClass'
		}

		/**
		 * RuntimeClassList is a list of RuntimeClass objects.
		 */
		export interface RuntimeClassList {
			/**
			 * Items is a list of schema objects.
			 */
			items: node.v1alpha1.RuntimeClass[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'node.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RuntimeClassList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isRuntimeClassList(o: any): o is RuntimeClassList {
			return (
				o.apiVersion == 'node.k8s.io/v1alpha1' && o.kind == 'RuntimeClassList'
			)
		}

		/**
		 * RuntimeClassSpec is a specification of a RuntimeClass. It contains parameters that are
		 * required to describe the RuntimeClass to the Container Runtime Interface (CRI)
		 * implementation, as well as any other components that need to understand how the pod will be
		 * run. The RuntimeClassSpec is immutable.
		 */
		export interface RuntimeClassSpec {
			/**
			 * RuntimeHandler specifies the underlying runtime and configuration that the CRI
			 * implementation will use to handle pods of this class. The possible values are specific to
			 * the node & CRI configuration.  It is assumed that all handlers are available on every node,
			 * and handlers of the same name are equivalent on every node. For example, a handler called
			 * "runc" might specify that the runc OCI runtime (using native Linux containers) will be used
			 * to run the containers in a pod. The RuntimeHandler must conform to the DNS Label (RFC 1123)
			 * requirements and is immutable.
			 */
			runtimeHandler: string

			/**
			 * Overhead represents the resource overhead associated with running a pod for a given
			 * RuntimeClass. For more details, see
			 * https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
			 * alpha-level as of Kubernetes v1.15, and is only honored by servers that enable the
			 * PodOverhead feature.
			 */
			overhead?: node.v1alpha1.Overhead

			/**
			 * Scheduling holds the scheduling constraints to ensure that pods running with this
			 * RuntimeClass are scheduled to nodes that support it. If scheduling is nil, this
			 * RuntimeClass is assumed to be supported by all nodes.
			 */
			scheduling?: node.v1alpha1.Scheduling
		}

		/**
		 * Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass.
		 */
		export interface Scheduling {
			/**
			 * nodeSelector lists labels that must be present on nodes that support this RuntimeClass.
			 * Pods using this RuntimeClass can only be scheduled to a node matched by this selector. The
			 * RuntimeClass nodeSelector is merged with a pod's existing nodeSelector. Any conflicts will
			 * cause the pod to be rejected in admission.
			 */
			nodeSelector?: { [key: string]: string }

			/**
			 * tolerations are appended (excluding duplicates) to pods running with this RuntimeClass
			 * during admission, effectively unioning the set of nodes tolerated by the pod and the
			 * RuntimeClass.
			 */
			tolerations?: core.v1.Toleration[]
		}
	}
	export namespace v1beta1 {
		/**
		 * Overhead structure represents the resource overhead associated with running a pod.
		 */
		export interface Overhead {
			/**
			 * PodFixed represents the fixed resource overhead associated with running a pod.
			 */
			podFixed?: object
		}

		/**
		 * RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass
		 * is used to determine which container runtime is used to run all containers in a pod.
		 * RuntimeClasses are (currently) manually defined by a user or cluster provisioner, and
		 * referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName
		 * reference before running the pod.  For more details, see
		 * https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
		 */
		export interface RuntimeClass {
			/**
			 * Handler specifies the underlying runtime and configuration that the CRI implementation will
			 * use to handle pods of this class. The possible values are specific to the node & CRI
			 * configuration.  It is assumed that all handlers are available on every node, and handlers
			 * of the same name are equivalent on every node. For example, a handler called "runc" might
			 * specify that the runc OCI runtime (using native Linux containers) will be used to run the
			 * containers in a pod. The Handler must conform to the DNS Label (RFC 1123) requirements, and
			 * is immutable.
			 */
			handler: string

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'node.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RuntimeClass'

			/**
			 * More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Overhead represents the resource overhead associated with running a pod for a given
			 * RuntimeClass. For more details, see
			 * https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md This field is
			 * alpha-level as of Kubernetes v1.15, and is only honored by servers that enable the
			 * PodOverhead feature.
			 */
			overhead?: node.v1beta1.Overhead

			/**
			 * Scheduling holds the scheduling constraints to ensure that pods running with this
			 * RuntimeClass are scheduled to nodes that support it. If scheduling is nil, this
			 * RuntimeClass is assumed to be supported by all nodes.
			 */
			scheduling?: node.v1beta1.Scheduling
		}

		export function isRuntimeClass(o: any): o is RuntimeClass {
			return o.apiVersion == 'node.k8s.io/v1beta1' && o.kind == 'RuntimeClass'
		}

		/**
		 * RuntimeClassList is a list of RuntimeClass objects.
		 */
		export interface RuntimeClassList {
			/**
			 * Items is a list of schema objects.
			 */
			items: node.v1beta1.RuntimeClass[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'node.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RuntimeClassList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isRuntimeClassList(o: any): o is RuntimeClassList {
			return (
				o.apiVersion == 'node.k8s.io/v1beta1' && o.kind == 'RuntimeClassList'
			)
		}

		/**
		 * Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass.
		 */
		export interface Scheduling {
			/**
			 * nodeSelector lists labels that must be present on nodes that support this RuntimeClass.
			 * Pods using this RuntimeClass can only be scheduled to a node matched by this selector. The
			 * RuntimeClass nodeSelector is merged with a pod's existing nodeSelector. Any conflicts will
			 * cause the pod to be rejected in admission.
			 */
			nodeSelector?: { [key: string]: string }

			/**
			 * tolerations are appended (excluding duplicates) to pods running with this RuntimeClass
			 * during admission, effectively unioning the set of nodes tolerated by the pod and the
			 * RuntimeClass.
			 */
			tolerations?: core.v1.Toleration[]
		}
	}
}

export namespace pkg {
	export namespace version {
		/**
		 * Info contains versioning information. how we'll want to distribute that information.
		 */
		export interface Info {
			buildDate: string

			compiler: string

			gitCommit: string

			gitTreeState: string

			gitVersion: string

			goVersion: string

			major: string

			minor: string

			platform: string
		}
	}
}

export namespace policy {
	export namespace v1beta1 {
		/**
		 * AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
		 */
		export interface AllowedCSIDriver {
			/**
			 * Name is the registered name of the CSI driver
			 */
			name: string
		}

		/**
		 * AllowedFlexVolume represents a single Flexvolume that is allowed to be used.
		 */
		export interface AllowedFlexVolume {
			/**
			 * driver is the name of the Flexvolume driver.
			 */
			driver: string
		}

		/**
		 * AllowedHostPath defines the host volume conditions that will be enabled by a policy for pods
		 * to use. It requires the path prefix to be defined.
		 */
		export interface AllowedHostPath {
			/**
			 * pathPrefix is the path prefix that the host volume must match. It does not support `*`.
			 * Trailing slashes are trimmed when validating the path prefix with a host path.
			 *
			 * Examples: `/foo` would allow `/foo`, `/foo/` and `/foo/bar` `/foo` would not allow `/food`
			 * or `/etc/foo`
			 */
			pathPrefix?: string

			/**
			 * when set to true, will allow host volumes matching the pathPrefix only if all volume mounts
			 * are readOnly.
			 */
			readOnly?: boolean
		}

		/**
		 * Eviction evicts a pod from its node subject to certain policies and safety constraints. This
		 * is a subresource of Pod.  A request to cause such an eviction is created by POSTing to
		 * .../pods/<pod name>/evictions.
		 */
		export interface Eviction {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: string

			/**
			 * DeleteOptions may be provided
			 */
			deleteOptions?: meta.v1.DeleteOptions

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: string

			/**
			 * ObjectMeta describes the pod that is being evicted.
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isEviction(o: any): o is Eviction {
			return o.apiVersion == 'policy/v1beta1' && o.kind == 'Eviction'
		}

		/**
		 * FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
		 */
		export interface FSGroupStrategyOptions {
			/**
			 * ranges are the allowed ranges of fs groups.  If you would like to force a single fs group
			 * then supply a single range with the same start and end. Required for MustRunAs.
			 */
			ranges?: policy.v1beta1.IDRange[]

			/**
			 * rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
			 */
			rule?: string
		}

		/**
		 * HostPortRange defines a range of host ports that will be enabled by a policy for pods to use.
		 * It requires both the start and end to be defined.
		 */
		export interface HostPortRange {
			/**
			 * max is the end of the range, inclusive.
			 */
			max: number

			/**
			 * min is the start of the range, inclusive.
			 */
			min: number
		}

		/**
		 * IDRange provides a min/max of an allowed range of IDs.
		 */
		export interface IDRange {
			/**
			 * max is the end of the range, inclusive.
			 */
			max: number

			/**
			 * min is the start of the range, inclusive.
			 */
			min: number
		}

		/**
		 * PodDisruptionBudget is an object to define the max disruption that can be caused to a
		 * collection of pods
		 */
		export interface PodDisruptionBudget {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'policy/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PodDisruptionBudget'

			metadata?: meta.v1.ObjectMeta

			/**
			 * Specification of the desired behavior of the PodDisruptionBudget.
			 */
			spec?: policy.v1beta1.PodDisruptionBudgetSpec
		}

		export function isPodDisruptionBudget(o: any): o is PodDisruptionBudget {
			return o.apiVersion == 'policy/v1beta1' && o.kind == 'PodDisruptionBudget'
		}

		/**
		 * PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
		 */
		export interface PodDisruptionBudgetList {
			items: policy.v1beta1.PodDisruptionBudget[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'policy/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PodDisruptionBudgetList'

			metadata?: meta.v1.ListMeta
		}

		export function isPodDisruptionBudgetList(
			o: any
		): o is PodDisruptionBudgetList {
			return (
				o.apiVersion == 'policy/v1beta1' && o.kind == 'PodDisruptionBudgetList'
			)
		}

		/**
		 * PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
		 */
		export interface PodDisruptionBudgetSpec {
			/**
			 * An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are
			 * unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one
			 * can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting
			 * with "minAvailable".
			 */
			maxUnavailable?: number | string

			/**
			 * An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be
			 * available after the eviction, i.e. even in the absence of the evicted pod.  So for example
			 * you can prevent all voluntary evictions by specifying "100%".
			 */
			minAvailable?: number | string

			/**
			 * Label query over pods whose evictions are managed by the disruption budget.
			 */
			selector?: meta.v1.LabelSelector
		}

		/**
		 * PodSecurityPolicy governs the ability to make requests that affect the Security Context that
		 * will be applied to a pod and container.
		 */
		export interface PodSecurityPolicy {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'policy/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PodSecurityPolicy'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * spec defines the policy enforced.
			 */
			spec?: policy.v1beta1.PodSecurityPolicySpec
		}

		export function isPodSecurityPolicy(o: any): o is PodSecurityPolicy {
			return o.apiVersion == 'policy/v1beta1' && o.kind == 'PodSecurityPolicy'
		}

		/**
		 * PodSecurityPolicyList is a list of PodSecurityPolicy objects.
		 */
		export interface PodSecurityPolicyList {
			/**
			 * items is a list of schema objects.
			 */
			items: policy.v1beta1.PodSecurityPolicy[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'policy/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PodSecurityPolicyList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isPodSecurityPolicyList(
			o: any
		): o is PodSecurityPolicyList {
			return (
				o.apiVersion == 'policy/v1beta1' && o.kind == 'PodSecurityPolicyList'
			)
		}

		/**
		 * PodSecurityPolicySpec defines the policy enforced.
		 */
		export interface PodSecurityPolicySpec {
			/**
			 * fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
			 */
			fsGroup: policy.v1beta1.FSGroupStrategyOptions

			/**
			 * runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
			 */
			runAsUser: policy.v1beta1.RunAsUserStrategyOptions

			/**
			 * seLinux is the strategy that will dictate the allowable labels that may be set.
			 */
			seLinux: policy.v1beta1.SELinuxStrategyOptions

			/**
			 * supplementalGroups is the strategy that will dictate what supplemental groups are used by
			 * the SecurityContext.
			 */
			supplementalGroups: policy.v1beta1.SupplementalGroupsStrategyOptions

			/**
			 * allowPrivilegeEscalation determines if a pod can request to allow privilege escalation. If
			 * unspecified, defaults to true.
			 */
			allowPrivilegeEscalation?: boolean

			/**
			 * AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be
			 * embedded within a pod spec. An empty value indicates that any CSI driver can be used for
			 * inline ephemeral volumes. This is an alpha field, and is only honored if the API server
			 * enables the CSIInlineVolume feature gate.
			 */
			allowedCSIDrivers?: policy.v1beta1.AllowedCSIDriver[]

			/**
			 * allowedCapabilities is a list of capabilities that can be requested to add to the
			 * container. Capabilities in this field may be added at the pod author's discretion. You must
			 * not list a capability in both allowedCapabilities and requiredDropCapabilities.
			 */
			allowedCapabilities?: string[]

			/**
			 * allowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that all
			 * Flexvolumes may be used.  This parameter is effective only when the usage of the
			 * Flexvolumes is allowed in the "volumes" field.
			 */
			allowedFlexVolumes?: policy.v1beta1.AllowedFlexVolume[]

			/**
			 * allowedHostPaths is a white list of allowed host paths. Empty indicates that all host paths
			 * may be used.
			 */
			allowedHostPaths?: policy.v1beta1.AllowedHostPath[]

			/**
			 * AllowedProcMountTypes is a whitelist of allowed ProcMountTypes. Empty or nil indicates that
			 * only the DefaultProcMountType may be used. This requires the ProcMountType feature flag to
			 * be enabled.
			 */
			allowedProcMountTypes?: string[]

			/**
			 * allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none. Each
			 * entry is either a plain sysctl name or ends in "*" in which case it is considered as a
			 * prefix of allowed sysctls. Single * means all unsafe sysctls are allowed. Kubelet has to
			 * whitelist all allowed unsafe sysctls explicitly to avoid rejection.
			 *
			 * Examples: e.g. "foo/*" allows "foo/bar", "foo/baz", etc. e.g. "foo.*" allows "foo.bar",
			 * "foo.baz", etc.
			 */
			allowedUnsafeSysctls?: string[]

			/**
			 * defaultAddCapabilities is the default set of capabilities that will be added to the
			 * container unless the pod spec specifically drops the capability.  You may not list a
			 * capability in both defaultAddCapabilities and requiredDropCapabilities. Capabilities added
			 * here are implicitly allowed, and need not be included in the allowedCapabilities list.
			 */
			defaultAddCapabilities?: string[]

			/**
			 * defaultAllowPrivilegeEscalation controls the default setting for whether a process can gain
			 * more privileges than its parent process.
			 */
			defaultAllowPrivilegeEscalation?: boolean

			/**
			 * forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry is
			 * either a plain sysctl name or ends in "*" in which case it is considered as a prefix of
			 * forbidden sysctls. Single * means all sysctls are forbidden.
			 *
			 * Examples: e.g. "foo/*" forbids "foo/bar", "foo/baz", etc. e.g. "foo.*" forbids "foo.bar",
			 * "foo.baz", etc.
			 */
			forbiddenSysctls?: string[]

			/**
			 * hostIPC determines if the policy allows the use of HostIPC in the pod spec.
			 */
			hostIPC?: boolean

			/**
			 * hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
			 */
			hostNetwork?: boolean

			/**
			 * hostPID determines if the policy allows the use of HostPID in the pod spec.
			 */
			hostPID?: boolean

			/**
			 * hostPorts determines which host port ranges are allowed to be exposed.
			 */
			hostPorts?: policy.v1beta1.HostPortRange[]

			/**
			 * privileged determines if a pod can request to be run as privileged.
			 */
			privileged?: boolean

			/**
			 * readOnlyRootFilesystem when set to true will force containers to run with a read only root
			 * file system.  If the container specifically requests to run with a non-read only root file
			 * system the PSP should deny the pod. If set to false the container may run with a read only
			 * root file system if it wishes but it will not be forced to.
			 */
			readOnlyRootFilesystem?: boolean

			/**
			 * requiredDropCapabilities are the capabilities that will be dropped from the container.
			 * These are required to be dropped and cannot be added.
			 */
			requiredDropCapabilities?: string[]

			/**
			 * RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be
			 * set. If this field is omitted, the pod's RunAsGroup can take any value. This field requires
			 * the RunAsGroup feature gate to be enabled.
			 */
			runAsGroup?: policy.v1beta1.RunAsGroupStrategyOptions

			/**
			 * runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod. If
			 * this field is omitted, the pod's runtimeClassName field is unrestricted. Enforcement of
			 * this field depends on the RuntimeClass feature gate being enabled.
			 */
			runtimeClass?: policy.v1beta1.RuntimeClassStrategyOptions

			/**
			 * volumes is a white list of allowed volume plugins. Empty indicates that no volumes may be
			 * used. To allow all volumes you may use '*'.
			 */
			volumes?: string[]
		}

		/**
		 * RunAsGroupStrategyOptions defines the strategy type and any options used to create the
		 * strategy.
		 */
		export interface RunAsGroupStrategyOptions {
			/**
			 * rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
			 */
			rule: string

			/**
			 * ranges are the allowed ranges of gids that may be used. If you would like to force a single
			 * gid then supply a single range with the same start and end. Required for MustRunAs.
			 */
			ranges?: policy.v1beta1.IDRange[]
		}

		/**
		 * RunAsUserStrategyOptions defines the strategy type and any options used to create the
		 * strategy.
		 */
		export interface RunAsUserStrategyOptions {
			/**
			 * rule is the strategy that will dictate the allowable RunAsUser values that may be set.
			 */
			rule: string

			/**
			 * ranges are the allowed ranges of uids that may be used. If you would like to force a single
			 * uid then supply a single range with the same start and end. Required for MustRunAs.
			 */
			ranges?: policy.v1beta1.IDRange[]
		}

		/**
		 * RuntimeClassStrategyOptions define the strategy that will dictate the allowable
		 * RuntimeClasses for a pod.
		 */
		export interface RuntimeClassStrategyOptions {
			/**
			 * allowedRuntimeClassNames is a whitelist of RuntimeClass names that may be specified on a
			 * pod. A value of "*" means that any RuntimeClass name is allowed, and must be the only item
			 * in the list. An empty list requires the RuntimeClassName field to be unset.
			 */
			allowedRuntimeClassNames: string[]

			/**
			 * defaultRuntimeClassName is the default RuntimeClassName to set on the pod. The default MUST
			 * be allowed by the allowedRuntimeClassNames list. A value of nil does not mutate the Pod.
			 */
			defaultRuntimeClassName?: string
		}

		/**
		 * SELinuxStrategyOptions defines the strategy type and any options used to create the strategy.
		 */
		export interface SELinuxStrategyOptions {
			/**
			 * rule is the strategy that will dictate the allowable labels that may be set.
			 */
			rule: string

			/**
			 * seLinuxOptions required to run as; required for MustRunAs More info:
			 * https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
			 */
			seLinuxOptions?: core.v1.SELinuxOptions
		}

		/**
		 * SupplementalGroupsStrategyOptions defines the strategy type and options used to create the
		 * strategy.
		 */
		export interface SupplementalGroupsStrategyOptions {
			/**
			 * ranges are the allowed ranges of supplemental groups.  If you would like to force a single
			 * supplemental group then supply a single range with the same start and end. Required for
			 * MustRunAs.
			 */
			ranges?: policy.v1beta1.IDRange[]

			/**
			 * rule is the strategy that will dictate what supplemental groups is used in the
			 * SecurityContext.
			 */
			rule?: string
		}
	}
}

export namespace rbac {
	export namespace v1 {
		/**
		 * AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
		 */
		export interface AggregationRule {
			/**
			 * ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and
			 * create the rules. If any of the selectors match, then the ClusterRole's permissions will be
			 * added
			 */
			clusterRoleSelectors?: meta.v1.LabelSelector[]
		}

		/**
		 * ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
		 * unit by a RoleBinding or ClusterRoleBinding.
		 */
		export interface ClusterRole {
			/**
			 * AggregationRule is an optional field that describes how to build the Rules for this
			 * ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
			 * changes to Rules will be stomped by the controller.
			 */
			aggregationRule?: rbac.v1.AggregationRule

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRole'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Rules holds all the PolicyRules for this ClusterRole
			 */
			rules?: rbac.v1.PolicyRule[]
		}

		export function isClusterRole(o: any): o is ClusterRole {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1' &&
				o.kind == 'ClusterRole'
			)
		}

		/**
		 * ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
		 * ClusterRole in the global namespace, and adds who information via Subject.
		 */
		export interface ClusterRoleBinding {
			/**
			 * RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot be
			 * resolved, the Authorizer must return an error.
			 */
			roleRef: rbac.v1.RoleRef

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRoleBinding'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Subjects holds references to the objects the role applies to.
			 */
			subjects?: rbac.v1.Subject[]
		}

		export function isClusterRoleBinding(o: any): o is ClusterRoleBinding {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1' &&
				o.kind == 'ClusterRoleBinding'
			)
		}

		/**
		 * ClusterRoleBindingList is a collection of ClusterRoleBindings
		 */
		export interface ClusterRoleBindingList {
			/**
			 * Items is a list of ClusterRoleBindings
			 */
			items: rbac.v1.ClusterRoleBinding[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRoleBindingList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isClusterRoleBindingList(
			o: any
		): o is ClusterRoleBindingList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1' &&
				o.kind == 'ClusterRoleBindingList'
			)
		}

		/**
		 * ClusterRoleList is a collection of ClusterRoles
		 */
		export interface ClusterRoleList {
			/**
			 * Items is a list of ClusterRoles
			 */
			items: rbac.v1.ClusterRole[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRoleList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isClusterRoleList(o: any): o is ClusterRoleList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1' &&
				o.kind == 'ClusterRoleList'
			)
		}

		/**
		 * PolicyRule holds information that describes a policy rule, but does not contain information
		 * about who the rule applies to or which namespace the rule applies to.
		 */
		export interface PolicyRule {
			/**
			 * Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
			 * contained in this rule.  VerbAll represents all kinds.
			 */
			verbs: string[]

			/**
			 * APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups
			 * are specified, any action requested against one of the enumerated resources in any API
			 * group will be allowed.
			 */
			apiGroups?: string[]

			/**
			 * NonResourceURLs is a set of partial urls that a user should have access to.  *s are
			 * allowed, but only as the full, final step in the path Since non-resource URLs are not
			 * namespaced, this field is only applicable for ClusterRoles referenced from a
			 * ClusterRoleBinding. Rules can either apply to API resources (such as "pods" or "secrets")
			 * or non-resource URL paths (such as "/api"),  but not both.
			 */
			nonResourceURLs?: string[]

			/**
			 * ResourceNames is an optional white list of names that the rule applies to.  An empty set
			 * means that everything is allowed.
			 */
			resourceNames?: string[]

			/**
			 * Resources is a list of resources this rule applies to.  ResourceAll represents all
			 * resources.
			 */
			resources?: string[]
		}

		/**
		 * Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
		 * RoleBinding.
		 */
		export interface Role {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Role'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Rules holds all the PolicyRules for this Role
			 */
			rules?: rbac.v1.PolicyRule[]
		}

		export function isRole(o: any): o is Role {
			return o.apiVersion == 'rbac.authorization.k8s.io/v1' && o.kind == 'Role'
		}

		/**
		 * RoleBinding references a role, but does not contain it.  It can reference a Role in the same
		 * namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
		 * namespace information by which namespace it exists in.  RoleBindings in a given namespace
		 * only have effect in that namespace.
		 */
		export interface RoleBinding {
			/**
			 * RoleRef can reference a Role in the current namespace or a ClusterRole in the global
			 * namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
			 */
			roleRef: rbac.v1.RoleRef

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RoleBinding'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Subjects holds references to the objects the role applies to.
			 */
			subjects?: rbac.v1.Subject[]
		}

		export function isRoleBinding(o: any): o is RoleBinding {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1' &&
				o.kind == 'RoleBinding'
			)
		}

		/**
		 * RoleBindingList is a collection of RoleBindings
		 */
		export interface RoleBindingList {
			/**
			 * Items is a list of RoleBindings
			 */
			items: rbac.v1.RoleBinding[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RoleBindingList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isRoleBindingList(o: any): o is RoleBindingList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1' &&
				o.kind == 'RoleBindingList'
			)
		}

		/**
		 * RoleList is a collection of Roles
		 */
		export interface RoleList {
			/**
			 * Items is a list of Roles
			 */
			items: rbac.v1.Role[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RoleList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isRoleList(o: any): o is RoleList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1' && o.kind == 'RoleList'
			)
		}

		/**
		 * RoleRef contains information that points to the role being used
		 */
		export interface RoleRef {
			/**
			 * APIGroup is the group for the resource being referenced
			 */
			apiGroup: string

			/**
			 * Kind is the type of resource being referenced
			 */
			kind: string

			/**
			 * Name is the name of resource being referenced
			 */
			name: string
		}

		/**
		 * Subject contains a reference to the object or user identities a role binding applies to.
		 * This can either hold a direct API object reference, or a value for non-objects such as user
		 * and group names.
		 */
		export interface Subject {
			/**
			 * Kind of object being referenced. Values defined by this API group are "User", "Group", and
			 * "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer
			 * should report an error.
			 */
			kind: string

			/**
			 * Name of the object being referenced.
			 */
			name: string

			/**
			 * APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount
			 * subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
			 */
			apiGroup?: string

			/**
			 * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or
			 * "Group", and this value is not empty the Authorizer should report an error.
			 */
			namespace?: string
		}
	}
	export namespace v1alpha1 {
		/**
		 * AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
		 */
		export interface AggregationRule {
			/**
			 * ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and
			 * create the rules. If any of the selectors match, then the ClusterRole's permissions will be
			 * added
			 */
			clusterRoleSelectors?: meta.v1.LabelSelector[]
		}

		/**
		 * ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
		 * unit by a RoleBinding or ClusterRoleBinding.
		 *
		 * @deprecated rbac/v1alpha1/ClusterRole is deprecated by rbac/v1/ClusterRole and not supported
		 * by Kubernetes v1.20+ clusters.
		 */
		export interface ClusterRole {
			/**
			 * AggregationRule is an optional field that describes how to build the Rules for this
			 * ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
			 * changes to Rules will be stomped by the controller.
			 */
			aggregationRule?: rbac.v1alpha1.AggregationRule

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRole'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Rules holds all the PolicyRules for this ClusterRole
			 */
			rules?: rbac.v1alpha1.PolicyRule[]
		}

		export function isClusterRole(o: any): o is ClusterRole {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1alpha1' &&
				o.kind == 'ClusterRole'
			)
		}

		/**
		 * ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
		 * ClusterRole in the global namespace, and adds who information via Subject.
		 *
		 * @deprecated rbac/v1alpha1/ClusterRoleBinding is deprecated by rbac/v1/ClusterRoleBinding and
		 * not supported by Kubernetes v1.20+ clusters.
		 */
		export interface ClusterRoleBinding {
			/**
			 * RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot be
			 * resolved, the Authorizer must return an error.
			 */
			roleRef: rbac.v1alpha1.RoleRef

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRoleBinding'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Subjects holds references to the objects the role applies to.
			 */
			subjects?: rbac.v1alpha1.Subject[]
		}

		export function isClusterRoleBinding(o: any): o is ClusterRoleBinding {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1alpha1' &&
				o.kind == 'ClusterRoleBinding'
			)
		}

		/**
		 * ClusterRoleBindingList is a collection of ClusterRoleBindings.
		 *
		 * @deprecated rbac/v1alpha1/ClusterRoleBindingList is deprecated by
		 * rbac/v1/ClusterRoleBindingList and not supported by Kubernetes v1.20+ clusters.
		 */
		export interface ClusterRoleBindingList {
			/**
			 * Items is a list of ClusterRoleBindings
			 */
			items: rbac.v1alpha1.ClusterRoleBinding[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRoleBindingList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isClusterRoleBindingList(
			o: any
		): o is ClusterRoleBindingList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1alpha1' &&
				o.kind == 'ClusterRoleBindingList'
			)
		}

		/**
		 * ClusterRoleList is a collection of ClusterRoles.
		 *
		 * @deprecated rbac/v1alpha1/ClusterRoleList is deprecated by rbac/v1/ClusterRoleList and not
		 * supported by Kubernetes v1.20+ clusters.
		 */
		export interface ClusterRoleList {
			/**
			 * Items is a list of ClusterRoles
			 */
			items: rbac.v1alpha1.ClusterRole[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRoleList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isClusterRoleList(o: any): o is ClusterRoleList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1alpha1' &&
				o.kind == 'ClusterRoleList'
			)
		}

		/**
		 * PolicyRule holds information that describes a policy rule, but does not contain information
		 * about who the rule applies to or which namespace the rule applies to.
		 */
		export interface PolicyRule {
			/**
			 * Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
			 * contained in this rule.  VerbAll represents all kinds.
			 */
			verbs: string[]

			/**
			 * APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups
			 * are specified, any action requested against one of the enumerated resources in any API
			 * group will be allowed.
			 */
			apiGroups?: string[]

			/**
			 * NonResourceURLs is a set of partial urls that a user should have access to.  *s are
			 * allowed, but only as the full, final step in the path This name is intentionally different
			 * than the internal type so that the DefaultConvert works nicely and because the ordering may
			 * be different. Since non-resource URLs are not namespaced, this field is only applicable for
			 * ClusterRoles referenced from a ClusterRoleBinding. Rules can either apply to API resources
			 * (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
			 */
			nonResourceURLs?: string[]

			/**
			 * ResourceNames is an optional white list of names that the rule applies to.  An empty set
			 * means that everything is allowed.
			 */
			resourceNames?: string[]

			/**
			 * Resources is a list of resources this rule applies to.  ResourceAll represents all
			 * resources.
			 */
			resources?: string[]
		}

		/**
		 * Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
		 * RoleBinding.
		 *
		 * @deprecated rbac/v1alpha1/Role is deprecated by rbac/v1/Role and not supported by Kubernetes
		 * v1.20+ clusters.
		 */
		export interface Role {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Role'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Rules holds all the PolicyRules for this Role
			 */
			rules?: rbac.v1alpha1.PolicyRule[]
		}

		export function isRole(o: any): o is Role {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1alpha1' && o.kind == 'Role'
			)
		}

		/**
		 * RoleBinding references a role, but does not contain it.  It can reference a Role in the same
		 * namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
		 * namespace information by which namespace it exists in.  RoleBindings in a given namespace
		 * only have effect in that namespace.
		 *
		 * @deprecated rbac/v1alpha1/RoleBinding is deprecated by rbac/v1/RoleBinding and not supported
		 * by Kubernetes v1.20+ clusters.
		 */
		export interface RoleBinding {
			/**
			 * RoleRef can reference a Role in the current namespace or a ClusterRole in the global
			 * namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
			 */
			roleRef: rbac.v1alpha1.RoleRef

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RoleBinding'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Subjects holds references to the objects the role applies to.
			 */
			subjects?: rbac.v1alpha1.Subject[]
		}

		export function isRoleBinding(o: any): o is RoleBinding {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1alpha1' &&
				o.kind == 'RoleBinding'
			)
		}

		/**
		 * RoleBindingList is a collection of RoleBindings
		 *
		 * @deprecated rbac/v1alpha1/RoleBindingList is deprecated by rbac/v1/RoleBindingList and not
		 * supported by Kubernetes v1.20+ clusters.
		 */
		export interface RoleBindingList {
			/**
			 * Items is a list of RoleBindings
			 */
			items: rbac.v1alpha1.RoleBinding[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RoleBindingList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isRoleBindingList(o: any): o is RoleBindingList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1alpha1' &&
				o.kind == 'RoleBindingList'
			)
		}

		/**
		 * RoleList is a collection of Roles.
		 *
		 * @deprecated rbac/v1alpha1/RoleList is deprecated by rbac/v1/RoleList and not supported by
		 * Kubernetes v1.20+ clusters.
		 */
		export interface RoleList {
			/**
			 * Items is a list of Roles
			 */
			items: rbac.v1alpha1.Role[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RoleList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isRoleList(o: any): o is RoleList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1alpha1' &&
				o.kind == 'RoleList'
			)
		}

		/**
		 * RoleRef contains information that points to the role being used
		 */
		export interface RoleRef {
			/**
			 * APIGroup is the group for the resource being referenced
			 */
			apiGroup: string

			/**
			 * Kind is the type of resource being referenced
			 */
			kind: string

			/**
			 * Name is the name of resource being referenced
			 */
			name: string
		}

		/**
		 * Subject contains a reference to the object or user identities a role binding applies to.
		 * This can either hold a direct API object reference, or a value for non-objects such as user
		 * and group names.
		 */
		export interface Subject {
			/**
			 * Kind of object being referenced. Values defined by this API group are "User", "Group", and
			 * "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer
			 * should report an error.
			 */
			kind: string

			/**
			 * Name of the object being referenced.
			 */
			name: string

			/**
			 * APIVersion holds the API group and version of the referenced subject. Defaults to "v1" for
			 * ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io/v1alpha1" for User and
			 * Group subjects.
			 */
			apiVersion?: string

			/**
			 * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or
			 * "Group", and this value is not empty the Authorizer should report an error.
			 */
			namespace?: string
		}

		export function isSubject(o: any): o is Subject {
			return o.apiVersion == 'rbac/v1alpha1' && o.kind == 'Subject'
		}
	}
	export namespace v1beta1 {
		/**
		 * AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
		 */
		export interface AggregationRule {
			/**
			 * ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and
			 * create the rules. If any of the selectors match, then the ClusterRole's permissions will be
			 * added
			 */
			clusterRoleSelectors?: meta.v1.LabelSelector[]
		}

		/**
		 * ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a
		 * unit by a RoleBinding or ClusterRoleBinding.
		 *
		 * @deprecated rbac/v1beta1/ClusterRole is deprecated by rbac/v1/ClusterRole and not supported
		 * by Kubernetes v1.20+ clusters.
		 */
		export interface ClusterRole {
			/**
			 * AggregationRule is an optional field that describes how to build the Rules for this
			 * ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct
			 * changes to Rules will be stomped by the controller.
			 */
			aggregationRule?: rbac.v1beta1.AggregationRule

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRole'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Rules holds all the PolicyRules for this ClusterRole
			 */
			rules?: rbac.v1beta1.PolicyRule[]
		}

		export function isClusterRole(o: any): o is ClusterRole {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1beta1' &&
				o.kind == 'ClusterRole'
			)
		}

		/**
		 * ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a
		 * ClusterRole in the global namespace, and adds who information via Subject.
		 *
		 * @deprecated rbac/v1beta1/ClusterRoleBinding is deprecated by rbac/v1/ClusterRoleBinding and
		 * not supported by Kubernetes v1.20+ clusters.
		 */
		export interface ClusterRoleBinding {
			/**
			 * RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot be
			 * resolved, the Authorizer must return an error.
			 */
			roleRef: rbac.v1beta1.RoleRef

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRoleBinding'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Subjects holds references to the objects the role applies to.
			 */
			subjects?: rbac.v1beta1.Subject[]
		}

		export function isClusterRoleBinding(o: any): o is ClusterRoleBinding {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1beta1' &&
				o.kind == 'ClusterRoleBinding'
			)
		}

		/**
		 * ClusterRoleBindingList is a collection of ClusterRoleBindings.
		 *
		 * @deprecated rbac/v1beta1/ClusterRoleBindingList is deprecated by
		 * rbac/v1/ClusterRoleBindingList and not supported by Kubernetes v1.20+ clusters.
		 */
		export interface ClusterRoleBindingList {
			/**
			 * Items is a list of ClusterRoleBindings
			 */
			items: rbac.v1beta1.ClusterRoleBinding[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRoleBindingList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isClusterRoleBindingList(
			o: any
		): o is ClusterRoleBindingList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1beta1' &&
				o.kind == 'ClusterRoleBindingList'
			)
		}

		/**
		 * ClusterRoleList is a collection of ClusterRoles.
		 *
		 * @deprecated rbac/v1beta1/ClusterRoleList is deprecated by rbac/v1/ClusterRoleList and not
		 * supported by Kubernetes v1.20+ clusters.
		 */
		export interface ClusterRoleList {
			/**
			 * Items is a list of ClusterRoles
			 */
			items: rbac.v1beta1.ClusterRole[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'ClusterRoleList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isClusterRoleList(o: any): o is ClusterRoleList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1beta1' &&
				o.kind == 'ClusterRoleList'
			)
		}

		/**
		 * PolicyRule holds information that describes a policy rule, but does not contain information
		 * about who the rule applies to or which namespace the rule applies to.
		 */
		export interface PolicyRule {
			/**
			 * Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions
			 * contained in this rule.  VerbAll represents all kinds.
			 */
			verbs: string[]

			/**
			 * APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups
			 * are specified, any action requested against one of the enumerated resources in any API
			 * group will be allowed.
			 */
			apiGroups?: string[]

			/**
			 * NonResourceURLs is a set of partial urls that a user should have access to.  *s are
			 * allowed, but only as the full, final step in the path Since non-resource URLs are not
			 * namespaced, this field is only applicable for ClusterRoles referenced from a
			 * ClusterRoleBinding. Rules can either apply to API resources (such as "pods" or "secrets")
			 * or non-resource URL paths (such as "/api"),  but not both.
			 */
			nonResourceURLs?: string[]

			/**
			 * ResourceNames is an optional white list of names that the rule applies to.  An empty set
			 * means that everything is allowed.
			 */
			resourceNames?: string[]

			/**
			 * Resources is a list of resources this rule applies to.  '*' represents all resources in the
			 * specified apiGroups. '*&#8205;/foo' represents the subresource 'foo' for all resources in
			 * the specified apiGroups.
			 */
			resources?: string[]
		}

		/**
		 * Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a
		 * RoleBinding.
		 *
		 * @deprecated rbac/v1beta1/Role is deprecated by rbac/v1/Role and not supported by Kubernetes
		 * v1.20+ clusters.
		 */
		export interface Role {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'Role'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Rules holds all the PolicyRules for this Role
			 */
			rules?: rbac.v1beta1.PolicyRule[]
		}

		export function isRole(o: any): o is Role {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1beta1' && o.kind == 'Role'
			)
		}

		/**
		 * RoleBinding references a role, but does not contain it.  It can reference a Role in the same
		 * namespace or a ClusterRole in the global namespace. It adds who information via Subjects and
		 * namespace information by which namespace it exists in.  RoleBindings in a given namespace
		 * only have effect in that namespace.
		 *
		 * @deprecated rbac/v1beta1/RoleBinding is deprecated by rbac/v1/RoleBinding and not supported
		 * by Kubernetes v1.20+ clusters.
		 */
		export interface RoleBinding {
			/**
			 * RoleRef can reference a Role in the current namespace or a ClusterRole in the global
			 * namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
			 */
			roleRef: rbac.v1beta1.RoleRef

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RoleBinding'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Subjects holds references to the objects the role applies to.
			 */
			subjects?: rbac.v1beta1.Subject[]
		}

		export function isRoleBinding(o: any): o is RoleBinding {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1beta1' &&
				o.kind == 'RoleBinding'
			)
		}

		/**
		 * RoleBindingList is a collection of RoleBindings
		 *
		 * @deprecated rbac/v1beta1/RoleBindingList is deprecated by rbac/v1/RoleBindingList and not
		 * supported by Kubernetes v1.20+ clusters.
		 */
		export interface RoleBindingList {
			/**
			 * Items is a list of RoleBindings
			 */
			items: rbac.v1beta1.RoleBinding[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RoleBindingList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isRoleBindingList(o: any): o is RoleBindingList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1beta1' &&
				o.kind == 'RoleBindingList'
			)
		}

		/**
		 * RoleList is a collection of Roles
		 *
		 * @deprecated rbac/v1beta1/RoleList is deprecated by rbac/v1/RoleList and not supported by
		 * Kubernetes v1.20+ clusters.
		 */
		export interface RoleList {
			/**
			 * Items is a list of Roles
			 */
			items: rbac.v1beta1.Role[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'rbac.authorization.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'RoleList'

			/**
			 * Standard object's metadata.
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isRoleList(o: any): o is RoleList {
			return (
				o.apiVersion == 'rbac.authorization.k8s.io/v1beta1' &&
				o.kind == 'RoleList'
			)
		}

		/**
		 * RoleRef contains information that points to the role being used
		 */
		export interface RoleRef {
			/**
			 * APIGroup is the group for the resource being referenced
			 */
			apiGroup: string

			/**
			 * Kind is the type of resource being referenced
			 */
			kind: string

			/**
			 * Name is the name of resource being referenced
			 */
			name: string
		}

		/**
		 * Subject contains a reference to the object or user identities a role binding applies to.
		 * This can either hold a direct API object reference, or a value for non-objects such as user
		 * and group names.
		 */
		export interface Subject {
			/**
			 * Kind of object being referenced. Values defined by this API group are "User", "Group", and
			 * "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer
			 * should report an error.
			 */
			kind: string

			/**
			 * Name of the object being referenced.
			 */
			name: string

			/**
			 * APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount
			 * subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
			 */
			apiGroup?: string

			/**
			 * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or
			 * "Group", and this value is not empty the Authorizer should report an error.
			 */
			namespace?: string
		}
	}
}

export namespace scheduling {
	export namespace v1 {
		/**
		 * PriorityClass defines mapping from a priority class name to the priority integer value. The
		 * value can be any valid integer.
		 */
		export interface PriorityClass {
			/**
			 * The value of this priority class. This is the actual priority that pods receive when they
			 * have the name of this class in their pod spec.
			 */
			value: number

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'scheduling.k8s.io/v1'

			/**
			 * description is an arbitrary string that usually provides guidelines on when this priority
			 * class should be used.
			 */
			description?: string

			/**
			 * globalDefault specifies whether this PriorityClass should be considered as the default
			 * priority for pods that do not have any priority class. Only one PriorityClass can be marked
			 * as `globalDefault`. However, if more than one PriorityClasses exists with their
			 * `globalDefault` field set to true, the smallest value of such global default
			 * PriorityClasses will be used as the default priority.
			 */
			globalDefault?: boolean

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PriorityClass'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
			 * PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is alpha-level
			 * and is only honored by servers that enable the NonPreemptingPriority feature.
			 */
			preemptionPolicy?: string
		}

		export function isPriorityClass(o: any): o is PriorityClass {
			return o.apiVersion == 'scheduling.k8s.io/v1' && o.kind == 'PriorityClass'
		}

		/**
		 * PriorityClassList is a collection of priority classes.
		 */
		export interface PriorityClassList {
			/**
			 * items is the list of PriorityClasses
			 */
			items: scheduling.v1.PriorityClass[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'scheduling.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PriorityClassList'

			/**
			 * Standard list metadata More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isPriorityClassList(o: any): o is PriorityClassList {
			return (
				o.apiVersion == 'scheduling.k8s.io/v1' && o.kind == 'PriorityClassList'
			)
		}
	}
	export namespace v1alpha1 {
		/**
		 * PriorityClass defines mapping from a priority class name to the priority integer value. The
		 * value can be any valid integer.
		 *
		 * @deprecated scheduling/v1alpha1/PriorityClass is deprecated by scheduling/v1/PriorityClass
		 * and not supported by Kubernetes v1.17+ clusters.
		 */
		export interface PriorityClass {
			/**
			 * The value of this priority class. This is the actual priority that pods receive when they
			 * have the name of this class in their pod spec.
			 */
			value: number

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'scheduling.k8s.io/v1alpha1'

			/**
			 * description is an arbitrary string that usually provides guidelines on when this priority
			 * class should be used.
			 */
			description?: string

			/**
			 * globalDefault specifies whether this PriorityClass should be considered as the default
			 * priority for pods that do not have any priority class. Only one PriorityClass can be marked
			 * as `globalDefault`. However, if more than one PriorityClasses exists with their
			 * `globalDefault` field set to true, the smallest value of such global default
			 * PriorityClasses will be used as the default priority.
			 */
			globalDefault?: boolean

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PriorityClass'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
			 * PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is alpha-level
			 * and is only honored by servers that enable the NonPreemptingPriority feature.
			 */
			preemptionPolicy?: string
		}

		export function isPriorityClass(o: any): o is PriorityClass {
			return (
				o.apiVersion == 'scheduling.k8s.io/v1alpha1' &&
				o.kind == 'PriorityClass'
			)
		}

		/**
		 * PriorityClassList is a collection of priority classes.
		 */
		export interface PriorityClassList {
			/**
			 * items is the list of PriorityClasses
			 */
			items: scheduling.v1alpha1.PriorityClass[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'scheduling.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PriorityClassList'

			/**
			 * Standard list metadata More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isPriorityClassList(o: any): o is PriorityClassList {
			return (
				o.apiVersion == 'scheduling.k8s.io/v1alpha1' &&
				o.kind == 'PriorityClassList'
			)
		}
	}
	export namespace v1beta1 {
		/**
		 * PriorityClass defines mapping from a priority class name to the priority integer value. The
		 * value can be any valid integer.
		 *
		 * @deprecated scheduling/v1beta1/PriorityClass is deprecated by scheduling/v1/PriorityClass and
		 * not supported by Kubernetes v1.17+ clusters.
		 */
		export interface PriorityClass {
			/**
			 * The value of this priority class. This is the actual priority that pods receive when they
			 * have the name of this class in their pod spec.
			 */
			value: number

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'scheduling.k8s.io/v1beta1'

			/**
			 * description is an arbitrary string that usually provides guidelines on when this priority
			 * class should be used.
			 */
			description?: string

			/**
			 * globalDefault specifies whether this PriorityClass should be considered as the default
			 * priority for pods that do not have any priority class. Only one PriorityClass can be marked
			 * as `globalDefault`. However, if more than one PriorityClasses exists with their
			 * `globalDefault` field set to true, the smallest value of such global default
			 * PriorityClasses will be used as the default priority.
			 */
			globalDefault?: boolean

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PriorityClass'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
			 * PreemptLowerPriority. Defaults to PreemptLowerPriority if unset. This field is alpha-level
			 * and is only honored by servers that enable the NonPreemptingPriority feature.
			 */
			preemptionPolicy?: string
		}

		export function isPriorityClass(o: any): o is PriorityClass {
			return (
				o.apiVersion == 'scheduling.k8s.io/v1beta1' && o.kind == 'PriorityClass'
			)
		}

		/**
		 * PriorityClassList is a collection of priority classes.
		 */
		export interface PriorityClassList {
			/**
			 * items is the list of PriorityClasses
			 */
			items: scheduling.v1beta1.PriorityClass[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'scheduling.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PriorityClassList'

			/**
			 * Standard list metadata More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isPriorityClassList(o: any): o is PriorityClassList {
			return (
				o.apiVersion == 'scheduling.k8s.io/v1beta1' &&
				o.kind == 'PriorityClassList'
			)
		}
	}
}

export namespace settings {
	export namespace v1alpha1 {
		/**
		 * PodPreset is a policy resource that defines additional runtime requirements for a Pod.
		 */
		export interface PodPreset {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'settings.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PodPreset'

			metadata?: meta.v1.ObjectMeta

			spec?: settings.v1alpha1.PodPresetSpec
		}

		export function isPodPreset(o: any): o is PodPreset {
			return o.apiVersion == 'settings.k8s.io/v1alpha1' && o.kind == 'PodPreset'
		}

		/**
		 * PodPresetList is a list of PodPreset objects.
		 */
		export interface PodPresetList {
			/**
			 * Items is a list of schema objects.
			 */
			items: settings.v1alpha1.PodPreset[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'settings.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'PodPresetList'

			/**
			 * Standard list metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isPodPresetList(o: any): o is PodPresetList {
			return (
				o.apiVersion == 'settings.k8s.io/v1alpha1' && o.kind == 'PodPresetList'
			)
		}

		/**
		 * PodPresetSpec is a description of a pod preset.
		 */
		export interface PodPresetSpec {
			/**
			 * Env defines the collection of EnvVar to inject into containers.
			 */
			env?: core.v1.EnvVar[]

			/**
			 * EnvFrom defines the collection of EnvFromSource to inject into containers.
			 */
			envFrom?: core.v1.EnvFromSource[]

			/**
			 * Selector is a label query over a set of resources, in this case pods. Required.
			 */
			selector?: meta.v1.LabelSelector

			/**
			 * VolumeMounts defines the collection of VolumeMount to inject into containers.
			 */
			volumeMounts?: core.v1.VolumeMount[]

			/**
			 * Volumes defines the collection of Volume to inject into the pod.
			 */
			volumes?: core.v1.Volume[]
		}
	}
}

export namespace storage {
	export namespace v1 {
		/**
		 * CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need
		 * to create the CSINode object directly. As long as they use the node-driver-registrar sidecar
		 * container, the kubelet will automatically populate the CSINode object for the CSI driver as
		 * part of kubelet plugin registration. CSINode has the same name as a node. If the object is
		 * missing, it means either there are no CSI Drivers available on the node, or the Kubelet
		 * version is low enough that it doesn't create this object. CSINode has an OwnerReference that
		 * points to the corresponding node object.
		 */
		export interface CSINode {
			/**
			 * spec is the specification of CSINode
			 */
			spec: storage.v1.CSINodeSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CSINode'

			/**
			 * metadata.name must be the Kubernetes node name.
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isCSINode(o: any): o is CSINode {
			return o.apiVersion == 'storage.k8s.io/v1' && o.kind == 'CSINode'
		}

		/**
		 * CSINodeDriver holds information about the specification of one CSI driver installed on a node
		 */
		export interface CSINodeDriver {
			/**
			 * This is the name of the CSI driver that this object refers to. This MUST be the same name
			 * returned by the CSI GetPluginName() call for that driver.
			 */
			name: string

			/**
			 * nodeID of the node from the driver point of view. This field enables Kubernetes to
			 * communicate with storage systems that do not share the same nomenclature for nodes. For
			 * example, Kubernetes may refer to a given node as "node1", but the storage system may refer
			 * to the same node as "nodeA". When Kubernetes issues a command to the storage system to
			 * attach a volume to a specific node, it can use this field to refer to the node name using
			 * the ID that the storage system will understand, e.g. "nodeA" instead of "node1". This field
			 * is required.
			 */
			nodeID: string

			/**
			 * allocatable represents the volume resources of a node that are available for scheduling.
			 * This field is beta.
			 */
			allocatable?: storage.v1.VolumeNodeResources

			/**
			 * topologyKeys is the list of keys supported by the driver. When a driver is initialized on a
			 * cluster, it provides a set of topology keys that it understands (e.g. "company.com/zone",
			 * "company.com/region"). When a driver is initialized on a node, it provides the same
			 * topology keys along with values. Kubelet will expose these topology keys as labels on its
			 * own node object. When Kubernetes does topology aware provisioning, it can use this list to
			 * determine which labels it should retrieve from the node object and pass back to the driver.
			 * It is possible for different nodes to use different topology keys. This can be empty if
			 * driver does not support topology.
			 */
			topologyKeys?: string[]
		}

		/**
		 * CSINodeList is a collection of CSINode objects.
		 */
		export interface CSINodeList {
			/**
			 * items is the list of CSINode
			 */
			items: storage.v1.CSINode[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CSINodeList'

			/**
			 * Standard list metadata More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isCSINodeList(o: any): o is CSINodeList {
			return o.apiVersion == 'storage.k8s.io/v1' && o.kind == 'CSINodeList'
		}

		/**
		 * CSINodeSpec holds information about the specification of all CSI drivers installed on a node
		 */
		export interface CSINodeSpec {
			/**
			 * drivers is a list of information of all CSI Drivers existing on a node. If all drivers in
			 * the list are uninstalled, this can become empty.
			 */
			drivers: storage.v1.CSINodeDriver[]
		}

		/**
		 * StorageClass describes the parameters for a class of storage for which PersistentVolumes can
		 * be dynamically provisioned.
		 *
		 * StorageClasses are non-namespaced; the name of the storage class according to etcd is in
		 * ObjectMeta.Name.
		 */
		export interface StorageClass {
			/**
			 * Provisioner indicates the type of the provisioner.
			 */
			provisioner: string

			/**
			 * AllowVolumeExpansion shows whether the storage class allow volume expand
			 */
			allowVolumeExpansion?: boolean

			/**
			 * Restrict the node topologies where volumes can be dynamically provisioned. Each volume
			 * plugin defines its own supported topology specifications. An empty TopologySelectorTerm
			 * list means there is no topology restriction. This field is only honored by servers that
			 * enable the VolumeScheduling feature.
			 */
			allowedTopologies?: core.v1.TopologySelectorTerm[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'StorageClass'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Dynamically provisioned PersistentVolumes of this storage class are created with these
			 * mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if one
			 * is invalid.
			 */
			mountOptions?: string[]

			/**
			 * Parameters holds the parameters for the provisioner that should create volumes of this
			 * storage class.
			 */
			parameters?: { [key: string]: string }

			/**
			 * Dynamically provisioned PersistentVolumes of this storage class are created with this
			 * reclaimPolicy. Defaults to Delete.
			 */
			reclaimPolicy?: string

			/**
			 * VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound.
			 * When unset, VolumeBindingImmediate is used. This field is only honored by servers that
			 * enable the VolumeScheduling feature.
			 */
			volumeBindingMode?: string
		}

		export function isStorageClass(o: any): o is StorageClass {
			return o.apiVersion == 'storage.k8s.io/v1' && o.kind == 'StorageClass'
		}

		/**
		 * StorageClassList is a collection of storage classes.
		 */
		export interface StorageClassList {
			/**
			 * Items is the list of StorageClasses
			 */
			items: storage.v1.StorageClass[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'StorageClassList'

			/**
			 * Standard list metadata More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isStorageClassList(o: any): o is StorageClassList {
			return o.apiVersion == 'storage.k8s.io/v1' && o.kind == 'StorageClassList'
		}

		/**
		 * VolumeAttachment captures the intent to attach or detach the specified volume to/from the
		 * specified node.
		 *
		 * VolumeAttachment objects are non-namespaced.
		 */
		export interface VolumeAttachment {
			/**
			 * Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
			 * system.
			 */
			spec: storage.v1.VolumeAttachmentSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'VolumeAttachment'

			/**
			 * Standard object metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isVolumeAttachment(o: any): o is VolumeAttachment {
			return o.apiVersion == 'storage.k8s.io/v1' && o.kind == 'VolumeAttachment'
		}

		/**
		 * VolumeAttachmentList is a collection of VolumeAttachment objects.
		 */
		export interface VolumeAttachmentList {
			/**
			 * Items is the list of VolumeAttachments
			 */
			items: storage.v1.VolumeAttachment[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'VolumeAttachmentList'

			/**
			 * Standard list metadata More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isVolumeAttachmentList(o: any): o is VolumeAttachmentList {
			return (
				o.apiVersion == 'storage.k8s.io/v1' && o.kind == 'VolumeAttachmentList'
			)
		}

		/**
		 * VolumeAttachmentSource represents a volume that should be attached. Right now only
		 * PersistenVolumes can be attached via external attacher, in future we may allow also inline
		 * volumes in pods. Exactly one member can be set.
		 */
		export interface VolumeAttachmentSource {
			/**
			 * inlineVolumeSpec contains all the information necessary to attach a persistent volume
			 * defined by a pod's inline VolumeSource. This field is populated only for the CSIMigration
			 * feature. It contains translated fields from a pod's inline VolumeSource to a
			 * PersistentVolumeSpec. This field is alpha-level and is only honored by servers that enabled
			 * the CSIMigration feature.
			 */
			inlineVolumeSpec?: core.v1.PersistentVolumeSpec

			/**
			 * Name of the persistent volume to attach.
			 */
			persistentVolumeName?: string
		}

		/**
		 * VolumeAttachmentSpec is the specification of a VolumeAttachment request.
		 */
		export interface VolumeAttachmentSpec {
			/**
			 * Attacher indicates the name of the volume driver that MUST handle this request. This is the
			 * name returned by GetPluginName().
			 */
			attacher: string

			/**
			 * The node that the volume should be attached to.
			 */
			nodeName: string

			/**
			 * Source represents the volume that should be attached.
			 */
			source: storage.v1.VolumeAttachmentSource
		}

		/**
		 * VolumeError captures an error encountered during a volume operation.
		 */
		export interface VolumeError {
			/**
			 * String detailing the error encountered during Attach or Detach operation. This string may
			 * be logged, so it should not contain sensitive information.
			 */
			message?: string

			/**
			 * Time the error was encountered.
			 */
			time?: string
		}

		/**
		 * VolumeNodeResources is a set of resource limits for scheduling of volumes.
		 */
		export interface VolumeNodeResources {
			/**
			 * Maximum number of unique volumes managed by the CSI driver that can be used on a node. A
			 * volume that is both attached and mounted on a node is considered to be used once, not
			 * twice. The same rule applies for a unique volume that is shared among multiple pods on the
			 * same node. If this field is not specified, then the supported number of volumes on this
			 * node is unbounded.
			 */
			count?: number
		}
	}
	export namespace v1alpha1 {
		/**
		 * VolumeAttachment captures the intent to attach or detach the specified volume to/from the
		 * specified node.
		 *
		 * VolumeAttachment objects are non-namespaced.
		 */
		export interface VolumeAttachment {
			/**
			 * Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
			 * system.
			 */
			spec: storage.v1alpha1.VolumeAttachmentSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'VolumeAttachment'

			/**
			 * Standard object metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isVolumeAttachment(o: any): o is VolumeAttachment {
			return (
				o.apiVersion == 'storage.k8s.io/v1alpha1' &&
				o.kind == 'VolumeAttachment'
			)
		}

		/**
		 * VolumeAttachmentList is a collection of VolumeAttachment objects.
		 */
		export interface VolumeAttachmentList {
			/**
			 * Items is the list of VolumeAttachments
			 */
			items: storage.v1alpha1.VolumeAttachment[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1alpha1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'VolumeAttachmentList'

			/**
			 * Standard list metadata More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isVolumeAttachmentList(o: any): o is VolumeAttachmentList {
			return (
				o.apiVersion == 'storage.k8s.io/v1alpha1' &&
				o.kind == 'VolumeAttachmentList'
			)
		}

		/**
		 * VolumeAttachmentSource represents a volume that should be attached. Right now only
		 * PersistenVolumes can be attached via external attacher, in future we may allow also inline
		 * volumes in pods. Exactly one member can be set.
		 */
		export interface VolumeAttachmentSource {
			/**
			 * inlineVolumeSpec contains all the information necessary to attach a persistent volume
			 * defined by a pod's inline VolumeSource. This field is populated only for the CSIMigration
			 * feature. It contains translated fields from a pod's inline VolumeSource to a
			 * PersistentVolumeSpec. This field is alpha-level and is only honored by servers that enabled
			 * the CSIMigration feature.
			 */
			inlineVolumeSpec?: core.v1.PersistentVolumeSpec

			/**
			 * Name of the persistent volume to attach.
			 */
			persistentVolumeName?: string
		}

		/**
		 * VolumeAttachmentSpec is the specification of a VolumeAttachment request.
		 */
		export interface VolumeAttachmentSpec {
			/**
			 * Attacher indicates the name of the volume driver that MUST handle this request. This is the
			 * name returned by GetPluginName().
			 */
			attacher: string

			/**
			 * The node that the volume should be attached to.
			 */
			nodeName: string

			/**
			 * Source represents the volume that should be attached.
			 */
			source: storage.v1alpha1.VolumeAttachmentSource
		}

		/**
		 * VolumeError captures an error encountered during a volume operation.
		 */
		export interface VolumeError {
			/**
			 * String detailing the error encountered during Attach or Detach operation. This string maybe
			 * logged, so it should not contain sensitive information.
			 */
			message?: string

			/**
			 * Time the error was encountered.
			 */
			time?: string
		}
	}
	export namespace v1beta1 {
		/**
		 * CSIDriver captures information about a Container Storage Interface (CSI) volume driver
		 * deployed on the cluster. CSI drivers do not need to create the CSIDriver object directly.
		 * Instead they may use the cluster-driver-registrar sidecar container. When deployed with a CSI
		 * driver it automatically creates a CSIDriver object representing the driver. Kubernetes attach
		 * detach controller uses this object to determine whether attach is required. Kubelet uses this
		 * object to determine whether pod information needs to be passed on mount. CSIDriver objects
		 * are non-namespaced.
		 */
		export interface CSIDriver {
			/**
			 * Specification of the CSI Driver.
			 */
			spec: storage.v1beta1.CSIDriverSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CSIDriver'

			/**
			 * Standard object metadata. metadata.Name indicates the name of the CSI driver that this
			 * object refers to; it MUST be the same name returned by the CSI GetPluginName() call for
			 * that driver. The driver name must be 63 characters or less, beginning and ending with an
			 * alphanumeric character ([a-z0-9A-Z]) with dashes (-), dots (.), and alphanumerics between.
			 * More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isCSIDriver(o: any): o is CSIDriver {
			return o.apiVersion == 'storage.k8s.io/v1beta1' && o.kind == 'CSIDriver'
		}

		/**
		 * CSIDriverList is a collection of CSIDriver objects.
		 */
		export interface CSIDriverList {
			/**
			 * items is the list of CSIDriver
			 */
			items: storage.v1beta1.CSIDriver[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CSIDriverList'

			/**
			 * Standard list metadata More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isCSIDriverList(o: any): o is CSIDriverList {
			return (
				o.apiVersion == 'storage.k8s.io/v1beta1' && o.kind == 'CSIDriverList'
			)
		}

		/**
		 * CSIDriverSpec is the specification of a CSIDriver.
		 */
		export interface CSIDriverSpec {
			/**
			 * attachRequired indicates this CSI volume driver requires an attach operation (because it
			 * implements the CSI ControllerPublishVolume() method), and that the Kubernetes attach detach
			 * controller should call the attach volume interface which checks the volumeattachment status
			 * and waits until the volume is attached before proceeding to mounting. The CSI
			 * external-attacher coordinates with CSI volume driver and updates the volumeattachment
			 * status when the attach operation is complete. If the CSIDriverRegistry feature gate is
			 * enabled and the value is specified to false, the attach operation will be skipped.
			 * Otherwise the attach operation will be called.
			 */
			attachRequired?: boolean

			/**
			 * If set to true, podInfoOnMount indicates this CSI volume driver requires additional pod
			 * information (like podName, podUID, etc.) during mount operations. If set to false, pod
			 * information will not be passed on mount. Default is false. The CSI driver specifies
			 * podInfoOnMount as part of driver deployment. If true, Kubelet will pass pod information as
			 * VolumeContext in the CSI NodePublishVolume() calls. The CSI driver is responsible for
			 * parsing and validating the information passed in as VolumeContext. The following
			 * VolumeConext will be passed if podInfoOnMount is set to true. This list might grow, but the
			 * prefix will be used. "csi.storage.k8s.io/pod.name": pod.Name
			 * "csi.storage.k8s.io/pod.namespace": pod.Namespace "csi.storage.k8s.io/pod.uid":
			 * string(pod.UID) "csi.storage.k8s.io/ephemeral": "true" iff the volume is an ephemeral
			 * inline volume
			 *                                 defined by a CSIVolumeSource, otherwise "false"
			 *
			 * "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only required for
			 * drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode. Other
			 * drivers can leave pod info disabled and/or ignore this field. As Kubernetes 1.15 doesn't
			 * support this field, drivers can only support one mode when deployed on such a cluster and
			 * the deployment determines which mode that is, for example via a command line parameter of
			 * the driver.
			 */
			podInfoOnMount?: boolean

			/**
			 * VolumeLifecycleModes defines what kind of volumes this CSI volume driver supports. The
			 * default if the list is empty is "Persistent", which is the usage defined by the CSI
			 * specification and implemented in Kubernetes via the usual PV/PVC mechanism. The other mode
			 * is "Ephemeral". In this mode, volumes are defined inline inside the pod spec with
			 * CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod. A driver has to
			 * be aware of this because it is only going to get a NodePublishVolume call for such a
			 * volume. For more information about implementing this mode, see
			 * https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html A driver can support one
			 * or more of these modes and more modes may be added in the future.
			 */
			volumeLifecycleModes?: string[]
		}

		/**
		 * CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need
		 * to create the CSINode object directly. As long as they use the node-driver-registrar sidecar
		 * container, the kubelet will automatically populate the CSINode object for the CSI driver as
		 * part of kubelet plugin registration. CSINode has the same name as a node. If the object is
		 * missing, it means either there are no CSI Drivers available on the node, or the Kubelet
		 * version is low enough that it doesn't create this object. CSINode has an OwnerReference that
		 * points to the corresponding node object.
		 *
		 * @deprecated storage/v1beta1/CSINode is deprecated by storage/v1/CSINode.
		 */
		export interface CSINode {
			/**
			 * spec is the specification of CSINode
			 */
			spec: storage.v1beta1.CSINodeSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CSINode'

			/**
			 * metadata.name must be the Kubernetes node name.
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isCSINode(o: any): o is CSINode {
			return o.apiVersion == 'storage.k8s.io/v1beta1' && o.kind == 'CSINode'
		}

		/**
		 * CSINodeDriver holds information about the specification of one CSI driver installed on a node
		 */
		export interface CSINodeDriver {
			/**
			 * This is the name of the CSI driver that this object refers to. This MUST be the same name
			 * returned by the CSI GetPluginName() call for that driver.
			 */
			name: string

			/**
			 * nodeID of the node from the driver point of view. This field enables Kubernetes to
			 * communicate with storage systems that do not share the same nomenclature for nodes. For
			 * example, Kubernetes may refer to a given node as "node1", but the storage system may refer
			 * to the same node as "nodeA". When Kubernetes issues a command to the storage system to
			 * attach a volume to a specific node, it can use this field to refer to the node name using
			 * the ID that the storage system will understand, e.g. "nodeA" instead of "node1". This field
			 * is required.
			 */
			nodeID: string

			/**
			 * allocatable represents the volume resources of a node that are available for scheduling.
			 */
			allocatable?: storage.v1beta1.VolumeNodeResources

			/**
			 * topologyKeys is the list of keys supported by the driver. When a driver is initialized on a
			 * cluster, it provides a set of topology keys that it understands (e.g. "company.com/zone",
			 * "company.com/region"). When a driver is initialized on a node, it provides the same
			 * topology keys along with values. Kubelet will expose these topology keys as labels on its
			 * own node object. When Kubernetes does topology aware provisioning, it can use this list to
			 * determine which labels it should retrieve from the node object and pass back to the driver.
			 * It is possible for different nodes to use different topology keys. This can be empty if
			 * driver does not support topology.
			 */
			topologyKeys?: string[]
		}

		/**
		 * CSINodeList is a collection of CSINode objects.
		 */
		export interface CSINodeList {
			/**
			 * items is the list of CSINode
			 */
			items: storage.v1beta1.CSINode[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'CSINodeList'

			/**
			 * Standard list metadata More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isCSINodeList(o: any): o is CSINodeList {
			return o.apiVersion == 'storage.k8s.io/v1beta1' && o.kind == 'CSINodeList'
		}

		/**
		 * CSINodeSpec holds information about the specification of all CSI drivers installed on a node
		 */
		export interface CSINodeSpec {
			/**
			 * drivers is a list of information of all CSI Drivers existing on a node. If all drivers in
			 * the list are uninstalled, this can become empty.
			 */
			drivers: storage.v1beta1.CSINodeDriver[]
		}

		/**
		 * StorageClass describes the parameters for a class of storage for which PersistentVolumes can
		 * be dynamically provisioned.
		 *
		 * StorageClasses are non-namespaced; the name of the storage class according to etcd is in
		 * ObjectMeta.Name.
		 */
		export interface StorageClass {
			/**
			 * Provisioner indicates the type of the provisioner.
			 */
			provisioner: string

			/**
			 * AllowVolumeExpansion shows whether the storage class allow volume expand
			 */
			allowVolumeExpansion?: boolean

			/**
			 * Restrict the node topologies where volumes can be dynamically provisioned. Each volume
			 * plugin defines its own supported topology specifications. An empty TopologySelectorTerm
			 * list means there is no topology restriction. This field is only honored by servers that
			 * enable the VolumeScheduling feature.
			 */
			allowedTopologies?: core.v1.TopologySelectorTerm[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'StorageClass'

			/**
			 * Standard object's metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta

			/**
			 * Dynamically provisioned PersistentVolumes of this storage class are created with these
			 * mountOptions, e.g. ["ro", "soft"]. Not validated - mount of the PVs will simply fail if one
			 * is invalid.
			 */
			mountOptions?: string[]

			/**
			 * Parameters holds the parameters for the provisioner that should create volumes of this
			 * storage class.
			 */
			parameters?: { [key: string]: string }

			/**
			 * Dynamically provisioned PersistentVolumes of this storage class are created with this
			 * reclaimPolicy. Defaults to Delete.
			 */
			reclaimPolicy?: string

			/**
			 * VolumeBindingMode indicates how PersistentVolumeClaims should be provisioned and bound.
			 * When unset, VolumeBindingImmediate is used. This field is only honored by servers that
			 * enable the VolumeScheduling feature.
			 */
			volumeBindingMode?: string
		}

		export function isStorageClass(o: any): o is StorageClass {
			return (
				o.apiVersion == 'storage.k8s.io/v1beta1' && o.kind == 'StorageClass'
			)
		}

		/**
		 * StorageClassList is a collection of storage classes.
		 */
		export interface StorageClassList {
			/**
			 * Items is the list of StorageClasses
			 */
			items: storage.v1beta1.StorageClass[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'StorageClassList'

			/**
			 * Standard list metadata More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isStorageClassList(o: any): o is StorageClassList {
			return (
				o.apiVersion == 'storage.k8s.io/v1beta1' && o.kind == 'StorageClassList'
			)
		}

		/**
		 * VolumeAttachment captures the intent to attach or detach the specified volume to/from the
		 * specified node.
		 *
		 * VolumeAttachment objects are non-namespaced.
		 */
		export interface VolumeAttachment {
			/**
			 * Specification of the desired attach/detach volume behavior. Populated by the Kubernetes
			 * system.
			 */
			spec: storage.v1beta1.VolumeAttachmentSpec

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'VolumeAttachment'

			/**
			 * Standard object metadata. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ObjectMeta
		}

		export function isVolumeAttachment(o: any): o is VolumeAttachment {
			return (
				o.apiVersion == 'storage.k8s.io/v1beta1' && o.kind == 'VolumeAttachment'
			)
		}

		/**
		 * VolumeAttachmentList is a collection of VolumeAttachment objects.
		 */
		export interface VolumeAttachmentList {
			/**
			 * Items is the list of VolumeAttachments
			 */
			items: storage.v1beta1.VolumeAttachment[]

			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should
			 * convert recognized schemas to the latest internal value, and may reject unrecognized
			 * values. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: 'storage.k8s.io/v1beta1'

			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may
			 * infer this from the endpoint the client submits requests to. Cannot be updated. In
			 * CamelCase. More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: 'VolumeAttachmentList'

			/**
			 * Standard list metadata More info:
			 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: meta.v1.ListMeta
		}

		export function isVolumeAttachmentList(o: any): o is VolumeAttachmentList {
			return (
				o.apiVersion == 'storage.k8s.io/v1beta1' &&
				o.kind == 'VolumeAttachmentList'
			)
		}

		/**
		 * VolumeAttachmentSource represents a volume that should be attached. Right now only
		 * PersistenVolumes can be attached via external attacher, in future we may allow also inline
		 * volumes in pods. Exactly one member can be set.
		 */
		export interface VolumeAttachmentSource {
			/**
			 * inlineVolumeSpec contains all the information necessary to attach a persistent volume
			 * defined by a pod's inline VolumeSource. This field is populated only for the CSIMigration
			 * feature. It contains translated fields from a pod's inline VolumeSource to a
			 * PersistentVolumeSpec. This field is alpha-level and is only honored by servers that enabled
			 * the CSIMigration feature.
			 */
			inlineVolumeSpec?: core.v1.PersistentVolumeSpec

			/**
			 * Name of the persistent volume to attach.
			 */
			persistentVolumeName?: string
		}

		/**
		 * VolumeAttachmentSpec is the specification of a VolumeAttachment request.
		 */
		export interface VolumeAttachmentSpec {
			/**
			 * Attacher indicates the name of the volume driver that MUST handle this request. This is the
			 * name returned by GetPluginName().
			 */
			attacher: string

			/**
			 * The node that the volume should be attached to.
			 */
			nodeName: string

			/**
			 * Source represents the volume that should be attached.
			 */
			source: storage.v1beta1.VolumeAttachmentSource
		}

		/**
		 * VolumeError captures an error encountered during a volume operation.
		 */
		export interface VolumeError {
			/**
			 * String detailing the error encountered during Attach or Detach operation. This string may
			 * be logged, so it should not contain sensitive information.
			 */
			message?: string

			/**
			 * Time the error was encountered.
			 */
			time?: string
		}

		/**
		 * VolumeNodeResources is a set of resource limits for scheduling of volumes.
		 */
		export interface VolumeNodeResources {
			/**
			 * Maximum number of unique volumes managed by the CSI driver that can be used on a node. A
			 * volume that is both attached and mounted on a node is considered to be used once, not
			 * twice. The same rule applies for a unique volume that is shared among multiple pods on the
			 * same node. If this field is nil, then the supported number of volumes on this node is
			 * unbounded.
			 */
			count?: number
		}
	}
}
