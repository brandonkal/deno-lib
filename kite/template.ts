/**
 * @file template.ts
 * @author Brandon Kalinowski
 * @description Templates YAML and applies Terraform as required.
 * @copyright 2020-2024 Brandon Kalinowski
 * @license MIT
 */

import * as fs from "jsr:@std/fs@0.229.3";
import * as path from "jsr:@std/path@0.225.2";
import * as YAML from "jsr:@std/yaml@0.224.1";
import { toText } from "jsr:@std/streams@0.224.4";
import { decodeBase32, encodeBase32 } from "jsr:@std/encoding@0.224.3/base32";

import { sha1 } from "https://deno.land/x/sha1@v1.0.3/mod.ts";
import titleCase from "https://deno.land/x/case@2.2.0/titleCase.ts";
import { sha256 } from "https://deno.land/x/sha256@v1.0.2/mod.ts";

import * as k8s from "https://x.kite.run/lib/kubernetes.ts";

import { dotProp, homedir, jsonItem, visitAll, withTimeout } from "../utils.ts";
import { merge, MergeObject } from "../merge.ts";
import { hashObject } from "../hash-object.ts";
import * as filter from "./filter-terraform.ts";
import * as rt from "../runtypes.ts";
import { buildCleanCommand } from "../shellbox.ts";
import { yaml } from "../kite.ts";
import { addNamespace } from "./namespaces.ts";

export class TemplateError extends Error {}

const banner = `\
# File Generated by the Kite™️ Config Generation tool by @brandonkal.
# Project name=`;

/// Types ///

/**
 * TemplateConfigSpec is a shorthand representation of a KiteConfig object.
 * If the args argument contains an args object of its own, it is assumed to be a shorthand Config
 * of its own. Ultimately, it will be transformed into the canonical representation with options
 * specified by flags overriding anything set on args.
 */
export interface TemplateConfigSpec {
	/** a string representing the Kite™️ program to execute. Cannot be specified if yaml is set. */
	exec?: string;
	/** display help text for CLI usage */
	help?: boolean;
	/** These arguments will be passed to the exec program (if specified) and then the Templating function */
	args?: Record<string, any>;
	/** silence stderr except on errors */
	quiet?: boolean;
	/** Set a unique name to identify this config state */
	name?: string;
	/** Force reload of Terraform state */
	reload?: boolean;
	/** The YAML text document to Template out. Cannot be specified if exec is set. */
	yaml?: string;
	/** only render exec program. Do not Template */
	preview?: boolean;
	/**
	 * a list of environment variables that can be read during templating.
	 * If an item is a simple string, it will be pulled from the environment.
	 * If it is a mapping, the first item will be set in the execution environment.
	 */
	env?: (string | { [key: string]: string })[];
}

const rtTemplateConfigSpec = rt.Partial({
	exec: rt.String,
	help: rt.Boolean,
	quiet: rt.Boolean,
	reload: rt.Boolean,
	yaml: rt.String,
	preview: rt.Boolean,
	allowEnv: rt.Array(rt.String),
	args: rt.Record({ string: rt.Unknown }),
	name: rt.String,
});

const rtTemplateConfig = rt.Record({
	apiVersion: rt.Literal("kite.run/v1alpha1"),
	kind: rt.Literal("TemplateConfig"),
	metadata: rt.Partial({
		name: rt.String,
		_allowAnyEnv: rt.Boolean,
	}),
	spec: rtTemplateConfigSpec,
});

/** checks if an object is a canonical TemplateConfig */
export function isTemplateConfig(p: unknown): p is TemplateConfig {
	if (
		typeof p === "object" && p && "apiVersion" in p &&
		p.apiVersion === "kite.run/v1alpha1" && "kind" in p &&
		p.kind === "TemplateConfig" && "spec" in p &&
		p.spec &&
		typeof p.spec === "object"
	) {
		return true;
	}
	return false;
}

export interface TemplateConfig {
	apiVersion: "kite.run/v1alpha1";
	kind: "TemplateConfig";
	metadata: {
		/** A unique name to use for storing Terraform state. Required if TerraformConfig exists. */
		name?: string;
		/** This private parameter can only be set by the CLI. If true, env merges. */
		_allowEnv?: boolean | string[];
	};
	spec: TemplateConfigSpec;
}

/** Creates a TemplateConfig from spec property object. */
export function configFromSpec(spec: any): TemplateConfig {
	return {
		apiVersion: "kite.run/v1alpha1",
		kind: "TemplateConfig",
		metadata: {
			name: spec.name,
		},
		spec: spec,
	};
}

/// Logic ///
const timeoutMsg: Deno.ProcessStatus = {
	success: false,
	code: 0,
	signal: 255,
};
function isTimeoutMessage(x: any) {
	return x.success === false && x.signal === 255;
}

/**
 * Takes input YAML as a string and executes Terraform and Helm if required.
 * The resulting state is then queried and combined with argument inputs.
 * The resulting YAML is returned without the Terraform Resource and Helm charts rendered.
 */
export default async function template(
	cfg: TemplateConfig,
	useHelm = true,
): Promise<string> {
	cfg = rtTemplateConfig.check(cfg);
	const { spec } = cfg;
	let yamlText: string;
	if (spec.exec) {
		// Fetch dependencies first so we can limit actual execution time.
		const fp = new Deno.Command("deno", {
			args: ["cache", "--unstable", spec.exec],
			stderr: spec.quiet ? "piped" : "inherit",
			stdout: "null",
		});
		const fs = await fp.output();
		if (!fs.success) {
			if (spec.quiet) console.error(fs.stderr);
			throw new TemplateError(
				"Config program threw an Error during cache",
			);
		}

		const cmdArgs = ["run", "--unstable", spec.exec];
		if (spec.args) {
			cmdArgs.push(...["-a", JSON.stringify(spec.args)]);
		}
		if (!spec.quiet) console.error(`# Executing ${spec.exec}`);
		const p = new Deno.Command("deno", {
			args: cmdArgs,
			stderr: spec.quiet ? "piped" : "inherit",
			stdout: "piped",
		}).spawn();

		const out = await withTimeout(15e3, p.output.bind(p), timeoutMsg);
		if (isTimeoutMessage(out)) {
			p.kill("SIGABRT");
			throw new TemplateError("Config program timed out.");
		}
		const s = await p.status;
		if (!s.success) {
			if (spec.quiet) console.error(p.stderr);
			throw new TemplateError("Config program threw an Error");
		}
		yamlText = await toText(p.stdout);
	} else if (spec.yaml) {
		yamlText = spec.yaml;
	} else {
		throw new TemplateError("Either yaml or exec must be specified");
	}

	if (!spec.quiet) {
		console.error(`# Templating${spec.name ? " " + spec.name : "..."}`);
	}

	const { tfConfig, config, docs, toRemove } = getConfigFromYaml(
		yamlText,
		cfg,
	);
	const header = banner + config.metadata.name + "\n";
	if (cfg.spec.preview) {
		return `# (preview) ` + header + yamlText;
	}
	rtTemplateConfig.check(config);
	// note that config environment has been filtered by getConfigFromYaml
	const env = buildEnv(config.spec.env);

	let state: any = {};
	if (isTerraformConfig(tfConfig)) {
		// asert name exists
		const n = tfConfig?.metadata?.name;
		if (typeof n !== "string" || n === "") {
			throw new TemplateError(
				"The merged Terraform object must have a name. Supply as an argument to template or in the config.",
			);
		}
		const tf = tfConfig.spec as object;
		visitAll(tf, (value) => {
			if (typeof value === "string") {
				const m = value.match(/^{{ tf (.*)}}$/);
				if (m) {
					// Ignore pipeline for TF refs
					const [ref] = m[1].split("|");
					// Replace with something TF understands
					return `\${${ref.trim()}}`;
				}
			}
			return value;
		});
		if (!spec.quiet) console.error("# Executing Terraform...");
		state = await execTerraform(config, tf, env);
	}
	const allOps = ops(env);
	// Now return the filtered result
	const filtered = docs
		.filter((_, i) => !toRemove.has(i))
		.map((txt) => {
			return substitutePlaceholders(txt, config.spec, state, allOps)
				.trim();
		});
	// We now need to template out any Helm Charts
	const accumulated: string[] = [];
	for (const doc of filtered) {
		if (useHelm && doc.includes("HelmChart")) {
			const parsedDoc = YAML.parse(doc, {
				schema: YAML.JSON_SCHEMA,
			}) as any;
			if (isHelmChart(parsedDoc)) {
				// render the helm chart
				const chart = parsedDoc.spec.chart;
				if (chart && chart.split("/").length === 2) {
					if (
						parsedDoc.spec.valuesContent &&
						typeof parsedDoc.spec.valuesContent !== "string"
					) {
						throw new TemplateError(
							`Error: ${parsedDoc.metadata
								.name!} Kite™️ expects HelmChart.spec.valuesContent to by type (YAML) string.`,
						);
					}
					const [repoName] = chart.split("/");
					const repo = parsedDoc.spec.repo;
					if (
						repo && repo.startsWith("http") && repoName !== "stable"
					) {
						await helmFetch(repoName, repo, spec.quiet);
					}
					const helmParams = {
						chart,
						releaseName: parsedDoc.metadata.name!,
						version: parsedDoc.spec.version,
						namespace: parsedDoc.spec.targetNamespace,
						valuesContent: parsedDoc.spec.valuesContent as string,
						quiet: spec.quiet,
					};
					let manifest = "";
					const templateRun1 = await helmTemplate(helmParams);
					if (templateRun1.stderr.includes("failed to download")) {
						await helmRepoUpdate(spec.quiet);
						const templateRun2 = await helmTemplate(helmParams);
						if (templateRun2.err) throw templateRun2.err;
						manifest = templateRun2.out;
					} else {
						manifest = templateRun1.out;
					}
					const top = getComment(doc).replace(
						/^# urn/,
						"#region (rendered HelmChart) urn",
					);
					const chartResources = YAML.parseAll(manifest, {
						schema: YAML.JSON_SCHEMA,
					}) as any[];
					const comments = manifest.split(/^---/gm).map(getComment);
					if (comments[0] === "") comments.shift();
					if (comments.length > chartResources.length) {
						// If this happens, something weird is going on.
						throw new TemplateError(
							`Unexpected HelmChart ${parsedDoc.metadata?.name} rendered with more comments blocks than resources (${comments.length} vs ${chartResources.length})`,
						);
					}
					let out: [string, any][] = [];
					chartResources.forEach((item, i) => {
						out[i] = [comments[i], item];
					});
					out = out.filter((item) => {
						return item[1]?.apiVersion && item[1]?.kind;
					});
					const namespace = parsedDoc.spec.targetNamespace;
					if (namespace) {
						out = out.map(([comment, item]) => {
							return [comment, addNamespace(item, namespace)];
						});
					}
					const result = yaml.print(out, false, true);
					accumulated.push(
						top + result.replace(/^---/, "") + "\n#endregion",
					);
				} else {
					throw new TemplateError(
						`Invalid HelmChart: "${chart}". Must contain "/"`,
					);
				}
			}
		} else {
			accumulated.push(doc); // not HelmChart
		}
	}
	const result = accumulated.join("\n---\n");
	return header + addTopDashes(result) + "\n";
}

interface helmOpts {
	chart: string;
	releaseName: string;
	version?: string;
	namespace?: string;
	valuesContent?: string;
	quiet?: boolean;
}
/**
 * Execute helm template for the given values.
 * Clean up after and cache the result for the hashed inputs.
 */
async function helmTemplate(opts: helmOpts) {
	const { quiet = false } = opts;
	// option for hashing here. Though helm template isn't too slow...
	const { chart, releaseName, version, namespace, valuesContent } = opts;
	if (!quiet) console.error(`Rendering the ${chart} helm chart`);
	const cmdArgs = ["template", chart, "--name-template", releaseName];
	if (namespace) {
		cmdArgs.push("--namespace", namespace);
	}
	if (version) {
		cmdArgs.push("--version", version);
	}
	if (valuesContent) {
		cmdArgs.push("--values", "-");
	}
	if (!quiet) console.error(`Executing: ${cmdArgs.join(" ")}`);
	const te = new TextEncoder();
	const subp = new Deno.Command("helm", {
		args: cmdArgs,
		stdout: "piped",
		stderr: "piped",
		stdin: "piped",
	}).spawn();
	filter.clear();
	if (valuesContent) {
		// write values file direct to helm stdin
		subp.stdin.getWriter().write(te.encode(valuesContent));
		subp.stdin.close();
	}
	const s = await subp.status;
	let stderr = "";
	if (!s.success) {
		stderr = await toText(subp.stderr);
		console.error(stderr);
		return {
			out: "",
			stderr,
			err: new TemplateError("helm template failed"),
		};
	}
	const out = await toText(subp.stdout);
	if (out === "") {
		return {
			out,
			stderr,
			err: new TemplateError(`helm template returned empty `),
		};
	}
	return { out, stderr, err: undefined };
}

async function helmFetch(repoName: string, repo: string, quiet = false) {
	if (!quiet) console.error(`Checking for ${repoName} helm repo`);
	let shouldFetch = true;
	try {
		const check = new Deno.Command("helm", {
			args: ["repo", "ls", "-o", "json"],
			stdout: "piped",
			stderr: "piped",
		}).spawn();
		filter.clear();
		filter.stream(check.stderr, quiet);
		const cs = await check.status;
		if (!cs.success) {
			if (quiet) console.error(filter.flush());
			throw new TemplateError("helm repo ls failed");
		}
		const out: { name: string; url: string }[] = JSON.parse(
			await toText(check.stdout),
		);
		const search = {
			name: repoName,
			url: repo,
		};
		if (out.includes(search)) shouldFetch = false;
	} catch (_e) {
		console.error("helm repo ls failed");
		shouldFetch = true;
	}
	if (shouldFetch) {
		if (!quiet) console.error(`Adding the ${repoName} helm repo`);
		// adds or updates the given repo
		const pa = new Deno.Command("helm", {
			args: ["repo", "add", repoName, repo],
			stdout: "piped",
			stderr: "piped",
		}).spawn();
		filter.clear();
		filter.stream(pa.stderr, quiet);
		filter.stream(pa.stdout, quiet);
		const s = await pa.status;
		if (!s.success) {
			if (quiet) console.error(filter.flush());
			throw new TemplateError("helm repo add failed");
		}
	}
}

async function helmRepoUpdate(quiet = false) {
	if (!quiet) console.error(`Updating helm repos`);
	const update = new Deno.Command("helm", {
		args: ["repo", "update"],
		stdout: "piped",
		stderr: "piped",
	}).spawn();
	filter.clear();

	filter.stream(update.stdout, quiet);
	filter.stream(update.stderr, quiet);
	const cs = await update.status;
	if (!cs.success) {
		if (quiet) console.error(filter.flush());
		throw new TemplateError("helm repo update failed");
	}
}

function isHelmChart(desc: any): desc is k8s.helm.Chart {
	if (
		desc &&
		desc.apiVersion === "helm.cattle.io/v1" &&
		desc.kind === "HelmChart" &&
		desc.spec
	) {
		return true;
	}
	return false;
}

/** extract comments from YAML and move it to the top. */
function getComment(doc: string) {
	const commentLines = doc
		.split("\n")
		.map((l) => l.trimStart())
		.filter((l) => l.startsWith("#"));
	let header = "";
	if (commentLines.length) {
		header = commentLines.join("\n") + "\n";
	}
	return header;
}

/**
 * extracts merged TerraformConfig and TemplateConfig objects.
 * Returns metadata on which docs should be removed and an array of docs to join.
 * @internal
 */
export function getConfigFromYaml(yamlText: string, cfg: TemplateConfig) {
	yamlText = addTopDashes(yamlText);
	const docs = yamlText.split(/^---\n/m);
	const toRemove = new Set<number>();
	docs.forEach((doc, i) => {
		if (!doc.includes(": ")) {
			toRemove.add(i);
		}
	});
	const parsedDocs = docs.map((yamlDoc, i) => {
		if (toRemove.has(i)) return {};
		return YAML.parse(yamlDoc, { schema: YAML.JSON_SCHEMA }) as any;
	});
	const kiteConfigs: TemplateConfig[] = [];
	const terraformConfigs: any[] = [];
	parsedDocs.forEach((doc, i) => {
		if (doc == null) {
			// Document likely only contains comments
			toRemove.add(i);
		} else if (isTerraformConfig(doc)) {
			terraformConfigs.push(doc);
			toRemove.add(i);
		} else if (isTemplateConfig(doc)) {
			kiteConfigs.push(doc);
			toRemove.add(i);
		}
	});
	let config = {} as TemplateConfig;
	if (kiteConfigs.length) {
		kiteConfigs.forEach((cfgN) => {
			config = merge(config, cfgN);
		});
	}
	// As a security measure, this private value can only come via CLI args
	if (config?.metadata?._allowEnv) {
		delete config.metadata._allowEnv;
	}
	config = merge(config, cfg, templateConfigMergeObject(cfg));
	let tfConfig: any = {};
	terraformConfigs.forEach((cfg) => {
		tfConfig = merge(tfConfig, cfg);
	});
	const name = config.metadata.name;
	if (name !== undefined) {
		tfConfig = merge(tfConfig, { metadata: { name: name } });
		config.spec.name = name;
	}
	return { tfConfig, config, docs, toRemove };
}

function addTopDashes(yamlText: string) {
	yamlText = yamlText.trimStart();
	if (!yamlText.startsWith("---")) {
		// This is required for counting to function
		yamlText = "---\n" + yamlText;
	}
	return yamlText;
}

function isTerraformConfig(p: unknown): boolean {
	if (
		typeof p === "object" && p && "apiVersion" in p &&
		p.apiVersion === "kite.run/v1alpha1" && "kind" in p &&
		p.kind === "Terraform" && "spec" in p &&
		p.spec &&
		typeof p.spec === "object"
	) {
		return true;
	}
	return false;
}

const placeholderRe = /\(\((.+?)\)\)/g;

const yamlSpecials = [
	"-",
	"%",
	"!",
	"&",
	"*",
	" ",
	"?",
	"{",
	"[",
	"]",
	"}",
	",",
	"#",
	"|",
	">",
	"@",
	"`",
	'"',
	"'",
];

/** Test if string requires quotes per YAML rules */
function mustQuote(str: string) {
	// http://blogs.perl.org/users/tinita/2018/03/strings-in-yaml---to-quote-or-not-to-quote.html
	return (
		yamlSpecials.includes(str.charAt(0)) ||
		str.includes(": ") ||
		str.includes(" #")
	);
}

/** removes placeholders using Terraform state values */
function substitutePlaceholders(
	str: string,
	spec: TemplateConfigSpec,
	state: unknown,
	/** The operation map */
	allOps: Record<string, (a: unknown) => unknown>,
): string {
	let madeReplace = false;
	parseCache.clear();
	// match inside (( param ))
	const out = str.replace(placeholderRe, (_, dslText) => {
		const r = parseDSL(dslText, spec, state, allOps);
		if (r === undefined || r === "undefined") {
			throw new TemplateError(`${dslText} returned ${r}`);
		}
		madeReplace = true;
		const stringified = JSON.stringify(r);
		// remove quotes if not required in YAML
		if (
			stringified.startsWith('"') &&
			stringified.endsWith('"') &&
			stringified !== '"true"' &&
			stringified !== '"false"'
		) {
			const unquoted = stringified.replace(/^"/, "").replace(/"$/, "");
			if (unquoted === r) {
				if (!mustQuote(unquoted)) {
					return r;
				}
			}
		}
		return stringified;
	});
	// If a replacement was made, we parse as YAML and reserialize.
	// In this case, all comments are moved to the top.
	if (madeReplace) {
		const header = getComment(out);
		const yml = yaml.print(YAML.parse(out), false);
		return header + yml;
	}
	return out;
}

const envarNameRe = /^[a-zA-Z_]\w*$/;

function assertValidEnvarName(envar: string) {
	if (!envar.match(envarNameRe)) {
		throw new TemplateError(`Invalid envar name`);
	}
}

/** builds an environment based on allowed environment variables in config */
function buildEnv(
	envars: (string | Record<string, string>)[] = [],
): Record<string, string> {
	const tfEnv: Record<string, string> = {};
	if (envars && Array.isArray(envars)) {
		envars.forEach((envar) => {
			let value: string | undefined;
			if (typeof envar === "string") {
				assertValidEnvarName(envar);
				value = Deno.env.get(envar);
			} else {
				[envar, value] = Object.entries(envar)[0];
			}
			if (value !== undefined && typeof envar === "string") {
				assertValidEnvarName(envar);
				tfEnv[envar] = value;
			}
		});
	}
	tfEnv.TF_INPUT = "0";
	tfEnv.TF_IN_AUTOMATION = "true";
	return tfEnv;
}

type StringRecord = Record<string, string>;

/**
 * execute Terraform as a process for given JSON and return state object.
 * @internal
 */
async function execTerraform(
	config: TemplateConfig,
	tfConfig: object,
	env: StringRecord,
) {
	const name = config.metadata.name!;
	const quiet = config.spec.quiet || false;
	const forceApply = config.spec.reload;
	const home = homedir();
	if (!home) {
		throw new TemplateError("Could not locate home directory");
	}
	const tfDir = path.join(home, ".kite", name);
	const tfFile = path.join(tfDir + "/kite.tf.json");
	const hashFile = path.join(tfDir + "/env.hash");
	await fs.ensureDir(tfDir);
	const cfgText = JSON.stringify(tfConfig, undefined, 2);
	if (cfgText.includes("local-exec")) {
		throw new TemplateError(
			"local-exec is not allowed on the Kite™️ platform.",
		);
	}
	// Terraform is rather slow. So if the config has not changed, short-circuit.
	let currentContents: string;
	const envHash = await hashObject(env);
	let willRun = true;
	if (!forceApply) {
		if (await fs.exists(tfFile)) {
			currentContents = await Deno.readTextFile(tfFile);
			if (cfgText === currentContents) {
				// Has the environment changed?
				let lastHash = "";
				if (await fs.exists(hashFile)) {
					lastHash = await Deno.readTextFile(hashFile);
				}
				if (lastHash === envHash) {
					willRun = false;
				}
				if (!quiet && !willRun) {
					console.error(
						"# TerraformConfig unchanged. Skipping apply.",
					);
				}
			}
		}
	}

	async function backup() {
		const bak = tfFile + ".bak";
		try {
			const exists = await fs.exists(bak);
			if (exists) await Deno.remove(bak);
			await fs.move(tfFile, bak);
		} catch (e) {
			console.error("Backup failure:", e.message || e);
		}
	}

	if (willRun) {
		await Deno.writeTextFile(tfFile, cfgText);
		const hashPromise = Deno.writeTextFile(hashFile, envHash);
		// Ensure tf config exists
		const tfConfigPath = path.join(home, ".terraformrc");
		const hasTF = await fs.exists(tfConfigPath);
		if (!hasTF) {
			const tfConfig =
				`plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"\ndisable_checkpoint = true\n`;
			await Deno.writeTextFile(tfConfigPath, tfConfig);
		}

		const init = new Deno.Command("terraform", {
			args: ["terraform", "init", "-no-color"],
			cwd: tfDir,
			stdout: "piped",
			stderr: "piped",
			env,
		}).spawn();
		filter.clear();
		filter.stream(init.stderr, quiet);
		filter.stream(init.stdout, quiet);
		let s = await init.status;
		if (!s.success) {
			if (quiet) console.error(filter.flush());
			await backup();
			throw new TemplateError("Terraform init failed");
		}

		const applyCmd = buildCleanCommand(
			[
				"apply",
				"-auto-approve",
				"-no-color",
				"-compact-warnings",
			],
			env,
			tfDir,
		);

		const apply = new Deno.Command("terraform", {
			args: applyCmd,
			cwd: tfDir,
			stderr: "piped",
			stdout: "piped",
		}).spawn();

		filter.clear();
		filter.stream(apply.stderr, quiet);
		filter.stream(apply.stdout, quiet);
		s = await apply.status;
		if (!s.success) {
			if (quiet) console.error(filter.flush());
			await backup();
			throw new TemplateError("Terraform apply failed");
		}
		await hashPromise;
	}

	// Now suck in the needed state
	const show = new Deno.Command("terraform", {
		args: ["show", "-json"],
		stdout: "piped",
		stderr: "piped",
		cwd: tfDir,
		env,
	}).spawn();
	filter.clear();
	filter.stream(show.stderr, quiet);
	const s = await show.status;
	if (!s.success) {
		if (quiet) console.error(filter.flush());
		throw new TemplateError("Terraform show -json failed");
	}
	const json = await toText(show.stdout);
	if (!config.spec.quiet) {
		console.error(); // log empty line before printing YAML output.
	}
	return JSON.parse(json); /* state */
}

/** Can this value exist in a JSON document? */
function isPrimitive(item: unknown): item is jsonItem {
	const t = typeof item;
	if (
		t === "string" || t === "boolean" || t === "number" || item === "null"
	) {
		return true;
	}
	return false;
}

/**
 * find a Terraform value from `terraform show -json` output
 */
function findTerraformValue(state: any, path: string): jsonItem {
	function find() {
		let parts = path.split(".");
		const resources: any[] = state?.values?.root_module?.resources;
		if (Array.isArray(resources)) {
			const found = resources.find((res) => {
				return res.type === parts[0] && res.name === parts[1];
			});
			if (parts.length === 2) {
				if (isPrimitive(found)) {
					return found;
				} else if (isPrimitive(found?.values)) {
					return found.values;
				}
			}
			if (found?.values) {
				parts = parts.slice(2);
				return dotProp(found.values, parts);
			}
		}
		return undefined;
	}
	const result = find();
	if (!isPrimitive(result)) {
		throw new TemplateError(
			`Invalid interpolated value for ${path}. Expected string|boolean|number|null. Got ${result}`,
		);
	}
	return result;
}

const same = (x: any) => x;

type OpMap = Record<string, (a: any) => any>;

function ops(envars: Record<string, string | undefined>) {
	const map: OpMap = {
		// default requires special logic
		default: same,
		int: (a) => {
			const n = parseInt(a, 10);
			if (Number.isNaN(n)) {
				throw new TemplateError(`could not parse "${a}" as an integer`);
			}
			return n;
		},
		number: (a) => {
			const n = Number(a);
			if (Number.isNaN(n)) {
				throw new TemplateError(`could not parse "${a}" as number`);
			}
			return n;
		},
		trim: (a: string) => a.trim(),
		upper: (a: string) => a.toUpperCase(),
		lower: (a: string) => a.toLowerCase(),
		title: titleCase,
		toString: (a: any) => String(a),
		env: (a: string) => {
			const envar = envars[a];
			if (envar === undefined) {
				throw new TemplateError(
					`Environment variable ${a} is undefined or access is disabled`,
				);
			}
			return envar;
		},
		boolean: (a) => Boolean(a),
		b64enc: btoa,
		b64dec: atob,
		b32enc: (a: string) => {
			const binary = new TextEncoder().encode(a);
			return encodeBase32(binary);
		},
		b32dec: (a: string) => {
			const decoded = decodeBase32(a);
			return new TextDecoder().decode(decoded);
		},
		sha1sum: (a: string) => sha1(a, "utf8", "hex"),
		sha256sum: (a: string) => sha256(a, "utf8", "hex"),
		toJson: (a) => JSON.stringify(a),
		arg: same, // Requires custom logic
		tf: same, // custom logic
	};
	return map;
}

const opsRe = new RegExp("^" + Object.keys(ops({})).join("|"));

const ROOK = "♜";

const parseCache = new Map<string, any>();

/**
 * parses DSL and returns the result
 * @param input The string to parse
 * @param spec represents available args to evaluate template
 * @param tfState represents Terraform state object
 */
function parseDSL(
	input: string,
	spec: TemplateConfigSpec,
	tfState: any,
	allOps: OpMap,
) {
	const { args } = spec;
	input = input.trim();
	if (parseCache.has(input)) {
		return parseCache.get(input);
	}
	const withRook = input.replace("\\|", ROOK);
	const parts = withRook.split("|").map((it) => it.replace(ROOK, "|").trim());
	if (parts.some((v) => v === "")) {
		throw new TemplateError(
			`Unexpected empty operation in expression: "${input}"`,
		);
	}
	let last: any;
	parts.forEach((part, i) => {
		let txt = part;
		const m = opsRe.exec(txt);
		if (m && m.length) {
			const op = m[0];
			const re = new RegExp(`^${op}`);
			txt = txt.replace(re, "").trim();
			if (i === 0) last = txt;
			if (i === 0 && txt === "") {
				throw new TemplateError(
					`First operation must contain a value in expression: "${input}"`,
				);
			}
			if (op === "default") {
				last = last || txt;
			} else if (op === "arg" && args) {
				dotProp(args, txt);
			} else if (op === "tf") {
				if (i !== 0) {
					throw new TemplateError(
						`Terraform lookup is only allowed at the start of a pipeline. While parsing value "${input}"`,
					);
				}
				last = findTerraformValue(tfState, txt);
			} else {
				last = allOps[op](last);
			}
		} else if (args) {
			last = dotProp(args, txt);
		}
	});
	return last;
}

/**
 * Builds a config merge object where env is filtered.
 * env is merged and then filtered by the contents of the
 * private allowEnv key.
 */
export function templateConfigMergeObject(
	objectB: TemplateConfig,
): MergeObject<TemplateConfig> {
	const allowEnv = objectB.metadata._allowEnv;
	return {
		spec: {
			//@ts-ignore -- Deno is wrong here
			env: (a, b) => {
				function getArray() {
					if (a === undefined) {
						if (Array.isArray(b)) {
							return b;
						}
						return [];
					} else if (b === undefined) {
						return [];
					}
					// merge and deduplicate
					return Array.from(new Set([...a, ...b]));
				}
				// filter result for allowEnv
				return getArray().filter((item) => {
					// string values access the environment. So we must filter them.
					if (typeof item === "string") {
						if (!allowEnv) {
							return false;
						} else if (Array.isArray(allowEnv)) {
							return allowEnv.includes(item);
						}
					}
					return true;
				});
			},
		},
	};
}
