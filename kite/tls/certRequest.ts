/**
 * @author Brandon Kalinowski
 * @copyright 2020 Brandon Kalinowski
 * @license Not Provided. Contact for details.
 */
// *** WARNING: this file was generated by the Kite Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as kite from 'https://deno.land/x/lib/kite.ts'
import * as inputs from './types/input.ts'
import * as outputs from './types/output.ts'

/**
 * > This content is derived from https://github.com/terraform-providers/terraform-provider-tls/blob/master/website/docs/r/cert_request.html.md.
 */
export class CertRequest extends kite.Resource {
	/**
	 * The certificate request data in PEM format.
	 */
	public readonly /*out*/ certRequestPem!: string
	/**
	 * List of DNS names for which a certificate is being requested.
	 */
	public readonly dnsNames!: string[] | undefined
	/**
	 * List of IP addresses for which a certificate is being requested.
	 */
	public readonly ipAddresses!: string[] | undefined
	/**
	 * The name of the algorithm for the key provided
	 * in `privateKeyPem`.
	 */
	public readonly keyAlgorithm!: string
	/**
	 * PEM-encoded private key that the certificate will belong to
	 */
	public readonly privateKeyPem!: string
	/**
	 * The subject for which a certificate is being requested. This is
	 * a nested configuration block whose structure is described below.
	 */
	public readonly subjects!: outputs.CertRequestSubject[]
	/**
	 * List of URIs for which a certificate is being requested.
	 */
	public readonly uris!: string[] | undefined

	/**
	 * Create a CertRequest resource with the given unique name, arguments, and options.
	 *
	 * @param name The _unique_ name of the resource.
	 * @param args The arguments to use to populate this resource's properties.
	 */
	constructor(name: string, args: CertRequestArgs) {
		let inputs: any = {}
		if (!args || args.keyAlgorithm === undefined) {
			throw new Error("Missing required property 'keyAlgorithm'")
		}
		if (!args || args.privateKeyPem === undefined) {
			throw new Error("Missing required property 'privateKeyPem'")
		}
		if (!args || args.subjects === undefined) {
			throw new Error("Missing required property 'subjects'")
		}
		inputs.dnsNames = args ? args.dnsNames : undefined
		inputs.ipAddresses = args ? args.ipAddresses : undefined
		inputs.keyAlgorithm = args ? args.keyAlgorithm : undefined
		inputs.privateKeyPem = args ? args.privateKeyPem : undefined
		inputs.subjects = args ? args.subjects : undefined
		inputs.uris = args ? args.uris : undefined
		super(name, inputs)
		this.setType(CertRequest.__kiteType)
		this.certRequestPem = `(( tf ${this.id()}.cert_request_pem ))` as any /*out*/
	}
	/**
	 * Used to map camelCased properties to Terraform snake_case
	 * @internal
	 */
	static convertMap: Record<string, string> = {
		dnsNames: 'dns_names',
		ipAddresses: 'ip_addresses',
		keyAlgorithm: 'key_algorithm',
		privateKeyPem: 'private_key_pem',
		subjects: 'subject',
		uris: 'uris',
		certRequestPem: 'undefined',
	}

	/**
	 * Transforms the Resource instance into the Terraform JSON representation.
	 * @internal
	 */
	convert() {
		const props: any = {}
		Object.entries(this).forEach(([key, value]) => {
			const newKey = CertRequest.convertMap[key]
			if (!newKey) {
				throw new Error(
					`Could not print key: ${key}. Not found in ${
						(this as any).__type
					} spec.`
				)
			}
			if (newKey !== 'undefined' /* out */) {
				props[newKey] = value
			}
		})
		return {
			terraform: {
				required_providers: {
					tls: '~> 2.1',
				},
			},
			resource: {
				tls_cert_request: { [this.__name]: props },
			},
		}
	}

	/** @internal */
	public static readonly __kiteType = 'tf:tls:index/certRequest:CertRequest'
	/** @internal */
	public static readonly __tfType = 'tls_cert_request'

	/** @internal */
	public id() {
		return CertRequest.__tfType + '.' + this.__name
	}
}

/**
 * The set of arguments for constructing a CertRequest resource.
 */
export interface CertRequestArgs {
	/**
	 * List of DNS names for which a certificate is being requested.
	 */
	readonly dnsNames?: string[]
	/**
	 * List of IP addresses for which a certificate is being requested.
	 */
	readonly ipAddresses?: string[]
	/**
	 * The name of the algorithm for the key provided
	 * in `privateKeyPem`.
	 */
	readonly keyAlgorithm: string
	/**
	 * PEM-encoded private key that the certificate will belong to
	 */
	readonly privateKeyPem: string
	/**
	 * The subject for which a certificate is being requested. This is
	 * a nested configuration block whose structure is described below.
	 */
	readonly subjects: inputs.CertRequestSubject[]
	/**
	 * List of URIs for which a certificate is being requested.
	 */
	readonly uris?: string[]
}
