/**
 * @author Brandon Kalinowski
 * @copyright 2020 Brandon Kalinowski
 * @license Not Provided. Contact for details.
 */
// *** WARNING: this file was generated by the Kite Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as kite from 'https://deno.land/x/lib/kite.ts'
import * as inputs from './types/input.ts'
import * as outputs from './types/output.ts'

import { Algorithm, Region } from './mod.ts'

/**
 * Provides a DigitalOcean Load Balancer resource. This can be used to create,
 * modify, and delete Load Balancers.
 *
 * > This content is derived from https://github.com/terraform-providers/terraform-provider-digitalocean/blob/master/website/docs/r/loadbalancer.html.markdown.
 */
export class LoadBalancer extends kite.Resource {
	/**
	 * The load balancing algorithm used to determine
	 * which backend Droplet will be selected by a client. It must be either `roundRobin`
	 * or `leastConnections`. The default value is `roundRobin`.
	 */
	public readonly algorithm!: Algorithm | undefined
	/**
	 * A list of the IDs of each droplet to be attached to the Load Balancer.
	 */
	public readonly dropletIds!: number[]
	/**
	 * The name of a Droplet tag corresponding to Droplets to be assigned to the Load Balancer.
	 */
	public readonly dropletTag!: string | undefined
	/**
	 * A boolean value indicating whether PROXY
	 * Protocol should be used to pass information from connecting client requests to
	 * the backend service. Default value is `false`.
	 */
	public readonly enableProxyProtocol!: boolean | undefined
	/**
	 * A list of `forwardingRule` to be assigned to the
	 * Load Balancer. The `forwardingRule` block is documented below.
	 */
	public readonly forwardingRules!: outputs.LoadBalancerForwardingRule[]
	/**
	 * A `healthcheck` block to be assigned to the
	 * Load Balancer. The `healthcheck` block is documented below. Only 1 healthcheck is allowed.
	 */
	public readonly healthcheck!: outputs.LoadBalancerHealthcheck
	public readonly /*out*/ ip!: string
	/**
	 * The Load Balancer name
	 */
	public readonly name!: string
	/**
	 * A boolean value indicating whether
	 * HTTP requests to the Load Balancer on port 80 will be redirected to HTTPS on port 443.
	 * Default value is `false`.
	 */
	public readonly redirectHttpToHttps!: boolean | undefined
	/**
	 * The region to start in
	 */
	public readonly region!: Region
	public readonly /*out*/ status!: string
	/**
	 * A `stickySessions` block to be assigned to the
	 * Load Balancer. The `stickySessions` block is documented below. Only 1 stickySessions block is allowed.
	 */
	public readonly stickySessions!: outputs.LoadBalancerStickySessions
	/**
	 * The uniform resource name for the Load Balancer
	 */
	public readonly /*out*/ urn!: string

	/**
	 * Create a LoadBalancer resource with the given unique name, arguments, and options.
	 *
	 * @param name The _unique_ name of the resource.
	 * @param args The arguments to use to populate this resource's properties.
	 */
	constructor(name: string, args: LoadBalancerArgs) {
		let inputs: any = {}
		if (!args || args.forwardingRules === undefined) {
			throw new Error("Missing required property 'forwardingRules'")
		}
		if (!args || args.region === undefined) {
			throw new Error("Missing required property 'region'")
		}
		inputs.algorithm = args ? args.algorithm : undefined
		inputs.dropletIds = args ? args.dropletIds : undefined
		inputs.dropletTag = args ? args.dropletTag : undefined
		inputs.enableProxyProtocol = args ? args.enableProxyProtocol : undefined
		inputs.forwardingRules = args ? args.forwardingRules : undefined
		inputs.healthcheck = args ? args.healthcheck : undefined
		inputs.name = args ? args.name : undefined
		inputs.redirectHttpToHttps = args ? args.redirectHttpToHttps : undefined
		inputs.region = args ? args.region : undefined
		inputs.stickySessions = args ? args.stickySessions : undefined
		super(name, inputs)
		this.setType(LoadBalancer.__kiteType)
		this.ip = `(( tf ${this.id()}.ip ))` as any /*out*/
		this.status = `(( tf ${this.id()}.status ))` as any /*out*/
		this.urn = `(( tf ${this.id()}.urn ))` as any /*out*/
	}
	/**
	 * Used to map camelCased properties to Terraform snake_case
	 * @internal
	 */
	static convertMap: Record<string, string> = {
		algorithm: 'algorithm',
		dropletIds: 'droplet_ids',
		dropletTag: 'droplet_tag',
		enableProxyProtocol: 'enable_proxy_protocol',
		forwardingRules: 'forwarding_rule',
		healthcheck: 'healthcheck',
		name: 'name',
		redirectHttpToHttps: 'redirect_http_to_https',
		region: 'region',
		stickySessions: 'sticky_sessions',
		ip: 'undefined',
		status: 'undefined',
		urn: 'undefined',
	}

	/**
	 * Transforms the Resource instance into the Terraform JSON representation.
	 * @internal
	 */
	convert() {
		const props: any = {}
		Object.entries(this).forEach(([key, value]) => {
			const newKey = LoadBalancer.convertMap[key]
			if (!newKey) {
				throw new Error(
					`Could not print key: ${key}. Not found in ${
						(this as any).__type
					} spec.`
				)
			}
			if (newKey !== 'undefined' /* out */) {
				props[newKey] = value
			}
		})
		return {
			terraform: {
				required_providers: {
					digitalocean: '~> 1.13.0',
				},
			},
			resource: {
				digitalocean_loadbalancer: { [this.__name]: props },
			},
		}
	}

	/** @internal */
	public static readonly __kiteType =
		'tf:digitalocean:index/loadBalancer:LoadBalancer'
	/** @internal */
	public static readonly __tfType = 'digitalocean_loadbalancer'

	/** @internal */
	public id() {
		return LoadBalancer.__tfType + '.' + this.__name
	}
}

/**
 * The set of arguments for constructing a LoadBalancer resource.
 */
export interface LoadBalancerArgs {
	/**
	 * The load balancing algorithm used to determine
	 * which backend Droplet will be selected by a client. It must be either `roundRobin`
	 * or `leastConnections`. The default value is `roundRobin`.
	 */
	readonly algorithm?: Algorithm
	/**
	 * A list of the IDs of each droplet to be attached to the Load Balancer.
	 */
	readonly dropletIds?: number[]
	/**
	 * The name of a Droplet tag corresponding to Droplets to be assigned to the Load Balancer.
	 */
	readonly dropletTag?: string
	/**
	 * A boolean value indicating whether PROXY
	 * Protocol should be used to pass information from connecting client requests to
	 * the backend service. Default value is `false`.
	 */
	readonly enableProxyProtocol?: boolean
	/**
	 * A list of `forwardingRule` to be assigned to the
	 * Load Balancer. The `forwardingRule` block is documented below.
	 */
	readonly forwardingRules: inputs.LoadBalancerForwardingRule[]
	/**
	 * A `healthcheck` block to be assigned to the
	 * Load Balancer. The `healthcheck` block is documented below. Only 1 healthcheck is allowed.
	 */
	readonly healthcheck?: inputs.LoadBalancerHealthcheck
	/**
	 * The Load Balancer name
	 */
	readonly name?: string
	/**
	 * A boolean value indicating whether
	 * HTTP requests to the Load Balancer on port 80 will be redirected to HTTPS on port 443.
	 * Default value is `false`.
	 */
	readonly redirectHttpToHttps?: boolean
	/**
	 * The region to start in
	 */
	readonly region: Region
	/**
	 * A `stickySessions` block to be assigned to the
	 * Load Balancer. The `stickySessions` block is documented below. Only 1 stickySessions block is allowed.
	 */
	readonly stickySessions?: inputs.LoadBalancerStickySessions
}
